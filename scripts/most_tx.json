[
 {
  "source": "contract AmIOnTheFork {\r\n    function forked() constant returns(bool);\r\n}\r\n\r\ncontract ReplaySafeSplit {\r\n    // Fork oracle to use\r\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\r\n\r\n    // Splits the funds into 2 addresses\r\n    function split(address targetFork, address targetNoFork) returns(bool) {\r\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\r\n            return true;\r\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\r\n            return true;\r\n        }\r\n        throw; // don't accept value transfer, otherwise it would be trapped.\r\n    }\r\n\r\n    // Reject value transfers.\r\n    function() {\r\n        throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ReplaySafeSplit", 
  "transactions": "184836", 
  "address": "0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444"
 }, 
 {
  "source": "/*\n\n- Bytecode Verification performed was compared on second iteration -\n\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic, standardized Token contract with no \"premine\". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic account, used by the DAO contract to separately manage both the rewards \nand the extraBalance accounts. \n*/\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n * Token Creation contract, used by the DAO to create its tokens and initialize\n * its ether. Feel free to modify the divisor method to implement different\n * Token Creation parameters\n*/\n\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks > now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days > now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0\n            || _debatingPeriod < minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}", 
  "balance": "7<b>.</b>565996705823359927 Ether", 
  "name": "DAO", 
  "transactions": "168208", 
  "address": "0xbb9bc244d798123fde783fcc1c72d3bb8c189413"
 }, 
 {
  "source": "contract AmIOnTheFork {\r\n    function forked() constant returns(bool);\r\n}\r\n\r\ncontract ReplaySafeSplit {\r\n    // Fork oracle to use\r\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\r\n\r\n    event e(address a);\r\n\t\r\n    // Splits the funds into 2 addresses\r\n    function split(address targetFork, address targetNoFork) returns(bool) {\r\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\r\n\t\t\te(targetFork);\r\n            return true;\r\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\r\n\t\t\te(targetNoFork);\t\t\r\n            return true;\r\n        }\r\n        throw; // don't accept value transfer, otherwise it would be trapped.\r\n    }\r\n\r\n    // Reject value transfers.\r\n    function() {\r\n        throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ReplaySafeSplit", 
  "transactions": "123263", 
  "address": "0xe94b04a0fed112f3664e45adb2b8915693dd5ff3"
 }, 
 {
  "source": "pragma solidity ^0.4.4;\r\n/*\r\n* This is a contract for debloating the state\r\n* @author mhswende\r\n**/\r\ncontract Sweeper\r\n{\r\n    //Solidity implentation\r\n    function sol_clean(uint256 s, uint i){\r\n        uint x = s;\r\n        address b = 0;\r\n        for(uint c=0 ; c < i ; c++){\r\n            x = x+s;\r\n            b = address(x/0x1000000000000000000000000);\r\n            b.send(0);\r\n\r\n        }\r\n    }\r\n    //Asm implementation\r\n    function asm_clean(uint s, uint i)\r\n    {\r\n\r\n        assembly{\r\n            let seed := calldataload(4)//4 if we're using a named function\r\n            let iterations := calldataload(36)\r\n            let target :=seed\r\n        \r\n        loop:\r\n            target := add(target,seed)\r\n            pop(call(0,div(target,0x1000000000000000000000000),0,0,0,0,0))\r\n            iterations := sub(iterations,1) \r\n            jumpi(loop, iterations)\r\n        }\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "Sweeper", 
  "transactions": "35370", 
  "address": "0xa43ebd8939d8328f5858119a3fb65f65c864c6dd"
 }, 
 {
  "source": "// Ethereum Name Registrar as it should be!\r\n//\r\n// Written by Alexandre Naverniouk\r\n// twitter @AlexNa\r\n\r\n\r\ncontract EtherId {\r\n\r\nuint constant MAX_PROLONG = 2000000; // Maximum number of blocks to prolong the ownership. About one year.\r\n\r\nuint public n_domains = 0;      // total number of registered domains\r\nuint public root_domain = 0;    // name of the first domain in the linked list\r\naddress contract_owner = 0; //\r\n\r\nstruct Id {                     // Id record. Double linked list. Allows to delete ID\r\n    uint value;\r\n    uint next_id;\r\n    uint prev_id;\r\n}\r\n\r\nstruct Domain {                 // Domain record. Linked list. \r\n    address owner;              // Owner of the domain\r\n    uint expires;               // Expiration block namber\r\n    uint price;                 // Sale price ( 0 - not for sale )\r\n    address transfer;           // Address of the new owner\r\n    uint next_domain;           // Makes linked list for scanning\r\n    uint root_id;               // Name of the first ID in the list\r\n    mapping (uint => Id) ids;   // Map of the ID's\r\n}\r\n\r\nmapping (uint => Domain) domains; // Map of the domains\r\n\r\nfunction EtherId()\r\n{\r\n    contract_owner = msg.sender;\r\n}\r\n\r\nevent DomainChanged( address indexed sender, uint domain, uint id ); // Fired every time the registry is changed\r\n\r\nfunction getId( uint domain, uint id ) constant returns (uint v, uint next_id, uint prev_id )\r\n{\r\n    Id i = domains[domain].ids[id]; \r\n\r\n    v = i.value;\r\n    next_id = i.next_id;\r\n    prev_id = i.prev_id;\r\n}\r\n\r\nfunction getDomain( uint domain ) constant returns \r\n    (address owner, uint expires, uint price, address transfer, uint next_domain, uint root_id )\r\n{\r\n    Domain d = domains[ domain ];\r\n    \r\n    owner = d.owner;\r\n    expires = d.expires;\r\n    price = d.price;\r\n    transfer = d.transfer;\r\n    next_domain = d.next_domain;\r\n    root_id = d.root_id;    \r\n}\r\n\r\n\r\nfunction changeDomain( uint domain, uint expires, uint price, address transfer ) \r\n{\r\n    uint money_used = 0;            // How much was spent here\r\n\r\n    if( expires > MAX_PROLONG )     // Not prolong for too long\r\n    {\r\n        expires = MAX_PROLONG;\r\n    }\r\n    \r\n    if( domain == 0 ) throw;        // Prevents creating 0 domain\r\n\r\n    Domain d = domains[ domain ];\r\n\r\n    if( d.owner == 0 )              // 0 means the domain is not yet registered\r\n    { \r\n        d.owner = msg.sender;       // Simple calim\r\n        d.price = price;\r\n        d.transfer = transfer;\r\n        d.expires = block.number + expires;\r\n        \r\n        d.next_domain = root_domain;// Put the new domain into the linked list\r\n        root_domain = domain;\r\n        \r\n        //****************************************************************************\r\n        //*** SPECIAL CODE FOR TRANSFERING FIRST 32301 DOMAINS INTO THE NEW CONTRACT\r\n        if( msg.sender == contract_owner && n_domains < 32301 && transfer != 0 ) { \r\n            d.owner = transfer; // immediately transfer the ownership to the old owner\r\n            d.transfer = 0;\r\n        }\r\n        //****************************************************************************\r\n        \r\n        \r\n        n_domains = n_domains + 1;\r\n        DomainChanged( msg.sender, domain, 0 );\r\n    }\r\n    else                            // The domain already has an owner\r\n    {\r\n        if( d.owner == msg.sender || block.number > d.expires ) { // If it is yours or expired, you have all rights to change\r\n            d.owner = msg.sender;   // Possible change of the ownershp if expired\r\n            d.price = price;\r\n            d.transfer = transfer;\r\n            d.expires = block.number + expires;\r\n            DomainChanged( msg.sender, domain, 0 );\r\n        }\r\n        else                        // Not yours and not expired\r\n        {\r\n            if( d.transfer != 0 ) { // The new owner is specified and ...\r\n                if( d.transfer == msg.sender && msg.value >= d.price ) // ... it is you and enought money \r\n                {\r\n                    if( d.price > 0 ) \r\n                    { \r\n                        if( address( d.owner ).send( d.price ) ) // The money goes to the owner\r\n                        {\r\n                            money_used = d.price;   // remember how much spent\r\n                        }\r\n                        else throw; // problem with send()\r\n                    }\r\n\r\n                    d.owner = msg.sender;   // Change the ownership\r\n                    d.price = price;        // New price\r\n                    d.transfer = transfer;  // New transfer\r\n                    d.expires = block.number + expires; //New expiration\r\n                    DomainChanged( msg.sender, domain, 0 );\r\n                }\r\n            } \r\n            else  // not set for transfer, but...\r\n            {\r\n                if( d.price > 0 &&  msg.value >= d.price ) // ... on sale, and enough money\r\n                {\r\n                    if( address( d.owner ).send( d.price ) ) // The money goes to the owner\r\n                    {\r\n                        money_used = d.price; // remember how much spent\r\n                    }\r\n                    else throw; // problem with send()\r\n\r\n                    d.owner = msg.sender;   // Change the ownership\r\n                    d.price = price;        // New price\r\n                    d.transfer = transfer;  // New transfer\r\n                    d.expires = block.number + expires; // New expiration\r\n                    DomainChanged( msg.sender, domain, 0 );\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    if( msg.value > money_used ) // If transaction has more money than was needed\r\n    {\r\n        if( !msg.sender.send( msg.value - money_used ) ) throw; // We do not need your leftover\r\n    }\r\n}\r\n\r\nfunction changeId( uint domain, uint name, uint value ) {\r\n\r\n    if( domain == 0 ) throw;        // Prevents creating 0 domain\r\n    if( name == 0 ) throw;          // Prevents creating 0 id\r\n    \r\n    Domain d = domains[ domain ];\r\n\r\n    if( d.owner == msg.sender )     // Only owner can change the ID\r\n    {\r\n        Id id = d.ids[ name ];\r\n\r\n        if( id.value == 0 ) {       // 0 means the ID was not found\r\n            if( value != 0 ) {      // Only add non zero values\r\n                id.value = value;   \r\n                id.next_id = d.root_id; // Put into the head of the list\r\n                // id.prev_id = 0;  // 0 is the default, no need to assign\r\n                \r\n                if( d.root_id != 0 ) \r\n                {\r\n                    d.ids[ d.root_id ].prev_id = name; // link the next ID back\r\n                }\r\n\r\n                d.root_id = name;   \r\n                DomainChanged( msg.sender, domain, name );\r\n            }\r\n        }\r\n        else                        // The ID was found\r\n        {\r\n            if( value != 0 )        // Simple change of the value\r\n            {\r\n                id.value = value;\r\n                DomainChanged( msg.sender, domain, name );\r\n            }\r\n            else                    // Deleting the ID\r\n            {\r\n                if( id.prev_id != 0 ) // Modify the double linked list\r\n                {\r\n                    d.ids[ id.prev_id ].next_id = id.next_id;   \r\n                }\r\n                else\r\n                {\r\n                    d.root_id = id.next_id;\r\n                }\r\n\r\n                if( id.next_id != 0 )\r\n                {\r\n                    d.ids[ id.next_id ].prev_id = id.prev_id;   \r\n                }\r\n                \r\n                id.prev_id = 0;   // Clear the storage\r\n                id.next_id = 0;   \r\n                id.value = 0;   \r\n                DomainChanged( msg.sender, domain, name );\r\n            }\r\n        }\r\n    }\r\n    \r\n    if( msg.value > 0 ) // If transaction has any money...\r\n    {\r\n        if( !msg.sender.send( msg.value ) ) throw; // ... it is a mistake, so send it back\r\n    }\r\n}\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "EtherId", 
  "transactions": "33203", 
  "address": "0xd588b586d61c826a0e87919b3d1a239206d58bf2"
 }, 
 {
  "source": "//                       , ; ,   .-'\"\"\"'-.   , ; ,\r\n//                       \\\\|/  .'          '.  \\|//\r\n//                        \\-;-/   ()   ()   \\-;-/\r\n//                        // ;               ; \\\\\r\n//                       //__; :.         .; ;__\\\\\r\n//                      `-----\\'.'-.....-'.'/-----'\r\n//                             '.'.-.-,_.'.'\r\n//                               '(  (..-'\r\n//                                 '-'\r\n//  ROULETH \r\n//\r\n//  Play the Roulette on ethereum blockchain !\r\n//  (or become a member of Rouleth's Decentralized Organisation  and contribute to the bankroll.) \r\n//\r\n//\r\n//\r\n//   check latest contract address version on the current website interface\r\n//   V 2\r\n//\r\n//\r\n//\r\n\r\ncontract Rouleth\r\n{\r\n    //Game and Global Variables, Structure of gambles\r\n    address developer;\r\n    uint8 blockDelay; //nb of blocks to wait before spin\r\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\r\n    uint256 maxGamble; //max gamble value manually set by config\r\n    uint256 minGamble; //min gamble value manually set by config\r\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\r\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\r\n    uint casinoStatisticalLimit; //ratio payroll and max win\r\n    //Current gamble value possibly lower than limit auto\r\n    uint256 currentMaxGamble; \r\n    //Gambles\r\n    enum BetTypes{number, color, parity, dozen, column, lowhigh} \r\n    struct Gamble\r\n    {\r\n\taddress player;\r\n        bool spinned; //Was the rouleth spinned ?\r\n\tbool win;\r\n\t//Possible bet types\r\n        BetTypes betType;\r\n\tuint8 input; //stores number, color, dozen or oddeven\r\n\tuint256 wager;\r\n\tuint256 blockNumber; //block of bet\r\n\tuint256 blockSpinned; //block of spin\r\n        uint8 wheelResult;\r\n    }\r\n    Gamble[] private gambles;\r\n    uint totalGambles; \r\n    //Tracking progress of players\r\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\r\n    //records current status of player\r\n    enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; \r\n\r\n\r\n    //**********************************************\r\n    //        Management & Config FUNCTIONS        //\r\n    //**********************************************\r\n\r\n    function  Rouleth() private //creation settings\r\n    { \r\n        developer = msg.sender;\r\n        blockDelay=1; //indicates which block after bet will be used for RNG\r\n\tblockExpiration=200; //delay after which gamble expires\r\n        minGamble=50 finney; //configurable min bet\r\n        maxGamble=500 finney; //configurable max bet\r\n        maxBetsPerBlock=5; // limit of bets per block, to prevent multiple bets per miners\r\n        casinoStatisticalLimit=100; //we are targeting at least 400\r\n    }\r\n    \r\n    modifier onlyDeveloper() \r\n    {\r\n\tif (msg.sender!=developer) throw;\r\n\t_\r\n    }\r\n    \r\n    function changeDeveloper_only_Dev(address new_dev)\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\tdeveloper=new_dev;\r\n    }\r\n\r\n    //Prevents accidental sending of Eth when you shouldn't\r\n    modifier noEthSent()\r\n    {\r\n        if (msg.value>0) \r\n\t{\r\n\t    throw;\r\n\t}\r\n        _\r\n    }\r\n\r\n\r\n    //Activate, Deactivate Betting\r\n    enum States{active, inactive} States private contract_state;\r\n    \r\n    function disableBetting_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        contract_state=States.inactive;\r\n    }\r\n\r\n\r\n    function enableBetting_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        contract_state=States.active;\r\n\r\n    }\r\n    \r\n    modifier onlyActive()\r\n    {\r\n        if (contract_state==States.inactive) throw;\r\n        _\r\n    }\r\n\r\n\r\n\r\n    //Change some settings within safety bounds\r\n    function changeSettings_only_Dev(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMinGamble, uint256 newMaxGamble, uint16 newMaxInvestor, uint256 newMinInvestment,uint256 newMaxInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\r\n\r\n        // changes the statistical multiplier that guarantees the long run casino survival\r\n        if (newCasinoStatLimit<100) throw;\r\n        casinoStatisticalLimit=newCasinoStatLimit;\r\n        //Max number of bets per block to prevent miner cheating\r\n        maxBetsPerBlock=newMaxBetsBlock;\r\n        //MAX BET : limited by payroll/(casinoStatisticalLimit*35)\r\n        if (newMaxGamble<newMinGamble) throw;  \r\n\telse { maxGamble=newMaxGamble; }\r\n        //Min Bet\r\n        if (newMinGamble<0) throw; \r\n\telse { minGamble=newMinGamble; }\r\n        //MAX NB of DAO members (can only increase (within bounds) or stay equal)\r\n        //this number of members can only increase after 25k spins on Rouleth\r\n        //refuse change of max number of members if less than 25k spins played\r\n        if (newMaxInvestor!=setting_maxInvestors && gambles.length<25000) throw;\r\n        if ( newMaxInvestor<setting_maxInvestors \r\n             || newMaxInvestor>investors.length) throw;\r\n        else { setting_maxInvestors=newMaxInvestor;}\r\n        //computes the results of the vote of the VIP members, fees to apply to new members\r\n        computeResultVoteExtraInvestFeesRate();\r\n        if (newMaxInvestment<newMinInvestment) throw;\r\n        //MIN INVEST : \r\n        setting_minInvestment=newMinInvestment;\r\n        //MAX INVEST : \r\n        setting_maxInvestment=newMaxInvestment;\r\n        //Invest LOCK PERIOD\r\n\t//1 year max\r\n\t//can also serve as a failsafe to shutdown withdraws for a period\r\n        if (setting_lockPeriod>360 days) throw; \r\n        setting_lockPeriod=newLockPeriod;\r\n        //Delay before spin :\r\n\tblockDelay=newBlockDelay;\r\n\tif (newBlockExpiration<blockDelay+20) throw;\r\n\tblockExpiration=newBlockExpiration;\r\n        updateMaxBet();\r\n    }\r\n\r\n\r\n    //**********************************************\r\n    //                 Nicknames FUNCTIONS                    //\r\n    //**********************************************\r\n\r\n    //User set nickname\r\n    mapping (address => string) nicknames;\r\n    function setNickname(string name) \r\n    noEthSent\r\n    {\r\n        if (bytes(name).length >= 2 && bytes(name).length <= 30)\r\n            nicknames[msg.sender] = name;\r\n    }\r\n    function getNickname(address _address) constant returns(string _name) {\r\n        _name = nicknames[_address];\r\n    }\r\n\r\n    \r\n    //**********************************************\r\n    //                 BETTING FUNCTIONS                    //\r\n    //**********************************************\r\n\r\n    //***//basic betting without Mist or contract call\r\n    //activates when the player only sends eth to the contract\r\n    //without specifying any type of bet.\r\n    function () \r\n    {\r\n\t//defaut bet : bet on red\r\n\tbetOnColor(true,false);\r\n    } \r\n\r\n    //Admin function that\r\n    //recalculates max bet\r\n    //updated after each bet and change of bankroll\r\n    function updateMaxBet() private\r\n    {\r\n\t//check that setting is still within safety bounds\r\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \r\n\t{ \r\n\t    currentMaxGamble=maxGamble;\r\n        }\r\n\telse\r\n\t{ \r\n\t    currentMaxGamble = payroll/(casinoStatisticalLimit*35);\r\n\t}\r\n    }\r\n\r\n\r\n    //***//Guarantees that gamble is under max bet and above min.\r\n    // returns bet value\r\n    function checkBetValue() private returns(uint256 playerBetValue)\r\n    {\r\n        if (msg.value < minGamble) throw;\r\n\tif (msg.value > currentMaxGamble) //if above max, send difference back\r\n\t{\r\n            playerBetValue=currentMaxGamble;\r\n\t}\r\n        else\r\n        { playerBetValue=msg.value; }\r\n        return;\r\n    }\r\n\r\n\r\n    //check number of bets in block (to prevent miner cheating)\r\n    modifier checkNbBetsCurrentBlock()\r\n    {\r\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\r\n        else nbBetsCurrentBlock=0;\r\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\r\n        _\r\n    }\r\n\r\n\r\n    //Function record bet called by all others betting functions\r\n    function placeBet(BetTypes betType_, uint8 input_) private\r\n    {\r\n\t// Before we record, we may have to spin the past bet if the croupier bot \r\n\t// is down for some reason or if the player played again too quickly.\r\n\t// This would fail though if the player tries too play to quickly (in consecutive block).\r\n\t// gambles should be spaced by at least a block\r\n\t// the croupier bot should spin within 2 blocks (~30 secs) after your bet.\r\n\t// if the bet expires it is added to casino profit, otherwise it would be a way to cheat\r\n\tif (playerStatus[msg.sender]!=Status.waitingForBet)\r\n\t{\r\n            SpinTheWheel(msg.sender);\r\n\t}\r\n        //Once this is done, we can record the new bet\r\n\tplayerStatus[msg.sender]=Status.waitingForSpin;\r\n\tgambleIndex[msg.sender]=gambles.length;\r\n        totalGambles++;\r\n        //adapts wager to casino limits\r\n        uint256 betValue = checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, betType_, input_, betValue, block.number, 0, 37)); //37 indicates not spinned yet\r\n\t//refund excess bet (at last step vs re-entry)\r\n        if (betValue<msg.value) \r\n        {\r\n \t    if (msg.sender.send(msg.value-betValue)==false) throw;\r\n        }\r\n    }\r\n\r\n\r\n    //***//bet on Number\t\r\n    function betOnNumber(uint8 numberChosen)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        //check that number chosen is valid and records bet\r\n        if (numberChosen>36) throw;\r\n        placeBet(BetTypes.number, numberChosen);\r\n    }\r\n\r\n    //***// function betOnColor\r\n    //bet type : color\r\n    //input : 0 for red\r\n    //input : 1 for black\r\n    function betOnColor(bool Red, bool Black)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Red) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (Black) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(BetTypes.color, input);\r\n    }\r\n\r\n    //***// function betOnLow_High\r\n    //bet type : lowhigh\r\n    //input : 0 for low\r\n    //input : 1 for low\r\n    function betOnLowHigh(bool Low, bool High)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Low) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (High) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(BetTypes.lowhigh, input);\r\n    }\r\n\r\n    //***// function betOnOddEven\r\n    //bet type : parity\r\n    //input : 0 for even\r\n    //input : 1 for odd\r\n    function betOnOddEven(bool Odd, bool Even)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Even) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (Odd) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(BetTypes.parity, input);\r\n    }\r\n\r\n\r\n    //***// function betOnDozen\r\n    //     //bet type : dozen\r\n    //     //input : 0 for first dozen\r\n    //     //input : 1 for second dozen\r\n    //     //input : 2 for third dozen\r\n    function betOnDozen(bool First, bool Second, bool Third)\r\n    {\r\n        betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\r\n    }\r\n\r\n\r\n    // //***// function betOnColumn\r\n    //     //bet type : column\r\n    //     //input : 0 for first column\r\n    //     //input : 1 for second column\r\n    //     //input : 2 for third column\r\n    function betOnColumn(bool First, bool Second, bool Third)\r\n    {\r\n        betOnColumnOrDozen(First, Second, Third, BetTypes.column);\r\n    }\r\n\r\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    { \r\n        uint8 count;\r\n        uint8 input;\r\n        if (First) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (Second) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (Third) \r\n        {\r\n            count+=1; \r\n            input=2;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(bet, input);\r\n    }\r\n\r\n\r\n    //**********************************************\r\n    // Spin The Wheel & Check Result FUNCTIONS//\r\n    //**********************************************\r\n\r\n    event Win(address player, uint8 result, uint value_won, bytes32 bHash, bytes32 sha3Player, uint gambleId);\r\n    event Loss(address player, uint8 result, uint value_loss, bytes32 bHash, bytes32 sha3Player, uint gambleId);\r\n\r\n    //***//function to spin callable\r\n    // no eth allowed\r\n    function spinTheWheel(address spin_for_player)\r\n    noEthSent\r\n    {\r\n        SpinTheWheel(spin_for_player);\r\n    }\r\n\r\n\r\n    function SpinTheWheel(address playerSpinned) private\r\n    {\r\n        if (playerSpinned==0)\r\n\t{\r\n\t    playerSpinned=msg.sender;         //if no index spins for the sender\r\n\t}\r\n\r\n\t//check that player has to spin\r\n        if (playerStatus[playerSpinned]!=Status.waitingForSpin) throw;\r\n        //redundent double check : check that gamble has not been spinned already\r\n        if (gambles[gambleIndex[playerSpinned]].spinned==true) throw;\r\n        //check that the player waited for the delay before spin\r\n        //and also that the bet is not expired\r\n\tuint playerblock = gambles[gambleIndex[playerSpinned]].blockNumber;\r\n        //too early to spin\r\n\tif (block.number<=playerblock+blockDelay) throw;\r\n        //too late, bet expired, player lost\r\n        else if (block.number>playerblock+blockExpiration)  solveBet(playerSpinned, 255, false, 1, 0, 0) ;\r\n\t//spin !\r\n        else\r\n\t{\r\n\t    uint8 wheelResult;\r\n            //Spin the wheel, \r\n            bytes32 blockHash= block.blockhash(playerblock+blockDelay);\r\n            //security check that the Hash is not empty\r\n            if (blockHash==0) throw;\r\n\t    // generate the hash for RNG from the blockHash and the player's address\r\n            bytes32 shaPlayer = sha3(playerSpinned, blockHash);\r\n\t    // get the final wheel result\r\n\t    wheelResult = uint8(uint256(shaPlayer)%37);\r\n            //check result against bet and pay if win\r\n\t    checkBetResult(wheelResult, playerSpinned, blockHash, shaPlayer);\r\n\t}\r\n    }\r\n    \r\n\r\n    //CHECK BETS FUNCTIONS private\r\n    function checkBetResult(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        BetTypes betType=gambles[gambleIndex[player]].betType;\r\n        //bet on Number\r\n        if (betType==BetTypes.number) checkBetNumber(result, player, blockHash, shaPlayer);\r\n        else if (betType==BetTypes.parity) checkBetParity(result, player, blockHash, shaPlayer);\r\n        else if (betType==BetTypes.color) checkBetColor(result, player, blockHash, shaPlayer);\r\n\telse if (betType==BetTypes.lowhigh) checkBetLowhigh(result, player, blockHash, shaPlayer);\r\n\telse if (betType==BetTypes.dozen) checkBetDozen(result, player, blockHash, shaPlayer);\r\n        else if (betType==BetTypes.column) checkBetColumn(result, player, blockHash, shaPlayer);\r\n        updateMaxBet();  //at the end, update the Max possible bet\r\n    }\r\n\r\n    // function solve Bet once result is determined : sends to winner, adds loss to profit\r\n    function solveBet(address player, uint8 result, bool win, uint8 multiplier, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        //Update status and record spinned\r\n        playerStatus[player]=Status.waitingForBet;\r\n        gambles[gambleIndex[player]].wheelResult=result;\r\n        gambles[gambleIndex[player]].spinned=true;\r\n        gambles[gambleIndex[player]].blockSpinned=block.number;\r\n\tuint bet_v = gambles[gambleIndex[player]].wager;\r\n\t\r\n        if (win)\r\n        {\r\n\t    gambles[gambleIndex[player]].win=true;\r\n\t    uint win_v = (multiplier-1)*bet_v;\r\n            lossSinceChange+=win_v;\r\n            Win(player, result, win_v, blockHash, shaPlayer, gambleIndex[player]);\r\n            //send win!\r\n\t    //safe send vs potential callstack overflowed spins\r\n            if (player.send(win_v+bet_v)==false) throw;\r\n        }\r\n        else\r\n        {\r\n\t    Loss(player, result, bet_v-1, blockHash, shaPlayer, gambleIndex[player]);\r\n            profitSinceChange+=bet_v-1;\r\n            //send 1 wei to confirm spin if loss\r\n            if (player.send(1)==false) throw;\r\n        }\r\n\r\n    }\r\n\r\n    // checkbeton number(input)\r\n    // bet type : number\r\n    // input : chosen number\r\n    function checkBetNumber(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n\tif (result==gambles[gambleIndex[player]].input)\r\n\t{\r\n            win=true;  \r\n        }\r\n        solveBet(player, result,win,36, blockHash, shaPlayer);\r\n    }\r\n\r\n\r\n    // checkbet on oddeven\r\n    // bet type : parity\r\n    // input : 0 for even, 1 for odd\r\n    function checkBetParity(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n\tif (result%2==gambles[gambleIndex[player]].input && result!=0)\r\n\t{\r\n            win=true;                \r\n        }\r\n        solveBet(player,result,win,2, blockHash, shaPlayer);\r\n    }\r\n    \r\n    // checkbet on lowhigh\r\n    // bet type : lowhigh\r\n    // input : 0 low, 1 high\r\n    function checkBetLowhigh(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n\tif (result!=0 && ( (result<19 && gambles[gambleIndex[player]].input==0)\r\n\t\t\t   || (result>18 && gambles[gambleIndex[player]].input==1)\r\n\t\t\t ) )\r\n\t{\r\n            win=true;\r\n        }\r\n        solveBet(player,result,win,2, blockHash, shaPlayer);\r\n    }\r\n\r\n    // checkbet on color\r\n    // bet type : color\r\n    // input : 0 red, 1 black\r\n    uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\r\n    function checkBetColor(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool red;\r\n        //check if red\r\n        for (uint8 k; k<18; k++)\r\n        { \r\n            if (red_list[k]==result) \r\n            { \r\n                red=true; \r\n                break;\r\n            }\r\n        }\r\n        bool win;\r\n        //win\r\n        if ( result!=0\r\n             && ( (gambles[gambleIndex[player]].input==0 && red)  \r\n                  || ( gambles[gambleIndex[player]].input==1 && !red)  ) )\r\n        {\r\n            win=true;\r\n        }\r\n        solveBet(player,result,win,2, blockHash, shaPlayer);\r\n    }\r\n\r\n    // checkbet on dozen\r\n    // bet type : dozen\r\n    // input : 0 first, 1 second, 2 third\r\n    function checkBetDozen(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    { \r\n        bool win;\r\n        //win on first dozen\r\n     \tif ( result!=0 &&\r\n             ( (result<13 && gambles[gambleIndex[player]].input==0)\r\n     \t       ||\r\n               (result>12 && result<25 && gambles[gambleIndex[player]].input==1)\r\n               ||\r\n               (result>24 && gambles[gambleIndex[player]].input==2) ) )\r\n     \t{\r\n            win=true;                \r\n        }\r\n        solveBet(player,result,win,3, blockHash, shaPlayer);\r\n    }\r\n\r\n    // checkbet on column\r\n    // bet type : column\r\n    // input : 0 first, 1 second, 2 third\r\n    function checkBetColumn(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n        if ( result!=0\r\n             && ( (gambles[gambleIndex[player]].input==0 && result%3==1)  \r\n                  || ( gambles[gambleIndex[player]].input==1 && result%3==2)\r\n                  || ( gambles[gambleIndex[player]].input==2 && result%3==0)  ) )\r\n        {\r\n            win=true;\r\n        }\r\n        solveBet(player,result,win,3, blockHash, shaPlayer);\r\n    }\r\n\r\n\r\n    //D.A.O. FUNCTIONS\r\n\r\n\r\n    //total casino payroll\r\n    uint256 payroll;\r\n    //Profit Loss since last investor change\r\n    uint256 profitSinceChange;\r\n    uint256 lossSinceChange;\r\n    //DAO members struct array (hard capped to 777 members (77 VIP + 700 extra members) )\r\n    struct Investor\r\n    {\r\n\taddress investor;\r\n\tuint256 time;\r\n    }\t\r\n    \r\n    Investor[777] private investors; //array of 777 elements (max Rouleth's members nb.)\r\n    uint16 setting_maxInvestors = 77; //Initially restricted to 77 VIP Members\r\n    //Balances of the DAO members\r\n    mapping (address=>uint256) balance; \r\n    //lockPeriod\r\n    //minimum membership time\r\n    uint256 setting_lockPeriod=30 days ;\r\n    uint256 setting_minInvestment=100 ether; //min amount to send when using \"invest()\"\r\n    uint256 setting_maxInvestment=200 ether; //max amount to send when using \"invest()\"\r\n    \r\n    event newInvest(address player, uint invest_v, uint net_invest_v);\r\n\r\n\r\n    //Become a DAO member.\r\n    function invest()\r\n    {\r\n        // update balances before altering the shares            \r\n        updateBalances();\r\n        uint256 netInvest;\r\n        uint excess;\r\n        // reset the open position counter to values out of bounds\r\n        // =999 if full\r\n        uint16 openPosition=999;\r\n        bool alreadyInvestor;\r\n        // loop over array to find if already member, \r\n        // and record a potential openPosition\r\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\r\n        { \r\n            // captures an index of an open position\r\n            if (investors[k].investor==0) openPosition=k; \r\n            // captures if already a member \r\n            else if (investors[k].investor==msg.sender)\r\n            {\r\n                alreadyInvestor=true;\r\n                break;\r\n            }\r\n        }\r\n        //new Member\r\n        if (!alreadyInvestor)\r\n        {\r\n            // check that more than min is sent (variable setting)\r\n            if (msg.value<setting_minInvestment) throw;\r\n            // check that less than max is sent (variable setting)\r\n            // otherwise refund\r\n            if (msg.value>setting_maxInvestment)\r\n            {\r\n                excess=msg.value-setting_maxInvestment;\r\n  \t\tnetInvest=setting_maxInvestment;\r\n            }\r\n\t    else\r\n\t    {\r\n\t\tnetInvest=msg.value;\r\n\t    }\r\n            //members can't become a VIP member after the initial period\r\n            if (setting_maxInvestors >77 && openPosition<77) throw;\r\n            //case : array not full, record new member\r\n            else if (openPosition!=999) investors[openPosition]=Investor(msg.sender, now);\r\n            //case : array full\r\n            else\r\n            {\r\n                throw;\r\n            }\r\n        }\r\n        //already a member\r\n        else\r\n        {\r\n            netInvest=msg.value;\r\n            //is already above the max balance allowed or is sending\r\n\t    // too much refuse additional invest\r\n            if (balance[msg.sender]+msg.value>setting_maxInvestment)\r\n            {\r\n                throw;\r\n            }\r\n\t    // this additionnal amount should be of at least 1/5 of \"setting_minInvestment\" (vs spam)\r\n\t    if (msg.value<setting_minInvestment/5) throw;\r\n        }\r\n\r\n        // add to balance of member and to bankroll\r\n        // 10% of initial 77 VIP members investment is allocated to\r\n        // game developement provider chosen by Rouleth DAO\r\n\t// 90% to bankroll\r\n        //share that will be allocated to game dev\r\n        uint256 developmentAllocation;\r\n        developmentAllocation=10*netInvest/100; \r\n        netInvest-=developmentAllocation;\r\n        //send game development allocation to Rouleth DAO or tech provider\r\n        if (developer.send(developmentAllocation)==false) throw;\r\n\r\n\t// Apply extra entry fee once casino has been opened to extra members\r\n\t// that fee will be shared between the VIP members and represents the increment of\r\n\t// market value of their shares in Rouleth to outsiders\r\n\t// warning if a VIP adds to its initial invest after the casino has been opened to \r\n\t// extra members he will pay have to pay this fee.\r\n        if (setting_maxInvestors>77)\r\n        {\r\n            // % of extra member's investment that rewards VIP funders\r\n            // Starts at 100%\r\n            // is set by a vote and computed when settings are changed\r\n            // to allow more investors\r\n            uint256 entryExtraCost=voted_extraInvestFeesRate*netInvest/100;\r\n            // add to VIP profit (to be shared by later call by dev.)\r\n            profitVIP += entryExtraCost;\r\n            netInvest-=entryExtraCost;\r\n        }\r\n        newInvest(msg.sender, msg.value, netInvest);//event log\r\n        balance[msg.sender]+=netInvest; //add to balance\r\n        payroll+=netInvest; //add to bankroll\r\n        updateMaxBet();\r\n        //refund potential excess\r\n        if (excess>0) \r\n        {\r\n            if (msg.sender.send(excess)==false) throw;\r\n        }\r\n    }\r\n\r\n\r\n    //Allows to transfer your DAO account to another address\r\n    //target should not be currently a DAO member of rouleth\r\n    //enter twice the address to make sure you make no mistake.\r\n    //this can't be reversed if you don't own the target account\r\n    function transferInvestorAccount(address newInvestorAccountOwner, address newInvestorAccountOwner_confirm)\r\n    noEthSent\r\n    {\r\n        if (newInvestorAccountOwner!=newInvestorAccountOwner_confirm) throw;\r\n        if (newInvestorAccountOwner==0) throw;\r\n        //retrieve investor ID\r\n        uint16 investorID=999;\r\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\r\n        {\r\n\t    //new address cant be of a current investor\r\n            if (investors[k].investor==newInvestorAccountOwner) throw;\r\n\r\n\t    //retrieve investor id\r\n            if (investors[k].investor==msg.sender)\r\n            {\r\n                investorID=k;\r\n            }\r\n        }\r\n        if (investorID==999) throw; //stop if not a member\r\n\telse\r\n\t    //accept and execute change of address\r\n\t    //votes on entryFeesRate are not transfered\r\n\t    //new address should vote again\r\n\t{\r\n\t    balance[newInvestorAccountOwner]=balance[msg.sender];\r\n\t    balance[msg.sender]=0;\r\n            investors[investorID].investor=newInvestorAccountOwner;\r\n\t}\r\n    }\r\n    \r\n    //***// Withdraw function (only after lockPeriod)\r\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\r\n    // if your withdraw brings your balance under the min required,\r\n    // your balance is fully withdrawn\r\n    event withdraw(address player, uint withdraw_v);\r\n    \r\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\r\n    noEthSent\r\n    {\r\n\t//vs spam withdraw min 1/10 of min\r\n\tif (amountToWithdrawInWei!=0 && amountToWithdrawInWei<setting_minInvestment/10) throw;\r\n        //before withdraw, update balances with the Profit and Loss sinceChange\r\n        updateBalances();\r\n\t//check that amount requested is authorized  \r\n\tif (amountToWithdrawInWei>balance[msg.sender]) throw;\r\n        //retrieve member ID\r\n        uint16 investorID=999;\r\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\r\n        {\r\n            if (investors[k].investor==msg.sender)\r\n            {\r\n                investorID=k;\r\n                break;\r\n            }\r\n        }\r\n        if (investorID==999) throw; //stop if not a member\r\n        //check if investment lock period is over\r\n        if (investors[investorID].time+setting_lockPeriod>now) throw;\r\n        //if balance left after withdraw is still above min accept partial withdraw\r\n        if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\r\n        {\r\n            balance[msg.sender]-=amountToWithdrawInWei;\r\n            payroll-=amountToWithdrawInWei;\r\n            //send amount to investor (with security if transaction fails)\r\n            if (msg.sender.send(amountToWithdrawInWei)==false) throw;\r\n\t    withdraw(msg.sender, amountToWithdrawInWei);\r\n        }\r\n        else\r\n            //if amountToWithdraw=0 : user wants full withdraw\r\n            //if balance after withdraw is < min invest, withdraw all and delete member\r\n        {\r\n            //send amount to member (with security if transaction fails)\r\n            uint256 fullAmount=balance[msg.sender];\r\n            payroll-=fullAmount;\r\n            balance[msg.sender]=0;\r\n\r\n\t    //delete member\r\n            delete investors[investorID];\r\n            if (msg.sender.send(fullAmount)==false) throw;\r\n   \t    withdraw(msg.sender, fullAmount);\r\n        }\r\n        updateMaxBet();\r\n    }\r\n\r\n    //***// updates balances with Profit Losses when there is a withdraw/deposit\r\n    // can be called by dev for accounting when there are no more changes\r\n    function manualUpdateBalances_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\tupdateBalances();\r\n    }\r\n    function updateBalances() private\r\n    {\r\n        //split Profits\r\n        uint256 profitToSplit;\r\n        uint256 lossToSplit;\r\n        if (profitSinceChange==0 && lossSinceChange==0)\r\n        { return; }\r\n        \r\n        else\r\n        {\r\n            // Case : Global profit (more win than losses)\r\n            // 20% fees for game development on global profit (if profit>loss)\r\n            if (profitSinceChange>lossSinceChange)\r\n            {\r\n                profitToSplit=profitSinceChange-lossSinceChange;\r\n                uint256 developerFees=profitToSplit*20/100;\r\n                profitToSplit-=developerFees;\r\n                if (developer.send(developerFees)==false) throw;\r\n            }\r\n            else\r\n            {\r\n                lossToSplit=lossSinceChange-profitSinceChange;\r\n            }\r\n            \r\n            //share the loss and profits between all DAO members \r\n            //(proportionnaly. to each one's balance)\r\n\r\n            uint totalShared;\r\n            for (uint16 k=0; k<setting_maxInvestors; k++)\r\n            {\r\n                address inv=investors[k].investor;\r\n                if (inv==0) continue;\r\n                else\r\n                {\r\n                    if (profitToSplit!=0) \r\n                    {\r\n                        uint profitShare=(profitToSplit*balance[inv])/payroll;\r\n                        balance[inv]+=profitShare;\r\n                        totalShared+=profitShare;\r\n                    }\r\n                    else if (lossToSplit!=0) \r\n                    {\r\n                        uint lossShare=(lossToSplit*balance[inv])/payroll;\r\n                        balance[inv]-=lossShare;\r\n                        totalShared+=lossShare;\r\n                        \r\n                    }\r\n                }\r\n            }\r\n            // update bankroll\r\n\t    // and handle potential very small left overs from integer div.\r\n            if (profitToSplit !=0) \r\n            {\r\n\t\tpayroll+=profitToSplit;\r\n\t\tbalance[developer]+=profitToSplit-totalShared;\r\n            }\r\n            else if (lossToSplit !=0) \r\n            {\r\n\t\tpayroll-=lossToSplit;\r\n\t\tbalance[developer]-=lossToSplit-totalShared;\r\n            }\r\n            profitSinceChange=0; //reset Profit;\r\n            lossSinceChange=0; //reset Loss ;\r\n        }\r\n    }\r\n    \r\n\r\n    //VIP Voting on Extra Invest Fees Rate\r\n    //mapping records 100 - vote\r\n    mapping (address=>uint) hundredminus_extraInvestFeesRate;\r\n    // max fee is 99%\r\n    // a fee of 100% indicates that the VIP has never voted.\r\n    function voteOnNewEntryFees_only_VIP(uint8 extraInvestFeesRate_0_to_99)\r\n    noEthSent\r\n    {\r\n        if (extraInvestFeesRate_0_to_99<1 || extraInvestFeesRate_0_to_99>99) throw;\r\n        hundredminus_extraInvestFeesRate[msg.sender]=100-extraInvestFeesRate_0_to_99;\r\n    }\r\n\r\n    uint256 payrollVIP;\r\n    uint256 voted_extraInvestFeesRate;\r\n    function computeResultVoteExtraInvestFeesRate() private\r\n    {\r\n        payrollVIP=0;\r\n        voted_extraInvestFeesRate=0;\r\n        //compute total payroll of the VIPs\r\n        //compute vote results among VIPs\r\n        for (uint8 k=0; k<77; k++)\r\n        {\r\n            if (investors[k].investor==0) continue;\r\n            else\r\n            {\r\n                //don't count vote if the VIP never voted\r\n                if (hundredminus_extraInvestFeesRate[investors[k].investor]==0) continue;\r\n                else\r\n                {\r\n                    payrollVIP+=balance[investors[k].investor];\r\n                    voted_extraInvestFeesRate+=hundredminus_extraInvestFeesRate[investors[k].investor]*balance[investors[k].investor];\r\n                }\r\n            }\r\n        }\r\n\t//compute final result\r\n\t    if (payrollVIP!=0)\r\n\t    {\r\n            voted_extraInvestFeesRate=100-voted_extraInvestFeesRate/payrollVIP;\r\n     \t    }\r\n    }\r\n\r\n\r\n    //Split the profits of the VIP members on extra members' contribution\r\n    uint profitVIP;\r\n    function splitProfitVIP_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        payrollVIP=0;\r\n        //compute total payroll of the VIPs\r\n        for (uint8 k=0; k<77; k++)\r\n        {\r\n            if (investors[k].investor==0) continue;\r\n            else\r\n            {\r\n                payrollVIP+=balance[investors[k].investor];\r\n            }\r\n        }\r\n        //split the profits of the VIP members on extra member's contribution\r\n\tuint totalSplit;\r\n        for (uint8 i=0; i<77; i++)\r\n        {\r\n            if (investors[i].investor==0) continue;\r\n            else\r\n            {\r\n\t\tuint toSplit=balance[investors[i].investor]*profitVIP/payrollVIP;\r\n                balance[investors[i].investor]+=toSplit;\r\n\t\ttotalSplit+=toSplit;\r\n            }\r\n        }\r\n\t//take care of Integer Div remainders, and add to bankroll\r\n\tbalance[developer]+=profitVIP-totalSplit;\r\n\tpayroll+=profitVIP;\r\n\t//reset var profitVIP\r\n        profitVIP=0;\r\n    }\r\n\r\n    \r\n    //INFORMATION FUNCTIONS\r\n    function checkProfitLossSinceInvestorChange() constant returns(uint profit_since_update_balances, uint loss_since_update_balances, uint profit_VIP_since_update_balances)\r\n    {\r\n        profit_since_update_balances=profitSinceChange;\r\n        loss_since_update_balances=lossSinceChange;\r\n        profit_VIP_since_update_balances=profitVIP;\t\r\n        return;\r\n    }\r\n\r\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\r\n    {\r\n        balanceInWei=balance[investor];\r\n        return;\r\n    }\r\n\r\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\r\n    {\r\n        investor=investors[index].investor;\r\n        endLockPeriod=investors[index].time+setting_lockPeriod;\r\n        return;\r\n    }\r\n    \r\n    function investmentEntryInfos() constant returns(uint current_max_nb_of_investors, uint investLockPeriod, uint voted_Fees_Rate_on_extra_investments)\r\n    {\r\n    \tinvestLockPeriod=setting_lockPeriod;\r\n    \tvoted_Fees_Rate_on_extra_investments=voted_extraInvestFeesRate;\r\n    \tcurrent_max_nb_of_investors=setting_maxInvestors;\r\n    \treturn;\r\n    }\r\n    \r\n    function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\r\n    {\r\n    \tmaxBet=currentMaxGamble;\r\n    \tblockDelayBeforeSpin=blockDelay;\r\n    \treturn ;\r\n    }\r\n\r\n    function getTotalGambles() constant returns(uint _totalGambles)\r\n    {\r\n        _totalGambles=totalGambles;\r\n    \treturn ;\r\n    }\r\n    \r\n    function getPayroll() constant returns(uint payroll_at_last_update_balances)\r\n    {\r\n        payroll_at_last_update_balances=payroll;\r\n    \treturn ;\r\n    }\r\n\r\n    \r\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin, uint gambleID)\r\n    {\r\n        player_status=playerStatus[player];\r\n        bettype=gambles[gambleIndex[player]].betType;\r\n        input=gambles[gambleIndex[player]].input;\r\n        value=gambles[gambleIndex[player]].wager;\r\n        result=gambles[gambleIndex[player]].wheelResult;\r\n        wheelspinned=gambles[gambleIndex[player]].spinned;\r\n        win=gambles[gambleIndex[player]].win;\r\n        blockNb=gambles[gambleIndex[player]].blockNumber;\r\n        blockSpin=gambles[gambleIndex[player]].blockSpinned;\r\n    \tgambleID=gambleIndex[player];\r\n    \treturn;\r\n    }\r\n    \r\n    function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin)\r\n    {\r\n        player=gambles[index].player;\r\n        bettype=gambles[index].betType;\r\n        input=gambles[index].input;\r\n        value=gambles[index].wager;\r\n        result=gambles[index].wheelResult;\r\n        wheelspinned=gambles[index].spinned;\r\n        win=gambles[index].win;\r\n    \tblockNb=gambles[index].blockNumber;\r\n        blockSpin=gambles[index].blockSpinned;\r\n    \treturn;\r\n    }\r\n\r\n} //end of contract", 
  "balance": "9,403<b>.</b>016499995142593469 Ether", 
  "name": "Rouleth", 
  "transactions": "25833", 
  "address": "0x18a672e11d637fffadccc99b152f4895da069601"
 }, 
 {
  "source": "contract Ambi {\r\n    function getNodeAddress(bytes32 _name) constant returns (address);\r\n    function addNode(bytes32 _name, address _addr) external returns (bool);\r\n    function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool);\r\n}\r\n\r\ncontract PotRewards {\r\n    function transfer(address _from, address _to, uint _amount);\r\n}\r\n\r\ncontract PosRewards {\r\n    function transfer(address _from, address _to);\r\n}\r\n\r\ncontract ElcoinInterface {\r\n    function rewardTo(address _to, uint _amount) returns (bool);\r\n}\r\n\r\ncontract EtherTreasuryInterface {\r\n    function withdraw(address _to, uint _value) returns(bool);\r\n}\r\n\r\ncontract MetaCoinInterface {\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approved(address indexed _owner, address indexed _spender, uint256 _value);\r\n\tevent Unapproved(address indexed _owner, address indexed _spender);\r\n\r\n\tfunction totalSupply() constant returns (uint256 supply){}\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance){}\r\n\tfunction transfer(address _to, uint256 _value) returns (bool success){}\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success){}\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success){}\r\n\tfunction unapprove(address _spender) returns (bool success){}\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining){}\r\n}\r\n\r\ncontract ElcoinDb {\r\n    function getBalance(address addr) constant returns(uint balance);\r\n    function deposit(address addr, uint amount, bytes32 hash, uint time) returns (bool res);\r\n    function withdraw(address addr, uint amount, bytes32 hash, uint time) returns (bool res);\r\n}\r\n\r\ncontract AmbiEnabled {\r\n    Ambi ambiC;\r\n    bytes32 public name;\r\n\r\n    modifier checkAccess(bytes32 _role) {\r\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\r\n            _\r\n        }\r\n    }\r\n    \r\n    function getAddress(bytes32 _name) constant returns (address) {\r\n        return ambiC.getNodeAddress(_name);\r\n    }\r\n\r\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\r\n        if(address(ambiC) != 0x0){\r\n            return false;\r\n        }\r\n        Ambi ambiContract = Ambi(_ambi);\r\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\r\n            bool isNode = ambiContract.addNode(_name, address(this));\r\n            if (!isNode){\r\n                return false;\r\n            }   \r\n        }\r\n        name = _name;\r\n        ambiC = ambiContract;\r\n        return true;\r\n    }\r\n\r\n    function remove() checkAccess(\"owner\") {\r\n        suicide(msg.sender);\r\n    }\r\n}\r\n\r\ncontract Elcoin is AmbiEnabled, MetaCoinInterface {\r\n\r\n    event Error(uint8 indexed code, address indexed origin, address indexed sender);\r\n\r\n    mapping (address => uint) public recoveredIndex;\r\n    address[] public recovered;\r\n\r\n    uint public totalSupply;\r\n    uint public absMinFee; // set up in 1/1000000 of Elcoin\r\n    uint public feePercent; // set up in 1/100 of percent, 10 is 0.1%\r\n    uint public absMaxFee; // set up in 1/1000000 of Elcoin\r\n    address public feeAddr;\r\n\r\n    function Elcoin() {\r\n        recovered.length++;\r\n        feeAddr = tx.origin;\r\n        _setFeeStructure(0, 0, 1);\r\n    }\r\n\r\n    function _db() internal constant returns (ElcoinDb) {\r\n        return ElcoinDb(getAddress(\"elcoinDb\"));\r\n    }\r\n\r\n    function _setFeeStructure(uint _absMinFee, uint _feePercent, uint _absMaxFee) internal returns (bool) {\r\n        if(_absMinFee < 0 || _feePercent < 0 || _feePercent > 10000 || _absMaxFee < 0 || _absMaxFee < _absMinFee) {\r\n            Error(1, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n        absMinFee = _absMinFee;\r\n        feePercent = _feePercent;\r\n        absMaxFee = _absMaxFee;\r\n        return true;\r\n    }\r\n\r\n    function _rawTransfer(ElcoinDb _db, address _from, address _to, uint _value) internal {\r\n        _db.withdraw(_from, _value, 0, 0);\r\n        uint fee = calculateFee(_value);\r\n        uint net = _value - fee;\r\n        _db.deposit(_to, net, 0, 0);\r\n\r\n        Transfer(_from, _to, _value);\r\n        if (fee > 0) {\r\n            _db.deposit(feeAddr, fee, 0, 0);\r\n        }\r\n    }\r\n\r\n    function _transfer(ElcoinDb _db, address _from, address _to, uint _value) internal returns (bool) {\r\n        if (_value < absMinFee) {\r\n            return false;\r\n        }\r\n        if (_from == _to) {\r\n            return false;\r\n        }\r\n        uint balance = _db.getBalance(_from);\r\n\r\n        if (balance < _value) {\r\n            return false;\r\n        }\r\n        _rawTransfer(_db, _from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transferWithReward(ElcoinDb _db, address _from, address _to, uint _value) internal returns (bool) {\r\n        if (!_transfer(_db, _from, _to, _value)) {\r\n            Error(2, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        address pos = getAddress(\"elcoinPoS\");\r\n        address pot = getAddress(\"elcoinPoT\");\r\n        if (pos != 0x0) {\r\n            PosRewards(pos).transfer(_from, _to);\r\n        }\r\n        if (pot != 0x0) {\r\n            PotRewards(pot).transfer(_from, _to, _value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _recoverAccount(ElcoinDb _db, address _old, address _new) internal returns (bool) {\r\n        uint pos =  recovered.length++;\r\n        recovered[pos] = _old;\r\n        recoveredIndex[_old] = pos;\r\n        uint balance = _db.getBalance(_old);\r\n        var rv = _db.withdraw(_old, balance, 0, 0);\r\n        if (!rv) {\r\n            Error(5, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n        _db.deposit(_new, balance, 0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    modifier notRecoveredAccount(address _account) {\r\n        if(recoveredIndex[_account] == 0x0) {\r\n            _\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _account) constant returns (uint) {\r\n        return _db().getBalance(_account);\r\n    }\r\n\r\n    function calculateFee(uint _amount) constant returns (uint) {\r\n        uint fee = (_amount * feePercent) / 10000;\r\n\r\n        if (fee < absMinFee) {\r\n            return absMinFee;\r\n        }\r\n\r\n        if (fee > absMaxFee) {\r\n            return absMaxFee;\r\n        }\r\n\r\n        return fee;\r\n    }\r\n\r\n    function issueCoin(address _to, uint _value, uint _totalSupply) checkAccess(\"currencyOwner\") returns (bool) {\r\n        if (totalSupply > 0) {\r\n            Error(6, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        bool dep = _db().deposit(_to, _value, 0, 0);\r\n        totalSupply = _totalSupply;\r\n        return dep;\r\n    }\r\n\r\n    function batchTransfer(address[] _to, uint[] _value) checkAccess(\"currencyOwner\") returns (bool) {\r\n        if (_to.length != _value.length) {\r\n            Error(7, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        uint totalToSend = 0;\r\n        for (uint8 i = 0; i < _value.length; i++) {\r\n            totalToSend += _value[i];\r\n        }\r\n\r\n        ElcoinDb db = _db();\r\n        if (db.getBalance(msg.sender) < totalToSend) {\r\n            Error(8, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        db.withdraw(msg.sender, totalToSend, 0, 0);\r\n        for (uint8 j = 0; j < _to.length; j++) {\r\n            db.deposit(_to[j], _value[j], 0, 0);\r\n            Transfer(msg.sender, _to[j], _value[j]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        uint startGas = msg.gas + transferCallGas;\r\n        if (!_transferWithReward(_db(), msg.sender, _to, _value)) {\r\n            return false;\r\n        }\r\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\r\n        return _refund(refund);\r\n    }\r\n\r\n    function transferPool(address _from, address _to, uint _value) checkAccess(\"pool\") returns (bool) {\r\n        return _transferWithReward(_db(), _from, _to, _value);\r\n    }\r\n\r\n    function rewardTo(address _to, uint _amount) checkAccess(\"reward\") returns (bool) {\r\n        bool result = _db().deposit(_to, _amount, 0, 0);\r\n        if (result) {\r\n            totalSupply += _amount;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function recoverAccount(address _old, address _new) checkAccess(\"recovery\") notRecoveredAccount(_old) returns (bool) {\r\n        return _recoverAccount(_db(), _old, _new);\r\n    }\r\n\r\n    function setFeeAddr(address _feeAddr) checkAccess(\"currencyOwner\") {\r\n        feeAddr = _feeAddr;\r\n    }\r\n\r\n    function setFee(uint _absMinFee, uint _feePercent, uint _absMaxFee) checkAccess(\"cron\") returns (bool) {\r\n        return _setFeeStructure(_absMinFee, _feePercent, _absMaxFee);\r\n    }\r\n\r\n    uint public txGasPriceLimit = 21000000000;\r\n    uint public transferCallGas = 21000;\r\n    uint public refundGas = 15000;\r\n    EtherTreasuryInterface treasury;\r\n\r\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(\"currencyOwner\") returns (bool) {\r\n        if (_txGasPriceLimit == 0) {\r\n            return false;\r\n        }\r\n        treasury = EtherTreasuryInterface(_treasury);\r\n        txGasPriceLimit = _txGasPriceLimit;\r\n        if (msg.value > 0 && !address(treasury).send(msg.value)) {\r\n            throw;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function updateRefundGas() checkAccess(\"currencyOwner\") returns (uint) {\r\n        uint startGas = msg.gas;\r\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice; // just to simulate calculations, dunno if optimizer will remove this.\r\n        if (!_refund(1)) {\r\n            return 0;\r\n        }\r\n        refundGas = startGas - msg.gas;\r\n        return refundGas;\r\n    }\r\n\r\n    function setOperationsCallGas(uint _transfer) checkAccess(\"currencyOwner\") returns (bool) {\r\n        transferCallGas = _transfer;\r\n        return true;\r\n    }\r\n\r\n    function _refund(uint _value) internal returns (bool) {\r\n        if (tx.gasprice > txGasPriceLimit) {\r\n            return false;\r\n        }\r\n        return treasury.withdraw(tx.origin, _value);\r\n    }\r\n}", 
  "balance": "0<b>.</b>00000000000001929 Ether", 
  "name": "Elcoin", 
  "transactions": "21926", 
  "address": "0x57d90b64a1a57749b0f932f1a3395792e12e7055"
 }, 
 {
  "source": "contract Ambi {\r\n    function getNodeAddress(bytes32) constant returns (address);\r\n    function addNode(bytes32, address) external returns (bool);\r\n    function hasRelation(bytes32, bytes32, address) constant returns (bool);\r\n}\r\n\r\ncontract AmbiEnabled {\r\n    Ambi ambiC;\r\n    bytes32 public name;\r\n\r\n    modifier checkAccess(bytes32 _role) {\r\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\r\n            _\r\n        }\r\n    }\r\n    \r\n    function getAddress(bytes32 _name) returns (address) {\r\n        return ambiC.getNodeAddress(_name);\r\n    }\r\n\r\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\r\n        if(address(ambiC) != 0x0){\r\n            return false;\r\n        }\r\n        Ambi ambiContract = Ambi(_ambi);\r\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\r\n            bool isNode = ambiContract.addNode(_name, address(this));\r\n            if (!isNode){\r\n                return false;\r\n            }   \r\n        }\r\n        name = _name;\r\n        ambiC = ambiContract;\r\n        return true;\r\n    }\r\n\r\n    function remove(){\r\n        if(msg.sender == address(ambiC)){\r\n            suicide(msg.sender);\r\n        }\r\n    }\r\n}\r\n\r\ncontract ElcoinDb {\r\n    function getBalance(address addr) constant returns(uint balance);\r\n}\r\n\r\ncontract ElcoinInterface {\r\n    function rewardTo(address _to, uint _amount) returns (bool);\r\n}\r\n\r\ncontract PosRewards is AmbiEnabled {\r\n\r\n    event Reward(address indexed beneficiary, uint indexed cycle, uint value, uint position);\r\n\r\n    uint public cycleLength; // PoS will be ready to send each cycleLength seconds\r\n    uint public startTime;   // starting at startTime\r\n    uint public cycleLimit;  // and will stop after cycleLimit cycles pass\r\n    uint public minimalRewardedBalance; // but only those accounts having balance\r\n                             // >= minimalRewardedBalance will get reward\r\n    uint[] public bannedCycles;\r\n\r\n    enum RewardStatuses { Unsent, Sent, TooSmallToSend }\r\n\r\n    struct Account {\r\n        address recipient;\r\n        RewardStatuses status;\r\n    }\r\n\r\n    // cycleNumber => (address => minimalBalance)\r\n    mapping (uint => mapping (address => int)) public accountsBalances;\r\n    // cycleNumber => Account[]\r\n    mapping (uint => Account[]) public accountsUsed;\r\n\r\n    function PosRewards() {\r\n        cycleLength = 864000; // 864000 seconds = 10 days, 14400 = 4 hours\r\n        cycleLimit = 255; // that's 9 + 9 + 9 + 9 + 219, see getRate() for info\r\n        minimalRewardedBalance = 1000000; // 1 coin\r\n        startTime = now;\r\n    }\r\n\r\n    // USE THIS FUNCTION ONLY IN NEW CONTRACT, IT WILL CORRUPT ALREADY COLLECTED DATA!\r\n    // startTime should be set to the time when PoS starts (on Dec 17, probably block 705000 or so).\r\n    // It should be at 12:00 Moscow time, this would be the start of all PoS cycles.\r\n    function setStartTime(uint _startTime) checkAccess(\"owner\") {\r\n        startTime = _startTime;\r\n    }\r\n\r\n    // this allows to end PoS before 2550 days pass or to extend it further\r\n    function setCycleLimit(uint _cycleLimit) checkAccess(\"owner\") {\r\n        cycleLimit = _cycleLimit;\r\n    }\r\n\r\n    // this allows to disable PoS sending for some of the cycles in case we\r\n    // need to send custom PoS. This will be 100% used on first deploy.\r\n    function setBannedCycles(uint[] _cycles) checkAccess(\"owner\") {\r\n        bannedCycles = _cycles;\r\n    }\r\n\r\n    // set to 0 to reward everyone\r\n    function setMinimalRewardedBalance(uint _balance) checkAccess(\"owner\") {\r\n        minimalRewardedBalance = _balance;\r\n    }\r\n\r\n    function kill() checkAccess(\"owner\") {\r\n        suicide(msg.sender); // kills this contract and sends remaining funds back to msg.sender\r\n    }\r\n\r\n    // First 90 days 50% yearly\r\n    // Next 90 days 40%\r\n    // Next 90 days 30%\r\n    // Next 90 days 20%\r\n    // Next 2190 days 10%\r\n    function getRate(uint cycle) constant returns (uint) {\r\n        if (cycle <= 9) {\r\n            return 50;\r\n        }\r\n        if (cycle <= 18) {\r\n            return 40;\r\n        }\r\n        if (cycle <= 27) {\r\n            return 30;\r\n        }\r\n        if (cycle <= 35) { // not 36 because 36 is elDay\r\n            return 20;\r\n        }\r\n        if (cycle == 36) {\r\n            return 40;\r\n        }\r\n        if (cycle <= cycleLimit) {\r\n            if (cycle % 36 == 0) {\r\n                // Every 360th day, reward amounts double.\r\n                // The elDay lasts precisely 24 hours, and after that, reward amounts revert to their original values.\r\n                return 20;\r\n            }\r\n\r\n            return 10;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // Cycle numeration starts from 1, 0 will be handled as not valid cycle\r\n    function currentCycle() constant returns (uint) {\r\n        if (startTime > now) {\r\n            return 0;\r\n        }\r\n\r\n        return 1 + ((now - startTime) / cycleLength);\r\n    }\r\n\r\n    function _isCycleValid(uint _cycle) constant internal returns (bool) {\r\n        if (_cycle >= currentCycle() || _cycle == 0) {\r\n            return false;\r\n        }\r\n        for (uint i; i<bannedCycles.length; i++) {\r\n            if (bannedCycles[i] == _cycle) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Returns how much Elcoin would be granted for user's minimal balance X in cycle Y\r\n    // The function is optimized to work with whole integer arithmetics\r\n    function getInterest(uint amount, uint cycle) constant returns (uint) {\r\n        return (amount * getRate(cycle)) / 3650;\r\n    }\r\n\r\n    // This function logs the balances after the transfer to be used in further calculations\r\n    function transfer(address _from, address _to) checkAccess(\"elcoin\") {\r\n        if (startTime == 0) {\r\n            return; // the easy way to disable PoS\r\n        }\r\n\r\n        _storeBalanceRecord(_from);\r\n        _storeBalanceRecord(_to);\r\n    }\r\n\r\n    function _storeBalanceRecord(address _addr) internal {\r\n        ElcoinDb db = ElcoinDb(getAddress(\"elcoinDb\"));\r\n        uint cycle = currentCycle();\r\n\r\n        if (cycle > cycleLimit) {\r\n            return;\r\n        }\r\n\r\n        int balance = int(db.getBalance(_addr));\r\n        bool accountNotUsedInCycle = (accountsBalances[cycle][_addr] == 0);\r\n\r\n        // We'll use -1 to mark accounts that have zero balance because\r\n        // mappings return 0 for unexisting records and there is no way to\r\n        // differ them without additional data structure\r\n        if (accountsBalances[cycle][_addr] != -1 && (accountNotUsedInCycle || accountsBalances[cycle][_addr] > balance)) {\r\n            if (balance == 0) {\r\n                balance = -1;\r\n            }\r\n            accountsBalances[cycle][_addr] = balance;\r\n\r\n            if (accountNotUsedInCycle) {\r\n                // do this only once for each account in each cycle\r\n                accountsUsed[cycle].push(Account(_addr, RewardStatuses.Unsent));\r\n            }\r\n        }\r\n    }\r\n\r\n    // Get minimal balance for address in some cycle\r\n    function getMinimalBalance(uint _cycle, address _addr) constant returns(int) {\r\n        int balance = accountsBalances[_cycle][_addr];\r\n        if (balance == -1) {\r\n            balance = 0;\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n    // Get information from accountsUsed structure\r\n    function getAccountInfo(uint _cycle, uint _position) constant returns(address, RewardStatuses, int) {\r\n        return (\r\n            accountsUsed[_cycle][_position].recipient,\r\n            accountsUsed[_cycle][_position].status,\r\n            accountsBalances[_cycle][accountsUsed[_cycle][_position].recipient]\r\n          );\r\n    }\r\n\r\n    // Get information from accountsUsed structure\r\n    function getRewardsCount(uint _cycle) constant returns(uint) {\r\n        return accountsUsed[_cycle].length;\r\n    }\r\n\r\n    function sendReward(uint _cycle, uint _position) returns(bool) {\r\n        // Check that parameters are in valid ranges\r\n        if (!_isCycleValid(_cycle) || _position >= accountsUsed[_cycle].length) {\r\n            return false;\r\n        }\r\n\r\n        // Check that this reward was not sent\r\n        Account claimant = accountsUsed[_cycle][_position];\r\n        if (claimant.status != RewardStatuses.Unsent) {\r\n            return false;\r\n        }\r\n\r\n        // Check that this reward passes the conditions\r\n        int minimalAccountBalance = accountsBalances[_cycle][claimant.recipient];\r\n        if (minimalAccountBalance < int(minimalRewardedBalance)) {\r\n            claimant.status = RewardStatuses.TooSmallToSend;\r\n            return false;\r\n        }\r\n\r\n        uint rewardAmount = getInterest(uint(minimalAccountBalance), _cycle);\r\n\r\n        // We are ready to send the reward\r\n        ElcoinInterface elcoin = ElcoinInterface(getAddress(\"elcoin\"));\r\n        bool result = elcoin.rewardTo(claimant.recipient, rewardAmount);\r\n        if (result) {\r\n            Reward(claimant.recipient, _cycle, rewardAmount, _position);\r\n            claimant.status = RewardStatuses.Sent;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "PosRewards", 
  "transactions": "20692", 
  "address": "0xa00fa22499478cc37beb45021a1f1c9f826f72e1"
 }, 
 {
  "source": "contract RequiringFunds {\r\n    modifier NeedEth () {\r\n        if (msg.value <= 0 ) throw;\r\n        _\r\n    }\r\n}\r\n\r\ncontract AmIOnTheFork {\r\n    function forked() constant returns(bool);\r\n}\r\n\r\ncontract ReplaySafeSplit is RequiringFunds {\r\n    //address private constant oracleAddress = 0x8128B12cABc6043d94BD3C4d9B9455077Eb18807;    // testnet\r\n    address private constant oracleAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;   // mainnet\r\n    \r\n    // Fork oracle to use\r\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(oracleAddress);\r\n\r\n    // Splits the funds into 2 addresses\r\n    function split(address targetFork, address targetNoFork) NeedEth returns(bool) {\r\n        // The 2 checks are to ensure that users provide BOTH addresses\r\n        // and prevent funds to be sent to 0x0 on one fork or the other.\r\n        if (targetFork == 0) throw;\r\n        if (targetNoFork == 0) throw;\r\n\r\n        if (amIOnTheFork.forked()                   // if we are on the fork \r\n            && targetFork.send(msg.value)) {        // send the ETH to the targetFork address\r\n            return true;\r\n        } else if (!amIOnTheFork.forked()           // if we are NOT on the fork \r\n            && targetNoFork.send(msg.value)) {      // send the ETH to the targetNoFork address \r\n            return true;\r\n        }\r\n\r\n        throw;                                      // don't accept value transfer, otherwise it would be trapped.\r\n    }\r\n\r\n    // Reject value transfers.\r\n    function() {\r\n        throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ReplaySafeSplit", 
  "transactions": "13364", 
  "address": "0xabbb6bebfa05aa13e908eaa492bd7a8343760477"
 }, 
 {
  "source": "contract WavesPresale {\r\n    address public owner;\r\n    \r\n    struct Sale\r\n    {\r\n        uint amount;\r\n        uint date;\r\n    }\r\n\r\n    mapping (bytes16 => Sale[]) public sales;\r\n    uint32 public numberOfSales;\r\n    uint public totalTokens;\r\n\r\n    function WavesPresale() {\r\n        owner = msg.sender;\r\n        numberOfSales = 0;\r\n    }\r\n\r\n    function changeOwner(address newOwner) {\r\n        if (msg.sender != owner) return;\r\n\r\n        owner = newOwner;\r\n    }\r\n\r\n    function newSale(bytes16 txidHash, uint amount, uint timestamp) {\r\n        if (msg.sender != owner) return;\r\n\r\n        sales[txidHash].push(Sale({\r\n                    amount: amount,\r\n                    date: timestamp\r\n                }));\r\n        numberOfSales += 1;\r\n        totalTokens += amount;\r\n    }\r\n\r\n    function getNumOfSalesWithSameId(bytes16 txidHash) constant returns (uint) {\r\n        return sales[txidHash].length;\r\n    }\r\n\r\n    function getSaleDate(bytes16 txidHash, uint num) constant returns (uint, uint) {\r\n    \treturn (sales[txidHash][num].amount, sales[txidHash][num].date);\r\n    }\r\n\r\n    function () {\r\n        // This function gets executed if a\r\n        // transaction with invalid data is sent to\r\n        // the contract or just ether without data.\r\n        // We revert the send so that no-one\r\n        // accidentally loses money when using the\r\n        // contract.\r\n        throw;\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "WavesPresale", 
  "transactions": "13018", 
  "address": "0xae506bb28ed79b29c6968ab527d1efdc5f399331"
 }, 
 {
  "source": "contract AmIOnTheFork {\r\n    bool public forked = false;\r\n    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\r\n    // Check the fork condition during creation of the contract.\r\n    // This function should be called between block 1920000 and 1921200.\r\n    // Approximately between 2016-07-20 12:00:00 UTC and 2016-07-20 17:00:00 UTC.\r\n    // After that the status will be locked in.\r\n    function update() {\r\n        if (block.number >= 1920000 && block.number <= 1921200) {\r\n            forked = darkDAO.balance < 3600000 ether;\r\n        }\r\n    }\r\n    function() {\r\n        throw;\r\n    }\r\n}\r\ncontract ReplaySafeSplit {\r\n    // Fork oracle to use\r\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\r\n\r\n    // Splits the funds into 2 addresses\r\n    function split(address targetFork, address targetNoFork) returns(bool) {\r\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\r\n            return true;\r\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\r\n            return true;\r\n        }\r\n        throw;\r\n    }\r\n\r\n    // Reject value transfers.\r\n    function() {\r\n        throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ReplaySafeSplit", 
  "transactions": "12944", 
  "address": "0x9554efa1669014c25070bc23c2df262825704228"
 }, 
 {
  "source": "/// @title DigixDAO Contract Interfaces\r\n\r\ncontract ConfigInterface {\r\n        address public owner;\r\n        mapping(address => bool) admins;\r\n        mapping(bytes32 => address) addressMap;\r\n        mapping(bytes32 => bool) boolMap;\r\n        mapping(bytes32 => bytes32) bytesMap;\r\n        mapping(bytes32 => uint256) uintMap;\r\n\r\n        /// @notice setConfigAddress sets configuration `_key` to `_val`\r\n        /// @param _key The key name of the configuration.\r\n        /// @param _val The value of the configuration.\r\n        /// @return Whether the configuration setting was successful or not.\r\n        function setConfigAddress(bytes32 _key, address _val) returns(bool success);\r\n\r\n        /// @notice setConfigBool sets configuration `_key` to `_val`\r\n        /// @param _key The key name of the configuration.\r\n        /// @param _val The value of the configuration.\r\n        /// @return Whether the configuration setting was successful or not.\r\n        function setConfigBool(bytes32 _key, bool _val) returns(bool success);\r\n\r\n        /// @notice setConfigBytes sets configuration `_key` to `_val`\r\n        /// @param _key The key name of the configuration.\r\n        /// @param _val The value of the configuration.\r\n        /// @return Whether the configuration setting was successful or not.\r\n        function setConfigBytes(bytes32 _key, bytes32 _val) returns(bool success);\r\n\r\n        /// @notice setConfigUint `_key` to `_val`\r\n        /// @param _key The key name of the configuration.\r\n        /// @param _val The value of the configuration.\r\n        /// @return Whether the configuration setting was successful or not.\r\n        function setConfigUint(bytes32 _key, uint256 _val) returns(bool success);\r\n\r\n        /// @notice getConfigAddress gets configuration `_key`'s value\r\n        /// @param _key The key name of the configuration.\r\n        /// @return The configuration value\r\n        function getConfigAddress(bytes32 _key) returns(address val);\r\n\r\n        /// @notice getConfigBool gets configuration `_key`'s value\r\n        /// @param _key The key name of the configuration.\r\n        /// @return The configuration value\r\n        function getConfigBool(bytes32 _key) returns(bool val);\r\n\r\n        /// @notice getConfigBytes gets configuration `_key`'s value\r\n        /// @param _key The key name of the configuration.\r\n        /// @return The configuration value\r\n        function getConfigBytes(bytes32 _key) returns(bytes32 val);\r\n\r\n        /// @notice getConfigUint gets configuration `_key`'s value\r\n        /// @param _key The key name of the configuration.\r\n        /// @return The configuration value\r\n        function getConfigUint(bytes32 _key) returns(uint256 val);\r\n\r\n        /// @notice addAdmin sets `_admin` as configuration admin\r\n        /// @return Whether the configuration setting was successful or not.\r\n        function addAdmin(address _admin) returns(bool success);\r\n\r\n        /// @notice removeAdmin removes  `_admin`'s rights\r\n        /// @param _admin The key name of the configuration.\r\n        /// @return Whether the configuration setting was successful or not.\r\n        function removeAdmin(address _admin) returns(bool success);\r\n\r\n}\r\n\r\ncontract TokenInterface {\r\n\r\n        mapping(address => uint256) balances;\r\n        mapping(address => mapping(address => uint256)) allowed;\r\n        mapping(address => bool) seller;\r\n\r\n        address config;\r\n        address owner;\r\n        address dao;\r\n        address public badgeLedger;\r\n        bool locked;\r\n\r\n        /// @return total amount of tokens\r\n        uint256 public totalSupply;\r\n\r\n        /// @param _owner The address from which the balance will be retrieved\r\n        /// @return The balance\r\n        function balanceOf(address _owner) constant returns(uint256 balance);\r\n\r\n        /// @notice send `_value` tokens to `_to` from `msg.sender`\r\n        /// @param _to The address of the recipient\r\n        /// @param _value The amount of tokens to be transfered\r\n        /// @return Whether the transfer was successful or not\r\n        function transfer(address _to, uint256 _value) returns(bool success);\r\n\r\n        /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\r\n        /// @param _from The address of the sender\r\n        /// @param _to The address of the recipient\r\n        /// @param _value The amount of tokens to be transfered\r\n        /// @return Whether the transfer was successful or not\r\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success);\r\n\r\n        /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\r\n        /// @param _spender The address of the account able to transfer the tokens\r\n        /// @param _value The amount of tokens to be approved for transfer\r\n        /// @return Whether the approval was successful or not\r\n        function approve(address _spender, uint256 _value) returns(bool success);\r\n\r\n        /// @param _owner The address of the account owning tokens\r\n        /// @param _spender The address of the account able to transfer the tokens\r\n        /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\r\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining);\r\n\r\n        /// @notice mint `_amount` of tokens to `_owner`\r\n        /// @param _owner The address of the account receiving the tokens\r\n        /// @param _amount The amount of tokens to mint\r\n        /// @return Whether or not minting was successful\r\n        function mint(address _owner, uint256 _amount) returns(bool success);\r\n\r\n        /// @notice mintBadge Mint `_amount` badges to `_owner`\r\n        /// @param _owner The address of the account receiving the tokens\r\n        /// @param _amount The amount of tokens to mint\r\n        /// @return Whether or not minting was successful\r\n        function mintBadge(address _owner, uint256 _amount) returns(bool success);\r\n\r\n        function registerDao(address _dao) returns(bool success);\r\n\r\n        function registerSeller(address _tokensales) returns(bool success);\r\n\r\n        event Transfer(address indexed _from, address indexed _to, uint256 indexed _value);\r\n        event Mint(address indexed _recipient, uint256 indexed _amount);\r\n        event Approval(address indexed _owner, address indexed _spender, uint256 indexed _value);\r\n}\r\n\r\ncontract TokenSalesInterface {\r\n\r\n        struct SaleProxy {\r\n                address payout;\r\n                bool isProxy;\r\n        }\r\n\r\n        struct SaleStatus {\r\n                bool founderClaim;\r\n                uint256 releasedTokens;\r\n                uint256 releasedBadges;\r\n                uint256 claimers;\r\n        }\r\n\r\n        struct Info {\r\n                uint256 totalWei;\r\n                uint256 totalCents;\r\n                uint256 realCents;\r\n                uint256 amount;\r\n        }\r\n\r\n        struct SaleConfig {\r\n                uint256 startDate;\r\n                uint256 periodTwo;\r\n                uint256 periodThree;\r\n                uint256 endDate;\r\n                uint256 goal;\r\n                uint256 cap;\r\n                uint256 badgeCost;\r\n                uint256 founderAmount;\r\n                address founderWallet;\r\n        }\r\n\r\n        struct Buyer {\r\n                uint256 centsTotal;\r\n                uint256 weiTotal;\r\n                bool claimed;\r\n        }\r\n\r\n        Info saleInfo;\r\n        SaleConfig saleConfig;\r\n        SaleStatus saleStatus;\r\n\r\n        address config;\r\n        address owner;\r\n        bool locked;\r\n\r\n        uint256 public ethToCents;\r\n\r\n        mapping(address => Buyer) buyers;\r\n        mapping(address => SaleProxy) proxies;\r\n\r\n        /// @notice Calculates the parts per billion 1\u20441,000,000,000 of `_a` to `_b`\r\n        /// @param _a The antecedent\r\n        /// @param _c The consequent\r\n        /// @return Part per billion value\r\n        function ppb(uint256 _a, uint256 _c) public constant returns(uint256 b);\r\n\r\n\r\n        /// @notice Calculates the share from `_total` based on `_contrib`\r\n        /// @param _contrib The contributed amount in USD\r\n        /// @param _total The total amount raised in USD\r\n        /// @return Total number of shares\r\n        function calcShare(uint256 _contrib, uint256 _total) public constant returns(uint256 share);\r\n\r\n        /// @notice Calculates the current USD cents value of `_wei`\r\n        /// @param _wei the amount of wei\r\n        /// @return The USD cents value\r\n        function weiToCents(uint256 _wei) public constant returns(uint256 centsvalue);\r\n\r\n        function proxyPurchase(address _user) returns(bool success);\r\n\r\n        /// @notice Send msg.value purchase for _user.\r\n        /// @param _user The account to be credited\r\n        /// @return Success if purchase was accepted\r\n        function purchase(address _user, uint256 _amount) private returns(bool success);\r\n\r\n        /// @notice Get crowdsale information for `_user`\r\n        /// @param _user The account to be queried\r\n        /// @return `centstotal` the total amount of USD cents contributed\r\n        /// @return `weitotal` the total amount in wei contributed\r\n        /// @return `share` the current token shares earned\r\n        /// @return `badges` the number of proposer badges earned\r\n        /// @return `claimed` is true if the tokens and badges have been claimed\r\n        function userInfo(address _user) public constant returns(uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed);\r\n\r\n        /// @notice Get the crowdsale information from msg.sender (see userInfo)\r\n        function myInfo() public constant returns(uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed);\r\n\r\n        /// @notice get the total amount of wei raised for the crowdsale\r\n        /// @return The amount of wei raised\r\n        function totalWei() public constant returns(uint);\r\n\r\n        /// @notice get the total USD value in cents raised for the crowdsale\r\n        /// @return the amount USD cents\r\n        function totalCents() public constant returns(uint);\r\n\r\n        /// @notice get the current crowdsale information\r\n        /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\r\n        /// @return `two` The unix timestamp for the start of the second period modifier\r\n        /// @return `three` The unix timestamp for the start of the third period modifier\r\n        /// @return `endsale` The unix timestamp of the end of crowdsale\r\n        /// @return `totalwei` The total amount of wei raised\r\n        /// @return `totalcents` The total number of USD cents raised\r\n        /// @return `amount` The amount of DGD tokens available for the crowdsale\r\n        /// @return `goal` The USD value goal for the crowdsale\r\n        /// @return `famount` Founders endowment\r\n        /// @return `faddress` Founder wallet address\r\n        /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\r\n\r\n        function claimFor(address _user) returns(bool success);\r\n\r\n        /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\r\n        function claim() returns(bool success);\r\n\r\n        function claimFounders() returns(bool success);\r\n\r\n        /// @notice See if the crowdsale goal has been reached\r\n        function goalReached() public constant returns(bool reached);\r\n\r\n        /// @notice Get the current sale period\r\n        /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\r\n        function getPeriod() public constant returns(uint saleperiod);\r\n\r\n        /// @notice Get the date for the start of the crowdsale\r\n        /// @return `date` The unix timestamp for the start\r\n        function startDate() public constant returns(uint date);\r\n\r\n        /// @notice Get the date for the second reward period of the crowdsale\r\n        /// @return `date` The unix timestamp for the second period\r\n        function periodTwo() public constant returns(uint date);\r\n\r\n        /// @notice Get the date for the final period of the crowdsale\r\n        /// @return `date` The unix timestamp for the final period\r\n        function periodThree() public constant returns(uint date);\r\n\r\n        /// @notice Get the date for the end of the crowdsale\r\n        /// @return `date` The unix timestamp for the end of the crowdsale\r\n        function endDate() public constant returns(uint date);\r\n\r\n        /// @notice Check if crowdsale has ended\r\n        /// @return `ended` If the crowdsale has ended\r\n\r\n        function isEnded() public constant returns(bool ended);\r\n\r\n        /// @notice Send raised funds from the crowdsale to the DAO\r\n        /// @return `success` if the send succeeded\r\n        function sendFunds() public returns(bool success);\r\n\r\n        //function regProxy(address _payment, address _payout) returns (bool success);\r\n        function regProxy(address _payout) returns(bool success);\r\n\r\n        function getProxy(address _payout) public returns(address proxy);\r\n\r\n        function getPayout(address _proxy) public returns(address payout, bool isproxy);\r\n\r\n        function unlock() public returns(bool success);\r\n\r\n        function getSaleStatus() public constant returns(bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\r\n\r\n        function getSaleInfo() public constant returns(uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\r\n\r\n        function getSaleConfig() public constant returns(uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\r\n\r\n        event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\r\n        event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\r\n\r\n}\r\n\r\ncontract Badge {\r\n        mapping(address => uint256) balances;\r\n        mapping(address => mapping(address => uint256)) allowed;\r\n\r\n        address public owner;\r\n        bool public locked;\r\n\r\n        /// @return total amount of tokens\r\n        uint256 public totalSupply;\r\n\r\n        modifier ifOwner() {\r\n                if (msg.sender != owner) {\r\n                        throw;\r\n                } else {\r\n                        _\r\n                }\r\n        }\r\n\r\n\r\n        event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n        event Mint(address indexed _recipient, uint256 indexed _amount);\r\n        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n        function Badge() {\r\n                owner = msg.sender;\r\n        }\r\n\r\n        function safeToAdd(uint a, uint b) returns(bool) {\r\n                return (a + b >= a);\r\n        }\r\n\r\n        function addSafely(uint a, uint b) returns(uint result) {\r\n                if (!safeToAdd(a, b)) {\r\n                        throw;\r\n                } else {\r\n                        result = a + b;\r\n                        return result;\r\n                }\r\n        }\r\n\r\n        function safeToSubtract(uint a, uint b) returns(bool) {\r\n                return (b <= a);\r\n        }\r\n\r\n        function subtractSafely(uint a, uint b) returns(uint) {\r\n                if (!safeToSubtract(a, b)) throw;\r\n                return a - b;\r\n        }\r\n\r\n        function balanceOf(address _owner) constant returns(uint256 balance) {\r\n                return balances[_owner];\r\n        }\r\n\r\n        function transfer(address _to, uint256 _value) returns(bool success) {\r\n                if (balances[msg.sender] >= _value && _value > 0) {\r\n                        balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\r\n                        balances[_to] = addSafely(_value, balances[_to]);\r\n                        Transfer(msg.sender, _to, _value);\r\n                        success = true;\r\n                } else {\r\n                        success = false;\r\n                }\r\n                return success;\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\r\n                if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n                        balances[_to] = addSafely(balances[_to], _value);\r\n                        balances[_from] = subtractSafely(balances[_from], _value);\r\n                        allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\r\n                        Transfer(_from, _to, _value);\r\n                        return true;\r\n                } else {\r\n                        return false;\r\n                }\r\n        }\r\n\r\n        function approve(address _spender, uint256 _value) returns(bool success) {\r\n                allowed[msg.sender][_spender] = _value;\r\n                Approval(msg.sender, _spender, _value);\r\n                success = true;\r\n                return success;\r\n        }\r\n\r\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\r\n                remaining = allowed[_owner][_spender];\r\n                return remaining;\r\n        }\r\n\r\n        function mint(address _owner, uint256 _amount) ifOwner returns(bool success) {\r\n                totalSupply = addSafely(totalSupply, _amount);\r\n                balances[_owner] = addSafely(balances[_owner], _amount);\r\n                Mint(_owner, _amount);\r\n                return true;\r\n        }\r\n\r\n        function setOwner(address _owner) ifOwner returns(bool success) {\r\n                owner = _owner;\r\n                return true;\r\n        }\r\n\r\n}\r\n\r\ncontract Token {\r\n\r\n        address public owner;\r\n        address public config;\r\n        bool public locked;\r\n        address public dao;\r\n        address public badgeLedger;\r\n        uint256 public totalSupply;\r\n\r\n        mapping(address => uint256) balances;\r\n        mapping(address => mapping(address => uint256)) allowed;\r\n        mapping(address => bool) seller;\r\n\r\n        /// @return total amount of tokens\r\n\r\n        modifier ifSales() {\r\n                if (!seller[msg.sender]) throw;\r\n                _\r\n        }\r\n\r\n        modifier ifOwner() {\r\n                if (msg.sender != owner) throw;\r\n                _\r\n        }\r\n\r\n        modifier ifDao() {\r\n                if (msg.sender != dao) throw;\r\n                _\r\n        }\r\n\r\n        event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n        event Mint(address indexed _recipient, uint256 _amount);\r\n        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n        function Token(address _config) {\r\n                config = _config;\r\n                owner = msg.sender;\r\n                address _initseller = ConfigInterface(_config).getConfigAddress(\"sale1:address\");\r\n                seller[_initseller] = true;\r\n                badgeLedger = new Badge();\r\n                locked = false;\r\n        }\r\n\r\n        function safeToAdd(uint a, uint b) returns(bool) {\r\n                return (a + b >= a);\r\n        }\r\n\r\n        function addSafely(uint a, uint b) returns(uint result) {\r\n                if (!safeToAdd(a, b)) {\r\n                        throw;\r\n                } else {\r\n                        result = a + b;\r\n                        return result;\r\n                }\r\n        }\r\n\r\n        function safeToSubtract(uint a, uint b) returns(bool) {\r\n                return (b <= a);\r\n        }\r\n\r\n        function subtractSafely(uint a, uint b) returns(uint) {\r\n                if (!safeToSubtract(a, b)) throw;\r\n                return a - b;\r\n        }\r\n\r\n        function balanceOf(address _owner) constant returns(uint256 balance) {\r\n                return balances[_owner];\r\n        }\r\n\r\n        function transfer(address _to, uint256 _value) returns(bool success) {\r\n                if (balances[msg.sender] >= _value && _value > 0) {\r\n                        balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\r\n                        balances[_to] = addSafely(balances[_to], _value);\r\n                        Transfer(msg.sender, _to, _value);\r\n                        success = true;\r\n                } else {\r\n                        success = false;\r\n                }\r\n                return success;\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\r\n                if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n                        balances[_to] = addSafely(balances[_to], _value);\r\n                        balances[_from] = subtractSafely(balances[_from], _value);\r\n                        allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\r\n                        Transfer(_from, _to, _value);\r\n                        return true;\r\n                } else {\r\n                        return false;\r\n                }\r\n        }\r\n\r\n        function approve(address _spender, uint256 _value) returns(bool success) {\r\n                allowed[msg.sender][_spender] = _value;\r\n                Approval(msg.sender, _spender, _value);\r\n                success = true;\r\n                return success;\r\n        }\r\n\r\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\r\n                remaining = allowed[_owner][_spender];\r\n                return remaining;\r\n        }\r\n\r\n        function mint(address _owner, uint256 _amount) ifSales returns(bool success) {\r\n                totalSupply = addSafely(_amount, totalSupply);\r\n                balances[_owner] = addSafely(balances[_owner], _amount);\r\n                return true;\r\n        }\r\n\r\n        function mintBadge(address _owner, uint256 _amount) ifSales returns(bool success) {\r\n                if (!Badge(badgeLedger).mint(_owner, _amount)) return false;\r\n                return true;\r\n        }\r\n\r\n        function registerDao(address _dao) ifOwner returns(bool success) {\r\n                if (locked == true) return false;\r\n                dao = _dao;\r\n                locked = true;\r\n                return true;\r\n        }\r\n\r\n        function setDao(address _newdao) ifDao returns(bool success) {\r\n                dao = _newdao;\r\n                return true;\r\n        }\r\n\r\n        function isSeller(address _query) returns(bool isseller) {\r\n                return seller[_query];\r\n        }\r\n\r\n        function registerSeller(address _tokensales) ifDao returns(bool success) {\r\n                seller[_tokensales] = true;\r\n                return true;\r\n        }\r\n\r\n        function unregisterSeller(address _tokensales) ifDao returns(bool success) {\r\n                seller[_tokensales] = false;\r\n                return true;\r\n        }\r\n\r\n        function setOwner(address _newowner) ifDao returns(bool success) {\r\n                if (Badge(badgeLedger).setOwner(_newowner)) {\r\n                        owner = _newowner;\r\n                        success = true;\r\n                } else {\r\n                        success = false;\r\n                }\r\n                return success;\r\n        }\r\n\r\n}", 
  "balance": "3<b>.</b>112250000000000002 Ether", 
  "name": "Token", 
  "transactions": "11516", 
  "address": "0xe0b7927c4af23765cb51314a0e0521a9645f0e2a"
 }, 
 {
  "source": "contract AmIOnTheFork {\r\n    function forked() constant returns(bool);\r\n}\r\n\r\ncontract ReplaySafeSplit {\r\n    // Fork oracle to use\r\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\r\n\r\n    // Splits the funds into 2 addresses\r\n    function split(address targetFork, address targetNoFork) returns(bool) {\r\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\r\n            return true;\r\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\r\n            return true;\r\n        }\r\n        throw; // don't accept value transfer, otherwise it would be trapped.\r\n    }\r\n\r\n    // Reject value transfers.\r\n    function() {\r\n        throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ReplaySafeSplit", 
  "transactions": "10340", 
  "address": "0xebf2bf80c3ddb0b6ac2f88be8dceec7bf12dff22"
 }, 
 {
  "source": "contract ClassicCheck {\r\n       function isClassic() constant returns (bool isClassic);\r\n}\r\n\r\ncontract SafeConditionalHFTransfer {\r\n\r\n    bool classic;\r\n    \r\n    function SafeConditionalHFTransfer() {\r\n        classic = ClassicCheck(0x882fb4240f9a11e197923d0507de9a983ed69239).isClassic();\r\n    }\r\n    \r\n    function classicTransfer(address to) {\r\n        if (!classic) \r\n            msg.sender.send(msg.value);\r\n        else\r\n            to.send(msg.value);\r\n    }\r\n    \r\n    function transfer(address to) {\r\n        if (classic)\r\n            msg.sender.send(msg.value);\r\n        else\r\n            to.send(msg.value);\r\n    }\r\n    \r\n}", 
  "balance": "0<b>.</b>973785799153 Ether", 
  "name": "SafeConditionalHFTransfer", 
  "transactions": "8926", 
  "address": "0x1e143b2588705dfea63a17f2032ca123df995ce0"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\n\r\ncontract IconomiToken {\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n  event BlockLockSet(uint256 _value);\r\n  event NewOwner(address _newOwner);\r\n\r\n  modifier onlyOwner {\r\n    if (msg.sender == owner) {\r\n      _;\r\n    }\r\n  }\r\n\r\n  modifier blockLock(address _sender) {\r\n    if (!isLocked() || _sender == owner) {\r\n      _;\r\n    }\r\n  }\r\n\r\n  modifier checkIfToContract(address _to) {\r\n    if(_to != address(this))  {\r\n      _;\r\n    }\r\n  }\r\n\r\n  uint256 public totalSupply;\r\n  string public name;\r\n  uint8 public decimals;\r\n  string public symbol;\r\n  string public version = '0.0.1';\r\n  address public owner;\r\n  uint256 public lockedUntilBlock;\r\n\r\n  function IconomiToken(\r\n    uint256 _initialAmount,\r\n    string _tokenName,\r\n    uint8 _decimalUnits,\r\n    string _tokenSymbol,\r\n    uint256 _lockedUntilBlock\r\n    ) {\r\n\r\n    balances[msg.sender] = _initialAmount;\r\n    totalSupply = _initialAmount;\r\n    name = _tokenName;\r\n    decimals = _decimalUnits;\r\n    symbol = _tokenSymbol;\r\n    lockedUntilBlock = _lockedUntilBlock;\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n    tokenRecipient spender = tokenRecipient(_spender);\r\n    if (approve(_spender, _value)) {\r\n      spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) blockLock(msg.sender) checkIfToContract(_to) returns (bool success) {\r\n    if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) blockLock(_from) checkIfToContract(_to) returns (bool success) {\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  function setBlockLock(uint256 _lockedUntilBlock) onlyOwner returns (bool success) {\r\n    lockedUntilBlock = _lockedUntilBlock;\r\n    BlockLockSet(_lockedUntilBlock);\r\n    return true;\r\n  }\r\n\r\n  function isLocked() constant returns (bool success) {\r\n    return lockedUntilBlock > block.number;\r\n  }\r\n\r\n  function replaceOwner(address _newOwner) onlyOwner returns (bool success) {\r\n    owner = _newOwner;\r\n    NewOwner(_newOwner);\r\n    return true;\r\n  }\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n}", 
  "balance": "0 Ether", 
  "name": "IconomiToken", 
  "transactions": "7079", 
  "address": "0x888666ca69e0f178ded6d75b5726cee99a87d698"
 }, 
 {
  "source": "/* Copyright (C) Etherplay <contact@etherplay.io> - All Rights Reserved */\r\npragma solidity 0.4.4;\r\n\r\ncontract CompetitionStore {\r\n\t\r\n/////////////////////////////////////////////////////////////////// DATA /////////////////////////////////////////////////////////////\r\n\t\r\n\t//player's submission store the info required to verify its accuracy\r\n\tstruct Submission{\r\n\t\tuint32 score; \r\n\t\tuint32 durationRoundedDown; // duration in second of the game session\r\n\t\tuint32 version; // version of the game used\r\n\t\tuint64 seed; //seed used\r\n\t\tuint64 submitBlockNumber; // blockNumber at which the submission is processed\r\n\t\tbytes32 proofHash;//sha256 of proof : to save gas, the proof is not saved directly in the contract. Instead its hash is saved. The actual proof will be saved on a server. The player could potentially save it too. \r\n\t}\r\n\t\r\n\t//player start game parameter\r\n\tstruct Start{\r\n\t\tuint8 competitionIndex; //competition index (0 or 1) there is only 2 current competition per game, one is active, the other one being the older one which might have pending verification\r\n\t\tuint32 version;  //version of the game that the player score is based on\r\n\t\tuint64 seed; // the seed used for the game session\r\n\t\tuint64 time; // start time , used to check if the player is not taking too long to submit its score\r\n\t}\r\n\t\r\n\t// the values representing each competition\r\n\tstruct Competition{\r\n\t\tuint8 numPastBlocks;// number of past block allowed, 1 is the minimum since you can only get the hash of a past block. Allow player to start play instantunously\r\n\t\tuint8 houseDivider; // how much the house takes : 4 means house take 1/4 (25%)\r\n\t\tuint16 lag; // define how much extra time is allowed to submit a score (to accomodate block time and delays)\r\n\t\tuint32 verificationWaitTime;// wait time allowed for submission past competition's end time \r\n\t\tuint32 numPlayers;//current number of player that submited a score\r\n\t\tuint32 version; //the version of the game used for that competition, a hash of the code is published in the log upon changing\r\n\t\tuint32 previousVersion; // previousVersion to allow smooth update upon version change\r\n\t\tuint64 versionChangeBlockNumber; \r\n\t\tuint64 switchBlockNumber; // the blockNumber at which the competition started\r\n\t\tuint64 endTime;//The time at which the competition is set to finish. No start can happen after that and the competition cannot be aborted before that\r\n\t\tuint88 price;  // the price for that competition, do not change \r\n\t\tuint128 jackpot; // the current jackpot for that competition, this jackpot is then shared among the developer (in the deposit account for  funding development) and the winners (see houseDivider))\r\n\t\tuint32[] rewardsDistribution; // the length of it define how many winners there is and the distribution of the reward is the value for each index divided by the total\r\n\t\tmapping (address => Submission) submissions;  //only one submission per player per competition\r\n\t\taddress[] players; // contain the list of players that submited a score for that competition\r\n\t}\r\n\t\t\r\n\tstruct Game{\r\n\t\tmapping (address => Start) starts; // only 1 start per player, further override the current\r\n\t\tCompetition[2] competitions; // 2 competitions only to save gas, overrite each other upon going to next competition\r\n\t\tuint8 currentCompetitionIndex; //can only be 1 or 0 (switch operation : 1 - currentCompetitionIndex)\r\n\t}\r\n\r\n\tmapping (string => Game) games;\r\n\t\r\n\taddress organiser; // admin having control of the reward \r\n\taddress depositAccount;\t // is the receiver of the house part of the jackpot (see houseDivider) Can only be changed by the depositAccount.\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////// EVENTS /////////////////////////////////////////////////////////////\r\n\r\n\t//event logging the hash of the game code for a particular version\r\n\tevent VersionChange(\r\n\t\tstring indexed gameID,\r\n\t\tuint32 indexed version,\r\n\t\tbytes32 codeHash // the sha256 of the game code as used by the player\r\n\t);\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n//////////////////////////////////////////////////////// PLAYERS ACTIONS /////////////////////////////////////////////////////////////\r\n\t\r\n\t/*\r\n\tThe seed is computed from the block hash and the sender address\r\n\tWhile the seed can be predicted for few block away (see : numPastBlocks) this is has no much relevance since a game session have a bigger duration,\r\n\tRemember this is not gambling game, this is a skill game, seed is only a small part of the game outcome\r\n\t*/\r\n\tfunction computeSeed(uint64 blockNumber, address player) internal constant returns(uint64 seed){ \r\n\t\treturn uint64(sha3(block.blockhash(blockNumber),block.blockhash(blockNumber-1),block.blockhash(blockNumber-2),block.blockhash(blockNumber-3),block.blockhash(blockNumber-4),block.blockhash(blockNumber-5),player)); \r\n\t}\r\n\t\r\n\t/*\r\n\t\tprobe the current state of the competition so player can start playing right away (need to commit a tx too to ensure its play will be considered though)\r\n\t*/\r\n\tfunction getSeedAndState(string gameID, address player) constant returns(uint64 seed, uint64 blockNumber, uint8 competitionIndex, uint32 version, uint64 endTime, uint88 price, uint32 myBestScore, uint64 competitionBlockNumber, uint64 registeredSeed){\r\n\t\tvar game = games[gameID];\r\n\r\n\t\tcompetitionIndex = game.currentCompetitionIndex;\r\n\t\tvar competition = game.competitions[competitionIndex];\r\n\r\n\t\tblockNumber = uint64(block.number-1);\r\n\t\tseed = computeSeed(blockNumber, player);\r\n\t\tversion = competition.version;\r\n\t\tendTime = competition.endTime;\r\n\t\tprice = competition.price;\r\n\t\tcompetitionBlockNumber = competition.switchBlockNumber;\r\n\t\t\r\n\t\tif (competition.submissions[player].submitBlockNumber >= competition.switchBlockNumber){\r\n\t\t\tmyBestScore = competition.submissions[player].score;\r\n\t\t}else{\r\n\t\t\tmyBestScore = 0;\r\n\t\t}\r\n\t\t\r\n\t\tregisteredSeed = game.starts[player].seed;\r\n\t}\r\n\t\r\n\t\r\n\t\t\r\n\tfunction start(string gameID, uint64 blockNumber,uint8 competitionIndex, uint32 version) payable {\r\n\t\tvar game = games[gameID];\r\n\t\tvar competition = game.competitions[competitionIndex];\r\n\r\n\t\tif(msg.value != competition.price){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\tif(\r\n\t\t\tcompetition.endTime <= now || //block play when time is up \r\n\t\t\tcompetitionIndex != game.currentCompetitionIndex || //start happen just after a switch // should not be possible since endTime already ensure that a new competition cannot start before the end of the first\r\n\t\t\tversion != competition.version && (version != competition.previousVersion || block.number > competition.versionChangeBlockNumber) || //ensure version is same as current (or previous if versionChangeBlockNumber is recent)\r\n\t\t\tblock.number >= competition.numPastBlocks && block.number - competition.numPastBlocks > blockNumber //ensure start is not too old   \r\n\t\t\t){\r\n\t\t\t\t//if ether was sent, send it back if possible, else throw\r\n\t\t\t\tif(msg.value != 0 && !msg.sender.send(msg.value)){\r\n\t\t\t\t\tthrow;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tcompetition.jackpot += uint128(msg.value); //increase the jackpot\r\n\t\t\r\n\t\t//save the start params\r\n\t\tgame.starts[msg.sender] = Start({\r\n\t\t\tseed: computeSeed(blockNumber,msg.sender)\r\n\t\t\t, time : uint64(now)\r\n\t\t\t, competitionIndex : competitionIndex\r\n\t\t\t, version : version\r\n\t\t}); \r\n\t}\r\n\t\t\r\n\tfunction submit(string gameID, uint64 seed, uint32 score, uint32 durationRoundedDown, bytes32 proofHash){ \r\n\t\tvar game = games[gameID];\r\n\r\n\t\tvar gameStart = game.starts[msg.sender];\r\n\t\t\t\r\n\t\t//seed should be same, else it means double start and this one executing is from the old one \r\n\t\tif(gameStart.seed != seed){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tvar competition = game.competitions[gameStart.competitionIndex];\r\n\t\t\r\n\t\t// game should not take too long to be submited\r\n\t\tif(now - gameStart.time > durationRoundedDown + competition.lag){ \r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(now >= competition.endTime + competition.verificationWaitTime){\r\n\t\t\treturn; //this ensure verifier to get all the score at that time (should never be there though as game should ensure a maximumTime < verificationWaitTime)\r\n\t\t}\r\n\t\t\r\n\t\tvar submission = competition.submissions[msg.sender];\r\n\t\tif(submission.submitBlockNumber < competition.switchBlockNumber){\r\n\t\t\tif(competition.numPlayers >= 4294967295){ //unlikely but if that happen this is for now the best place to stop\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}else if (score <= submission.score){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tvar players = competition.players;\r\n\t\t//if player did not submit score yet => add player to list\r\n\t\tif(submission.submitBlockNumber < competition.switchBlockNumber){\r\n\t\t\tvar currentNumPlayer = competition.numPlayers;\r\n\t\t\tif(currentNumPlayer >= players.length){\r\n\t\t\t\tplayers.push(msg.sender);\r\n\t\t\t}else{\r\n\t\t\t\tplayers[currentNumPlayer] = msg.sender;\r\n\t\t\t}\r\n\t\t\tcompetition.numPlayers = currentNumPlayer + 1;\r\n\t\t}\r\n\t\t\r\n\t\tcompetition.submissions[msg.sender] = Submission({\r\n\t\t\tproofHash:proofHash,\r\n\t\t\tseed:gameStart.seed,\r\n\t\t\tscore:score,\r\n\t\t\tdurationRoundedDown:durationRoundedDown,\r\n\t\t\tsubmitBlockNumber:uint64(block.number),\r\n\t\t\tversion:gameStart.version\r\n\t\t});\r\n\t\t\r\n\t}\r\n\t\r\n\t/*\r\n\t\taccept donation payment : this increase the jackpot of the currentCompetition of the specified game\r\n\t*/\r\n\tfunction increaseJackpot(string gameID) payable{\r\n\t\tvar game = games[gameID];\r\n\t\tgame.competitions[game.currentCompetitionIndex].jackpot += uint128(msg.value); //extra ether is lost but this is not going to happen :)\r\n\t}\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t\r\n/////////////////////////////////////// PRIVATE ///////////////////////////////////////////\r\n\t\t\r\n\tfunction CompetitionStore(){\r\n\t\torganiser = msg.sender;\r\n\t\tdepositAccount = msg.sender;\r\n\t}\r\n\r\n\t\r\n\t//give a starting jackpot by sending ether to the transaction\r\n\tfunction _startNextCompetition(string gameID, uint32 version, uint88 price, uint8 numPastBlocks, uint8 houseDivider, uint16 lag, uint64 duration, uint32 verificationWaitTime, bytes32 codeHash, uint32[] rewardsDistribution) payable{\r\n\t\tif(msg.sender != organiser){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\tvar game = games[gameID];\r\n\t\tvar newCompetition = game.competitions[1 - game.currentCompetitionIndex]; \r\n\t\tvar currentCompetition = game.competitions[game.currentCompetitionIndex];\r\n\t\t//do not allow to switch if endTime is not over\r\n\t\tif(currentCompetition.endTime >= now){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\t//block switch if reward was not called (numPlayers > 0)\r\n\t\tif(newCompetition.numPlayers > 0){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tif(houseDivider == 0){ \r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tif(numPastBlocks < 1){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tif(rewardsDistribution.length == 0 || rewardsDistribution.length > 64){ // do not risk gas shortage on reward\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t//ensure rewardsDistribution give always something and do not give more to a lower scoring player\r\n\t\tuint32 prev = 0;\r\n\t\tfor(uint8 i = 0; i < rewardsDistribution.length; i++){\r\n\t\t\tif(rewardsDistribution[i] == 0 ||  (prev != 0 && rewardsDistribution[i] > prev)){\r\n\t\t\t\tthrow;\r\n\t\t\t}\r\n\t\t\tprev = rewardsDistribution[i];\r\n\t\t}\r\n\r\n\t\tif(version != currentCompetition.version){\r\n\t\t\tVersionChange(gameID,version,codeHash); \r\n\t\t}\r\n\t\t\r\n\t\tgame.currentCompetitionIndex = 1 - game.currentCompetitionIndex;\r\n\t\t\r\n\t\tnewCompetition.switchBlockNumber = uint64(block.number);\r\n\t\tnewCompetition.previousVersion = 0;\r\n\t\tnewCompetition.versionChangeBlockNumber = 0;\r\n\t\tnewCompetition.version = version;\r\n\t\tnewCompetition.price = price; \r\n\t\tnewCompetition.numPastBlocks = numPastBlocks;\r\n\t\tnewCompetition.rewardsDistribution = rewardsDistribution;\r\n\t\tnewCompetition.houseDivider = houseDivider;\r\n\t\tnewCompetition.lag = lag;\r\n\t\tnewCompetition.jackpot += uint128(msg.value); //extra ether is lost but this is not going to happen :)\r\n\t\tnewCompetition.endTime = uint64(now) + duration;\r\n\t\tnewCompetition.verificationWaitTime = verificationWaitTime;\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\tfunction _setBugFixVersion(string gameID, uint32 version, bytes32 codeHash, uint32 numBlockAllowedForPastVersion){\r\n\t\tif(msg.sender != organiser){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\tvar game = games[gameID];\r\n\t\tvar competition = game.competitions[game.currentCompetitionIndex];\r\n\t\t\r\n\t\tif(version <= competition.version){ // a bug fix should be a new version (greater than previous version)\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tif(competition.endTime <= now){ // cannot bugFix a competition that already ended\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tcompetition.previousVersion = competition.version;\r\n\t\tcompetition.versionChangeBlockNumber = uint64(block.number + numBlockAllowedForPastVersion);\r\n\t\tcompetition.version = version;\r\n\t\tVersionChange(gameID,version,codeHash);\r\n\t}\r\n\r\n\tfunction _setLagParams(string gameID, uint16 lag, uint8 numPastBlocks){\r\n\t\tif(msg.sender != organiser){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tif(numPastBlocks < 1){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\tvar game = games[gameID];\r\n\t\tvar competition = game.competitions[game.currentCompetitionIndex];\r\n\t\tcompetition.numPastBlocks = numPastBlocks;\r\n\t\tcompetition.lag = lag;\r\n\t}\r\n\r\n\tfunction _rewardWinners(string gameID, uint8 competitionIndex, address[] winners){\r\n\t\tif(msg.sender != organiser){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t\r\n\t\tvar competition = games[gameID].competitions[competitionIndex];\r\n\r\n\t\t//ensure time has passed so that players who started near the end can finish their session \r\n\t\t//game should be made to ensure termination before verificationWaitTime, it is the game responsability\r\n\t\tif(int(now) - competition.endTime < competition.verificationWaitTime){\r\n\t\t\tthrow;\r\n\t\t}\r\n\r\n\t\t\r\n\t\tif( competition.jackpot > 0){ // if there is no jackpot skip\r\n\r\n\t\t\t\r\n\t\t\tvar rewardsDistribution = competition.rewardsDistribution;\r\n\r\n\t\t\tuint8 numWinners = uint8(rewardsDistribution.length);\r\n\r\n\t\t\tif(numWinners > uint8(winners.length)){\r\n\t\t\t\tnumWinners = uint8(winners.length);\r\n\t\t\t}\r\n\r\n\t\t\tuint128 forHouse = competition.jackpot;\r\n\t\t\tif(numWinners > 0 && competition.houseDivider > 1){ //in case there is no winners (no players or only cheaters), the house takes all\r\n\t\t\t\tforHouse = forHouse / competition.houseDivider;\r\n\t\t\t\tuint128 forWinners = competition.jackpot - forHouse;\r\n\r\n\t\t\t\tuint64 total = 0;\r\n\t\t\t\tfor(uint8 i=0; i<numWinners; i++){ // distribute all the winning even if there is not all the winners\r\n\t\t\t\t\ttotal += rewardsDistribution[i];\r\n\t\t\t\t}\r\n\t\t\t\tfor(uint8 j=0; j<numWinners; j++){\r\n\t\t\t\t\tuint128 value = (forWinners * rewardsDistribution[j]) / total;\r\n\t\t\t\t\tif(!winners[j].send(value)){ // if fail give to house\r\n\t\t\t\t\t\tforHouse = forHouse + value;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(!depositAccount.send(forHouse)){\r\n\t\t\t\t//in case sending to house failed \r\n\t\t\t\tvar nextCompetition = games[gameID].competitions[1 - competitionIndex];\r\n\t\t\t\tnextCompetition.jackpot = nextCompetition.jackpot + forHouse;\t\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\tcompetition.jackpot = 0;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tcompetition.numPlayers = 0;\r\n\t}\r\n\r\n\t\r\n\t/*\r\n\t\tallow to change the depositAccount of the house share, only the depositAccount can change it, depositAccount == organizer at creation\r\n\t*/\r\n\tfunction _setDepositAccount(address newDepositAccount){\r\n\t\tif(depositAccount != msg.sender){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\tdepositAccount = newDepositAccount;\r\n\t}\r\n\t\r\n\t/*\r\n\t\tallow to change the organiser, in case this need be \r\n\t*/\r\n\tfunction _setOrganiser(address newOrganiser){\r\n\t\tif(organiser != msg.sender){\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\torganiser = newOrganiser;\r\n\t}\r\n\t\r\n\t\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/////////////////////////////////////////////// OTHER CONSTANT CALLS TO PROBE VALUES ////////////////////////////////////////////////////\r\n\r\n\tfunction getPlayerSubmissionFromCompetition(string gameID, uint8 competitionIndex, address playerAddress) constant returns(uint32 score, uint64 seed, uint32 duration, bytes32 proofHash, uint32 version, uint64 submitBlockNumber){\r\n\t\tvar submission = games[gameID].competitions[competitionIndex].submissions[playerAddress];\r\n\t\tscore = submission.score;\r\n\t\tseed = submission.seed;\t\t\r\n\t\tduration = submission.durationRoundedDown;\r\n\t\tproofHash = submission.proofHash;\r\n\t\tversion = submission.version;\r\n\t\tsubmitBlockNumber =submission.submitBlockNumber;\r\n\t}\r\n\t\r\n\tfunction getPlayersFromCompetition(string gameID, uint8 competitionIndex) constant returns(address[] playerAddresses, uint32 num){\r\n\t\tvar competition = games[gameID].competitions[competitionIndex];\r\n\t\tplayerAddresses = competition.players;\r\n\t\tnum = competition.numPlayers;\r\n\t}\r\n\r\n\tfunction getCompetitionValues(string gameID, uint8 competitionIndex) constant returns (\r\n\t\tuint128 jackpot,\r\n\t\tuint88 price,\r\n\t\tuint32 version,\r\n\t\tuint8 numPastBlocks,\r\n\t\tuint64 switchBlockNumber,\r\n\t\tuint32 numPlayers,\r\n\t\tuint32[] rewardsDistribution,\r\n\t\tuint8 houseDivider,\r\n\t\tuint16 lag,\r\n\t\tuint64 endTime,\r\n\t\tuint32 verificationWaitTime,\r\n\t\tuint8 _competitionIndex\r\n\t){\r\n\t\tvar competition = games[gameID].competitions[competitionIndex];\r\n\t\tjackpot = competition.jackpot;\r\n\t\tprice = competition.price;\r\n\t\tversion = competition.version;\r\n\t\tnumPastBlocks = competition.numPastBlocks;\r\n\t\tswitchBlockNumber = competition.switchBlockNumber;\r\n\t\tnumPlayers = competition.numPlayers;\r\n\t\trewardsDistribution = competition.rewardsDistribution;\r\n\t\thouseDivider = competition.houseDivider;\r\n\t\tlag = competition.lag;\r\n\t\tendTime = competition.endTime;\r\n\t\tverificationWaitTime = competition.verificationWaitTime;\r\n\t\t_competitionIndex = competitionIndex;\r\n\t}\r\n\t\r\n\tfunction getCurrentCompetitionValues(string gameID) constant returns (\r\n\t\tuint128 jackpot,\r\n\t\tuint88 price,\r\n\t\tuint32 version,\r\n\t\tuint8 numPastBlocks,\r\n\t\tuint64 switchBlockNumber,\r\n\t\tuint32 numPlayers,\r\n\t\tuint32[] rewardsDistribution,\r\n\t\tuint8 houseDivider,\r\n\t\tuint16 lag,\r\n\t\tuint64 endTime,\r\n\t\tuint32 verificationWaitTime,\r\n\t\tuint8 _competitionIndex\r\n\t)\r\n\t{\r\n\t\treturn getCompetitionValues(gameID,games[gameID].currentCompetitionIndex);\r\n\t}\r\n}", 
  "balance": "1<b>.</b>906666666666666867 Ether", 
  "name": "CompetitionStore", 
  "transactions": "6832", 
  "address": "0x5f742383b6d1298980030d6af943b76cdd902143"
 }, 
 {
  "source": "pragma solidity ^0.4.2;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n  /// @return total amount of tokens\r\n  function totalSupply() constant returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint public decimals;\r\n  string public name;\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n  function transfer(address _to, uint256 _value) returns (bool success) {\r\n    //Default assumes totalSupply can't be over max (2^256 - 1).\r\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n    //Replace the if with this one instead.\r\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  uint256 public totalSupply;\r\n}\r\n\r\ncontract ReserveToken is StandardToken, SafeMath {\r\n  address public minter;\r\n  function ReserveToken() {\r\n    minter = msg.sender;\r\n  }\r\n  function create(address account, uint amount) {\r\n    if (msg.sender != minter) throw;\r\n    balances[account] = safeAdd(balances[account], amount);\r\n    totalSupply = safeAdd(totalSupply, amount);\r\n  }\r\n  function destroy(address account, uint amount) {\r\n    if (msg.sender != minter) throw;\r\n    if (balances[account] < amount) throw;\r\n    balances[account] = safeSub(balances[account], amount);\r\n    totalSupply = safeSub(totalSupply, amount);\r\n  }\r\n}\r\n\r\ncontract AccountLevels {\r\n  //given a user, returns an account level\r\n  //0 = regular user (pays take fee and make fee)\r\n  //1 = market maker silver (pays take fee, no make fee, gets rebate)\r\n  //2 = market maker gold (pays take fee, no make fee, gets entire counterparty's take fee as rebate)\r\n  function accountLevel(address user) constant returns(uint) {}\r\n}\r\n\r\ncontract AccountLevelsTest is AccountLevels {\r\n  mapping (address => uint) public accountLevels;\r\n\r\n  function setAccountLevel(address user, uint level) {\r\n    accountLevels[user] = level;\r\n  }\r\n\r\n  function accountLevel(address user) constant returns(uint) {\r\n    return accountLevels[user];\r\n  }\r\n}\r\n\r\ncontract EtherDelta is SafeMath {\r\n  address public admin; //the admin address\r\n  address public feeAccount; //the account that will receive fees\r\n  address public accountLevelsAddr; //the address of the AccountLevels contract\r\n  uint public feeMake; //percentage times (1 ether)\r\n  uint public feeTake; //percentage times (1 ether)\r\n  uint public feeRebate; //percentage times (1 ether)\r\n  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n\r\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\r\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n  function EtherDelta(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) {\r\n    admin = admin_;\r\n    feeAccount = feeAccount_;\r\n    accountLevelsAddr = accountLevelsAddr_;\r\n    feeMake = feeMake_;\r\n    feeTake = feeTake_;\r\n    feeRebate = feeRebate_;\r\n  }\r\n\r\n  function() {\r\n    throw;\r\n  }\r\n\r\n  function changeAdmin(address admin_) {\r\n    if (msg.sender != admin) throw;\r\n    admin = admin_;\r\n  }\r\n\r\n  function changeAccountLevelsAddr(address accountLevelsAddr_) {\r\n    if (msg.sender != admin) throw;\r\n    accountLevelsAddr = accountLevelsAddr_;\r\n  }\r\n\r\n  function changeFeeAccount(address feeAccount_) {\r\n    if (msg.sender != admin) throw;\r\n    feeAccount = feeAccount_;\r\n  }\r\n\r\n  function changeFeeMake(uint feeMake_) {\r\n    if (msg.sender != admin) throw;\r\n    if (feeMake_ > feeMake) throw;\r\n    feeMake = feeMake_;\r\n  }\r\n\r\n  function changeFeeTake(uint feeTake_) {\r\n    if (msg.sender != admin) throw;\r\n    if (feeTake_ > feeTake || feeTake_ < feeRebate) throw;\r\n    feeTake = feeTake_;\r\n  }\r\n\r\n  function changeFeeRebate(uint feeRebate_) {\r\n    if (msg.sender != admin) throw;\r\n    if (feeRebate_ < feeRebate || feeRebate_ > feeTake) throw;\r\n    feeRebate = feeRebate_;\r\n  }\r\n\r\n  function deposit() payable {\r\n    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\r\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function withdraw(uint amount) {\r\n    if (msg.value>0) throw;\r\n    if (tokens[0][msg.sender] < amount) throw;\r\n    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\r\n    if (!msg.sender.call.value(amount)()) throw;\r\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function depositToken(address token, uint amount) {\r\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n    if (msg.value>0 || token==0) throw;\r\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\r\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\r\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function withdrawToken(address token, uint amount) {\r\n    if (msg.value>0 || token==0) throw;\r\n    if (tokens[token][msg.sender] < amount) throw;\r\n    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\r\n    if (!Token(token).transfer(msg.sender, amount)) throw;\r\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function balanceOf(address token, address user) constant returns (uint) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {\r\n    if (msg.value>0) throw;\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    orders[msg.sender][hash] = true;\r\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\r\n  }\r\n\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\r\n    //amount is in amountGet terms\r\n    if (msg.value>0) throw;\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(\r\n      (orders[user][hash] || ecrecover(hash,v,r,s) == user) &&\r\n      block.number <= expires &&\r\n      safeAdd(orderFills[user][hash], amount) <= amountGet\r\n    )) throw;\r\n    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\r\n    orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\r\n    Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\r\n  }\r\n\r\n  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\r\n    uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\r\n    uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\r\n    uint feeRebateXfer = 0;\r\n    if (accountLevelsAddr != 0x0) {\r\n      uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);\r\n      if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);\r\n      if (accountLevel==2) feeRebateXfer = feeTakeXfer;\r\n    }\r\n    tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\r\n    tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));\r\n    tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer));\r\n    tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\r\n    tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\r\n  }\r\n\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\r\n    if (!(\r\n      tokens[tokenGet][sender] >= amount &&\r\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\r\n    )) return false;\r\n    return true;\r\n  }\r\n\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(\r\n      (orders[user][hash] || ecrecover(hash,v,r,s) == user) &&\r\n      block.number <= expires\r\n    )) return 0;\r\n    uint available1 = safeSub(amountGet, orderFills[user][hash]);\r\n    uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\r\n    if (available1<available2) return available1;\r\n    return available2;\r\n  }\r\n\r\n  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    return orderFills[user][hash];\r\n  }\r\n\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\r\n    if (msg.value>0) throw;\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(orders[msg.sender][hash] || ecrecover(hash,v,r,s) == msg.sender)) throw;\r\n    orderFills[msg.sender][hash] = amountGet;\r\n    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\r\n  }\r\n}", 
  "balance": "2,898<b>.</b>467887356619612152 Ether", 
  "name": "EtherDelta", 
  "transactions": "6347", 
  "address": "0x373c55c277b866a69dc047cad488154ab9759466"
 }, 
 {
  "source": "/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\n\r\n/// @title Abstract token contract - Functions to be implemented by token contracts.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract Token {\r\n    // This is not an abstract function, because solc won't recognize generated getter functions for public variables as functions\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    function transfer(address to, uint256 value) returns (bool success);\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    /*\r\n     *  Data structures\r\n     */\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n\r\n    /*\r\n     *  Read and write storage functions\r\n     */\r\n    /// @dev Transfers sender's tokens to a given address. Returns success.\r\n    /// @param _to Address of token receiver.\r\n    /// @param _value Number of tokens to transfer.\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by given address.\r\n    /// @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Read storage functions\r\n     */\r\n    /// @dev Returns number of allowed tokens for given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract SingularDTVFund {\r\n    function workshop() returns (address);\r\n    function softWithdrawRevenueFor(address forAddress) returns (uint);\r\n}\r\ncontract SingularDTVCrowdfunding {\r\n    function twoYearsPassed() returns (bool);\r\n    function startDate() returns (uint);\r\n    function CROWDFUNDING_PERIOD() returns (uint);\r\n    function TOKEN_TARGET() returns (uint);\r\n    function valuePerShare() returns (uint);\r\n    function fundBalance() returns (uint);\r\n    function campaignEndedSuccessfully() returns (bool);\r\n}\r\n\r\n\r\n/// @title Token contract - Implements token issuance.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract SingularDTVToken is StandardToken {\r\n\r\n    /*\r\n     *  External contracts\r\n     */\r\n    SingularDTVFund constant singularDTVFund = SingularDTVFund(0xe736091fc36f1ad476f5e4e03e4425940822d3ba);\r\n    SingularDTVCrowdfunding constant singularDTVCrowdfunding = SingularDTVCrowdfunding(0xbdf5c4f1c1a9d7335a6a68d9aa011d5f40cf5520);\r\n\r\n    /*\r\n     *  Token meta data\r\n     */\r\n    string constant public name = \"SingularDTV\";\r\n    string constant public symbol = \"SNGLS\";\r\n    uint8 constant public decimals = 0;\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier noEther() {\r\n        if (msg.value > 0) {\r\n            throw;\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier workshopWaitedTwoYears() {\r\n        // Workshop can only transfer tokens after a two years period.\r\n        if (msg.sender == singularDTVFund.workshop() && !singularDTVCrowdfunding.twoYearsPassed()) {\r\n            throw;\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier isCrowdfundingContract () {\r\n        // Only crowdfunding contract is allowed to proceed.\r\n        if (msg.sender != address(singularDTVCrowdfunding)) {\r\n            throw;\r\n        }\r\n        _\r\n    }\r\n\r\n    /*\r\n     *  Contract functions\r\n     */\r\n    /// @dev Crowdfunding contract issues new tokens for address. Returns success.\r\n    /// @param _for Address of receiver.\r\n    /// @param tokenCount Number of tokens to issue.\r\n    function issueTokens(address _for, uint tokenCount)\r\n        external\r\n        isCrowdfundingContract\r\n        returns (bool)\r\n    {\r\n        if (tokenCount == 0) {\r\n            return false;\r\n        }\r\n        balances[_for] += tokenCount;\r\n        totalSupply += tokenCount;\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers sender's tokens to a given address. Returns success.\r\n    /// @param to Address of token receiver.\r\n    /// @param value Number of tokens to transfer.\r\n    function transfer(address to, uint256 value)\r\n        noEther\r\n        workshopWaitedTwoYears\r\n        returns (bool)\r\n    {\r\n        // Both parties withdraw their revenue first\r\n        singularDTVFund.softWithdrawRevenueFor(msg.sender);\r\n        singularDTVFund.softWithdrawRevenueFor(to);\r\n        return super.transfer(to, value);\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param from Address from where tokens are withdrawn.\r\n    /// @param to Address to where tokens are sent.\r\n    /// @param value Number of tokens to transfer.\r\n    function transferFrom(address from, address to, uint256 value)\r\n        noEther\r\n        workshopWaitedTwoYears\r\n        returns (bool)\r\n    {\r\n        // Both parties withdraw their revenue first\r\n        singularDTVFund.softWithdrawRevenueFor(from);\r\n        singularDTVFund.softWithdrawRevenueFor(to);\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n\r\n    /// @dev Contract constructor function sets initial token balances.\r\n    function SingularDTVToken() noEther {\r\n        // Set token creation for workshop\r\n        balances[singularDTVFund.workshop()] = 400000000; // ~400M\r\n        // Set token creation for core\r\n        balances[0x0196b712a0459cbee711e7c1d34d2c85a9910379] = 5000000;\r\n        balances[0x0f94dc84ce0f5fa2a8cc8d27a6969e25b5a39273] = 200000;\r\n        balances[0x122b7eb5f629d806c8adb0baa0560266abb3ec80] = 450000;\r\n        balances[0x13870d30fcdb7d7ae875668f2a1219225295d57c] = 50000;\r\n        balances[0x26640e826547bc700b8c7a9cc2c1c39a4ab3cbb3] = 900000;\r\n        balances[0x26bbfc6b23bc36e84447f061c6804f3a8b1a3698] = 250000;\r\n        balances[0x2d37383a45b5122a27efade69f7180eee4d965da] = 1270000;\r\n        balances[0x2e79b81121193d55c4934c0f32ad3d0474ca7b9c] = 4200000;\r\n        balances[0x3114844fc0e3de03963bbd1d983ba17ca89ad010] = 5000000;\r\n        balances[0x378e6582e4e3723f7076c7769eef6febf51258e1] = 680000;\r\n        balances[0x3e18530a4ee49a0357ffc8e74c08bfdee3915482] = 2490000;\r\n        balances[0x43fed1208d25ca0ef5681a5c17180af50c19f826] = 100000;\r\n        balances[0x4f183b18302c0ac5804b8c455018efc51af15a56] = 10000;\r\n        balances[0x55a886834658ccb6f26c39d5fdf6d833df3a276a] = 100000;\r\n        balances[0x5faa1624422db662c654ab35ce57bf3242888937] = 5000000;\r\n        balances[0x6407b662b306e2353b627488da952337a5a0bbaa] = 5000000;\r\n        balances[0x66c334fff8c8b8224b480d8da658ca3b032fe625] = 10000000;\r\n        balances[0x6c24991c6a40cd5ad6fab78388651fb324b35458] = 250000;\r\n        balances[0x781ba492f786b2be48c2884b733874639f50022c] = 500000;\r\n        balances[0x79b48f6f1ac373648c509b74a2c04a3281066457] = 2000000;\r\n        balances[0x835898804ed30e20aa29f2fe35c9f225175b049f] = 100000;\r\n        balances[0x93c56ea8848150389e0917de868b0a23c87cf7b1] = 2790000;\r\n        balances[0x93f959df3df3c6ee01ee9748327b881b2137bf2a] = 450000;\r\n        balances[0x9adc0215372e4ffd8c89621a6bd9cfddf230349f] = 550000;\r\n        balances[0xae4dbd3dae66722315541d66fe9457b342ac76d9] = 500000;\r\n        balances[0xbae02fe006f115e45b372f2ddc053eedca2d6fff] = 1800000;\r\n        balances[0xcc835821f643e090d8157de05451b416cd1202c4] = 300000;\r\n        balances[0xce75342b92a7d0b1a2c6e9835b6b85787e12e585] = 670000;\r\n        balances[0xd2b388467d9d0c30bab0a68070c6f49c473583a0] = 990000;\r\n        balances[0xdca0724ddde95bbace1b557cab4375d9a813da49] = 3500000;\r\n        balances[0xe3ef62165b60cac0fcbe9c2dc6a03aab4c5c8462] = 150000;\r\n        balances[0xe4f7d5083baeea7810b6d816581bb0ee7cd4b6f4] = 10560000;\r\n        balances[0xef08eb55d3482973c178b02bd4d5f2cea420325f] = 80000;\r\n        balances[0xfdecc9f2ee374cedc94f72ab4da2de896ce58c19] = 5000000;\r\n        balances[0xe5ff71dc1dea8cd2552eec59e9a5e8813da9bb01] = 29110000;\r\n        totalSupply = 500000000; // 500M\r\n    }\r\n}", 
  "balance": "103<b>.</b>221 Ether", 
  "name": "SingularDTVToken", 
  "transactions": "6234", 
  "address": "0xaec2e87e0a235266d9c5adc9deb4b2e29b54d009"
 }, 
 {
  "source": "contract ERC20TokenInterface {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}   \r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract XaurumProxyERC20 is ERC20TokenInterface {\r\n\r\n    bool public xaurumProxyWorking;\r\n\r\n    XaurumToken xaurumTokenReference; \r\n\r\n    address proxyCurrator;\r\n    address owner;\r\n    address dev;\r\n\r\n    /* Public variables of the token */\r\n    string public standard = 'XaurumERCProxy';\r\n    string public name = 'Xaurum';\r\n    string public symbol = 'XAUR';\r\n    uint8 public decimals = 8;\r\n\r\n\r\n    modifier isWorking(){\r\n        if (xaurumProxyWorking && !xaurumTokenReference.lockdown()){\r\n            _\r\n        }\r\n    }\r\n\r\n    function XaurumProxyERC20(){\r\n        dev = msg.sender;\r\n        xaurumProxyWorking = true;\r\n    }\r\n\r\n    function setTokenReference(address _xaurumTokenAress) returns (bool){\r\n        if (msg.sender == proxyCurrator){\r\n            xaurumTokenReference = XaurumToken(_xaurumTokenAress);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function EnableDisableTokenProxy() returns (bool){\r\n        if (msg.sender == proxyCurrator){        \r\n            xaurumProxyWorking = !xaurumProxyWorking;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setProxyCurrator(address _newCurratorAdress) returns (bool){\r\n        if (msg.sender == owner || msg.sender == dev){        \r\n            proxyCurrator = _newCurratorAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setOwner(address _newOwnerAdress) returns (bool){\r\n        if ( msg.sender == dev ){        \r\n            owner = _newOwnerAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function totalSupply() constant returns (uint256 supply) {\r\n        return xaurumTokenReference.totalSupply();\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return xaurumTokenReference.balanceOf(_owner);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) isWorking returns (bool success) {\r\n        bool answerStatus;\r\n        address sentFrom;\r\n        address sentTo;\r\n        uint256 sentToAmount;\r\n        address burningAddress;\r\n        uint256 burningAmount;\r\n\r\n        (answerStatus, sentFrom, sentTo, sentToAmount, burningAddress, burningAmount) = xaurumTokenReference.transferViaProxy(msg.sender, _to, _value);\r\n        if(answerStatus){\r\n            Transfer(sentFrom, sentTo, sentToAmount);\r\n            Transfer(sentFrom, burningAddress, burningAmount);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) isWorking returns (bool success) {\r\n        bool answerStatus;\r\n        address sentFrom;\r\n        address sentTo;\r\n        uint256 sentToAmount;\r\n        address burningAddress;\r\n        uint256 burningAmount;\r\n\r\n        (answerStatus, sentFrom, sentTo, sentToAmount, burningAddress, burningAmount) = xaurumTokenReference.transferFromViaProxy(msg.sender, _from, _to, _value);\r\n        if(answerStatus){\r\n            Transfer(sentFrom, sentTo, sentToAmount);\r\n            Transfer(sentFrom, burningAddress, burningAmount);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) isWorking returns (bool success) {\r\n        if (xaurumTokenReference.approveFromProxy(msg.sender, _spender, _value)){\r\n            Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return xaurumTokenReference.allowanceFromProxy(msg.sender, _owner, _spender);\r\n    } \r\n}\r\n\r\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\n\r\ncontract XaurumToken {\r\n    \r\n    /* Public variables of the token */\r\n    string public standard = 'Xaurum v1.0';\r\n    string public name = 'Xaurum';\r\n    string public symbol = 'XAUR';\r\n    uint8 public decimals = 8;\r\n\r\n    uint256 public totalSupply = 0;\r\n    uint256 public totalGoldSupply = 0;\r\n    bool public lockdown = false;\r\n    uint256 numberOfCoinages;\r\n\r\n    /* Private variabiles for the token */\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    mapping (address => uint) lockedAccounts;\r\n\r\n    /* Events */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Burn(address from, uint256 value, BurningType burningType);\r\n    event Melt(uint256 xaurAmount, uint256 goldAmount);\r\n    event Coinage(uint256 coinageId, uint256 usdAmount, uint256 xaurAmount, uint256 goldAmount, uint256 totalGoldSupply, uint256 totalSupply);\r\n\r\n    /*enums*/\r\n    enum BurningType { TxtFee, AllyDonation, ServiceFee }\r\n\r\n   /* Contracts */\r\n    XaurumMeltingContract public meltingContract;\r\n    function setMeltingContract(address _meltingContractAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            meltingContract = XaurumMeltingContract(_meltingContractAddress);\r\n        }\r\n    }\r\n\r\n    XaurumDataContract public dataContract;\r\n    function setDataContract(address _dataContractAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            dataContract = XaurumDataContract(_dataContractAddress);\r\n        }\r\n    }\r\n\r\n    XaurumCoinageContract public coinageContract;\r\n    function setCoinageContract(address _coinageContractAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            coinageContract = XaurumCoinageContract(_coinageContractAddress);\r\n        }\r\n    }\r\n\r\n    XaurmProxyContract public proxyContract;\r\n    function setProxyContract(address _proxyContractAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            proxyContract = XaurmProxyContract(_proxyContractAddress);\r\n        }\r\n    }\r\n\r\n    XaurumAlliesContract public alliesContract;\r\n    function setAlliesContract(address _alliesContractAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            alliesContract = XaurumAlliesContract(_alliesContractAddress);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n\r\n    /* owner */\r\n    address public owner;\r\n    function setOwner(address _newOwnerAdress) returns (bool){\r\n        if ( msg.sender == dev ){        \r\n            owner = _newOwnerAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    address public dev;\r\n\r\n    /* Xaur for gas */\r\n    address xaurForGasCurrator;\r\n    function setXauForGasCurrator(address _curratorAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            xaurForGasCurrator = _curratorAddress;\r\n        }\r\n    }\r\n\r\n    /* Burrning */\r\n    address public burningAdress;\r\n\r\n    /* Constructor */\r\n    function XaurumToken(address _burningAddress) { \r\n        burningAdress = _burningAddress;\r\n        lockdown = false;\r\n        dev = msg.sender;\r\n       \r\n        \r\n        // initial\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] += 5999319593600000;\r\n         totalSupply += 5999319593600000;\r\n         totalGoldSupply += 1696620000000;\r\n         Coinage(numberOfCoinages, 0, 5999319593600000, 1696620000000, totalGoldSupply, totalSupply);      \r\n\t\t\r\n\r\n        // Mint 1\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] += 1588947591000000;\r\n         totalSupply += 1588947591000000;\r\n         totalGoldSupply += 1106042126000;\r\n         Coinage(numberOfCoinages, 60611110000000, 1588947591000000, 1106042126000, totalGoldSupply, totalSupply);\r\n        \t\t\r\n\t\t\r\n        // Mint 2\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] += 151127191000000;\r\n         totalSupply += 151127191000000;\r\n         totalGoldSupply += 110134338200;\r\n         Coinage(numberOfCoinages, 6035361000000, 151127191000000, 110134338200, totalGoldSupply, totalSupply);\r\n        \r\n\t\t\r\n\t\t   // Mint 3\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] += 63789854418800;\r\n         totalSupply += 63789854418800;\r\n         totalGoldSupply +=  46701000000;\r\n         Coinage(numberOfCoinages, 2559215000000, 63789854418800, 46701000000, totalGoldSupply, totalSupply);\r\n        \r\n\r\n\t\t   // Mint 4\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] +=  393015011191000;\r\n         totalSupply += 393015011191000;\r\n         totalGoldSupply +=  290692000000;\r\n         Coinage(numberOfCoinages, 15929931000000, 393015011191000, 290692000000, totalGoldSupply, totalSupply);\r\n        \r\n\r\n\t\t   // Mint 5\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] +=  49394793870000;\r\n         totalSupply += 49394793870000;\r\n         totalGoldSupply +=  36891368614;\r\n         Coinage(numberOfCoinages, 2021647000000, 49394793870000, 36891368614, totalGoldSupply, totalSupply);\r\n    }\r\n    \r\n    function freezeCoin(){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            lockdown = !lockdown;\r\n        }\r\n    }\r\n\r\n    /* Get balance of the account */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _amount) returns (bool status) {\r\n        uint256 goldFee = dataContract.goldFee();\r\n\r\n        if (balances[msg.sender] >= _amount &&                                  // Check if the sender has enough\r\n            balances[_to] + _amount > balances[_to] &&                          // Check for overflows\r\n            _amount > goldFee &&                                                // Check if there is something left after burning fee\r\n            !lockdown &&                                                        // Check if coin is on lockdown\r\n            lockedAccounts[msg.sender] <= block.number) {                       // Check if the account is locked\r\n            balances[msg.sender] -= _amount;                                    // Subtract from the sender minus the fee\r\n            balances[_to] += (_amount - goldFee );                              // Add the same to the recipient\r\n            Transfer(msg.sender, _to, (_amount - goldFee ));                    // Notify anyone listening that this transfer took place\r\n            doBurn(msg.sender, goldFee, BurningType.TxtFee);                    // Notify anyone listening that this burn took place\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /* A contract attempts to get the coins and sends them*/\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool status) {\r\n        uint256 goldFee = dataContract.goldFee();\r\n\r\n        if (balances[_from] >= _amount &&                                  // Check if the sender has enough\r\n            balances[_to] + _amount > balances[_to] &&                          // Check for overflows\r\n            _amount > goldFee &&                                                // Check if there is something left after burning fee\r\n            !lockdown &&                                                        // Check if coin is on lockdown\r\n            lockedAccounts[_from] <= block.number) {                       // Check if the account is locked\r\n            if (_amount > allowed[_from][msg.sender]){                          // Check allowance\r\n                return false;\r\n            }\r\n            balances[_from] -= _amount;                                    // Subtract from the sender minus the fee\r\n            balances[_to] += (_amount - goldFee);                               // Add the same to the recipient\r\n            Transfer(_from, _to, (_amount - goldFee));                     // Notify anyone listening that this transfer took place\r\n            doBurn(_from, goldFee, BurningType.TxtFee);                    \r\n            allowed[_from][msg.sender] -= _amount;                              // Update allowance\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /* Allow another contract to spend some tokens in your behalf */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n        return true;\r\n    }\r\n\r\n     function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    /* Send coins via proxy */\r\n    function transferViaProxy(address _source, address _to, uint256 _amount) returns (bool status, address sendFrom, address sentTo, uint256 sentToAmount, address burnAddress, uint256 burnAmount){\r\n        if (!proxyContract.isProxyLegit(msg.sender)){                                        // Check if proxy is legit\r\n            return (false, 0, 0, 0, 0, 0);\r\n        }\r\n\r\n        uint256 goldFee = dataContract.goldFee();\r\n\r\n        if (balances[_source] >= _amount &&                                     // Check if the sender has enough\r\n            balances[_to] + _amount > balances[_to] &&                          // Check for overflows\r\n            _amount > goldFee &&                                                // Check if there is something left after burning fee\r\n            !lockdown &&                                                        // Check if coin is on lockdown\r\n            lockedAccounts[_source] <= block.number) {                          // Check if the account is locked\r\n            \r\n            balances[_source] -= _amount;                                       // Subtract from the sender minus the fee\r\n            balances[_to] += (_amount - goldFee );                              // Add the same to the recipient\r\n            Transfer(_source, _to, ( _amount - goldFee ));                    // Notify anyone listening that this transfer took place\r\n            doBurn(_source, goldFee, BurningType.TxtFee);                         // Notify anyone listening that this burn took place\r\n        \r\n            return (true, _source, _to, (_amount - goldFee), burningAdress, goldFee);\r\n        } else {\r\n            return (false, 0, 0, 0, 0, 0);\r\n        }\r\n    }\r\n    \r\n    /* a contract attempts to get the coins and sends them via proxy */\r\n    function transferFromViaProxy(address _source, address _from, address _to, uint256 _amount) returns (bool status, address sendFrom, address sentTo, uint256 sentToAmount, address burnAddress, uint256 burnAmount) {\r\n        if (!proxyContract.isProxyLegit(msg.sender)){                                            // Check if proxy is legit\r\n            return (false, 0, 0, 0, 0, 0);\r\n        }\r\n\r\n        uint256 goldFee = dataContract.goldFee();\r\n\r\n        if (balances[_from] >= _amount &&                                       // Check if the sender has enough\r\n            balances[_to] + _amount > balances[_to] &&                          // Check for overflows\r\n            _amount > goldFee &&                                                // Check if there is something left after burning fee\r\n            !lockdown &&                                                        // Check if coin is on lockdown\r\n            lockedAccounts[_from] <= block.number) {                            // Check if the account is locked\r\n\r\n            if (_amount > allowed[_from][_source]){                             // Check allowance\r\n                return (false, 0, 0, 0, 0, 0); \r\n            }               \r\n\r\n            balances[_from] -= _amount;                                         // Subtract from the sender minus the fee\r\n            balances[_to] += ( _amount - goldFee );                             // Add the same to the recipient\r\n            Transfer(_from, _to, ( _amount - goldFee ));                        // Notify anyone listening that this transfer took place\r\n            doBurn(_from, goldFee, BurningType.TxtFee);\r\n            allowed[_from][_source] -= _amount;                                 // Update allowance\r\n            return (true, _from, _to, (_amount - goldFee), burningAdress, goldFee);\r\n        } else {\r\n            return (false, 0, 0, 0, 0, 0);\r\n        }\r\n    }\r\n    \r\n     function approveFromProxy(address _source, address _spender, uint256 _value) returns (bool success) {\r\n        if (!proxyContract.isProxyLegit(msg.sender)){                                        // Check if proxy is legit\r\n            return false;\r\n        }\r\n        allowed[_source][_spender] = _value;\r\n        Approval(_source, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowanceFromProxy(address _source, address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n    \r\n    /* -----------------------------------------------------------------------*/\r\n    \r\n    /* Lock account for X amount of blocks */\r\n    function lockAccount(uint _block) returns (bool answer){\r\n        if (lockedAccounts[msg.sender] < block.number + _block){\r\n            lockedAccounts[msg.sender] = block.number + _block;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isAccountLocked(address _accountAddress) returns (bool){\r\n        if (lockedAccounts[_accountAddress] > block.number){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    ///\r\n    /// Xaur for gas region\r\n    ///\r\n\r\n    /* user get small amout of wei for a small amout of Xaur */\r\n    function getGasForXau(address _to) returns (bool sucess){\r\n        uint256 xaurForGasLimit = dataContract.xaurForGasLimit();\r\n        uint256 weiForXau = dataContract.weiForXau();\r\n\r\n        if (balances[msg.sender] > xaurForGasLimit && \r\n            balances[xaurForGasCurrator] < balances[xaurForGasCurrator]  + xaurForGasLimit &&\r\n            this.balance > dataContract.weiForXau()) {\r\n            if (_to.send(dataContract.weiForXau())){\r\n                balances[msg.sender] -= xaurForGasLimit;\r\n                balances[xaurForGasCurrator] += xaurForGasLimit;\r\n                return true;\r\n            }\r\n        } \r\n        return false;\r\n    }\r\n    \r\n    /* Currator fills eth through this function */\r\n    function fillGas(){\r\n        if (msg.sender != xaurForGasCurrator) { \r\n            throw; \r\n        }\r\n    }\r\n\r\n    ///\r\n    /// Melting region\r\n    ///\r\n\r\n    function doMelt(uint256 _xaurAmount, uint256 _goldAmount) returns (bool){\r\n        if (msg.sender == address(meltingContract)){\r\n            totalSupply -= _xaurAmount;\r\n            totalGoldSupply -= _goldAmount;\r\n            Melt(_xaurAmount, _goldAmount);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    ///\r\n    /// Proxy region\r\n    ///\r\n\r\n    \r\n\r\n    ///\r\n    /// Coinage region\r\n    ///\r\n    function doCoinage(address[] _coinageAddresses, uint256[] _coinageAmounts, uint256 _usdAmount, uint256 _xaurCoined, uint256 _goldBought) returns (bool){\r\n        if (msg.sender == address(coinageContract) && \r\n            _coinageAddresses.length == _coinageAmounts.length){\r\n            \r\n            totalSupply += _xaurCoined;\r\n            totalGoldSupply += _goldBought;\r\n            numberOfCoinages += 1;\r\n            Coinage(numberOfCoinages, _usdAmount, _xaurCoined, _goldBought, totalGoldSupply, totalSupply);\r\n            for (uint256 cnt = 0; cnt < _coinageAddresses.length; cnt++){\r\n                balances[_coinageAddresses[cnt]] += _coinageAmounts[cnt]; \r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    ///\r\n    /// Burining region\r\n    ///\r\n    function doBurn(address _from, uint256 _amountToBurn, BurningType _burningType) internal {\r\n        balances[burningAdress] += _amountToBurn;                              // Burn the fee\r\n        totalSupply -= _amountToBurn;                                          // Edit total supply\r\n        Burn(_from, _amountToBurn, _burningType);                              // Notify anyone listening that this burn took place\r\n    }\r\n\r\n    function doBurnFromContract(address _from, uint256 _amount) returns (bool){\r\n        if (msg.sender == address(alliesContract)){\r\n            balances[_from] -= _amount;\r\n            doBurn(_from, _amount, BurningType.AllyDonation);\r\n            return true;\r\n        }\r\n        else if(msg.sender == address(coinageContract)){\r\n            balances[_from] -= _amount;\r\n            doBurn(_from, _amount, BurningType.ServiceFee);\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n    /* This unnamed function is called whenever someone tries to send ether to it */\r\n    function () {\r\n        throw;     // Prevents accidental sending of ether\r\n    }\r\n}\r\n\r\ncontract XaurumMeltingContract {}\r\n\r\ncontract XaurumAlliesContract {}\r\n\r\ncontract XaurumCoinageContract {}\r\n\r\ncontract XaurmProxyContract{\r\n\r\n    address public owner;\r\n    address public curator;\r\n    address public dev;\r\n\r\n    function XaurmProxyContract(){\r\n        dev = msg.sender;\r\n    }\r\n\r\n    function setProxyCurrator(address _newCurratorAdress) returns (bool){\r\n        if (msg.sender == owner || msg.sender == dev){        \r\n            curator = _newCurratorAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setOwner(address _newOwnerAdress) returns (bool){\r\n        if ( msg.sender == dev ){        \r\n            owner = _newOwnerAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /* Proxy Contract */\r\n    \r\n    address[] approvedProxys; \r\n    mapping (address => bool) proxyList;\r\n    \r\n    /* Adds new proxy to proxy lists and grants him the permission to use transferViaProxy */\r\n    function addNewProxy(address _proxyAdress){\r\n        if(msg.sender == curator){\r\n            proxyList[_proxyAdress] = true;\r\n            approvedProxys.push(_proxyAdress);\r\n        }\r\n    }\r\n\r\n    function isProxyLegit(address _proxyAddress) returns (bool){\r\n        return proxyList[_proxyAddress];\r\n    }\r\n    \r\n    function getApprovedProxys() returns (address[] proxys){\r\n        return approvedProxys;\r\n    }\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n}\r\n\r\ncontract XaurumDataContract {\r\n\r\n    /* Minting data */\r\n    uint256 public xauToEur;\r\n    uint256 public goldToEur;\r\n    uint256 public mintingDataUpdatedAtBlock;\r\n\r\n    /* Gas for xaur data */\r\n    uint256 public xaurForGasLimit;\r\n    uint256 public weiForXau;\r\n    uint256 public gasForXaurDataUpdateAtBlock;\r\n\r\n    /* Other data */\r\n    uint256 public goldFee;\r\n    uint256 public goldFeeDataUpdatedAtBlock;\r\n\r\n    address public owner;\r\n    address public curator;\r\n    address public dev;\r\n\r\n    function XaurumDataContract(){\r\n        xaurForGasLimit = 100000000;\r\n        weiForXau = 100000000000000000;\r\n        goldFee = 50000000;\r\n       // dev = _dev;\r\n\t   dev = msg.sender;\r\n    }\r\n\r\n    function setProxyCurrator(address _newCurratorAdress) returns (bool){\r\n        if (msg.sender == owner || msg.sender == dev){        \r\n            curator = _newCurratorAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setOwner(address _newOwnerAdress) returns (bool){\r\n        if ( msg.sender == dev ){        \r\n            owner = _newOwnerAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function updateMintingData(uint256 _xauToEur, uint256 _goldToEur) returns (bool status){\r\n        if (msg.sender == curator || msg.sender == dev){\r\n            xauToEur = _xauToEur;\r\n            goldToEur = _goldToEur;\r\n            mintingDataUpdatedAtBlock = block.number;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function updateGasForXaurData(uint256 _xaurForGasLimit, uint256 _weiForXau) returns (bool status){\r\n        if (msg.sender == curator || msg.sender == dev){\r\n            xaurForGasLimit = _xaurForGasLimit;\r\n            weiForXau = _weiForXau;\r\n            gasForXaurDataUpdateAtBlock = block.number;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function updateGoldFeeData(uint256 _goldFee) returns (bool status){\r\n        if (msg.sender == curator || msg.sender == dev){\r\n            goldFee = _goldFee;\r\n            goldFeeDataUpdatedAtBlock = block.number;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n}", 
  "balance": "0<b>.</b>002 Ether", 
  "name": "XaurumToken", 
  "transactions": "6138", 
  "address": "0x4df812f6064def1e5e029f1ca858777cc98d2d81"
 }, 
 {
  "source": "pragma solidity ^0.4.4;\r\n\r\n\r\n/// @title Golem Network Token (GNT) - crowdfunding code for Golem Project\r\ncontract GolemNetworkToken {\r\n    string public constant name = \"Golem Network Token\";\r\n    string public constant symbol = \"GNT\";\r\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\r\n\r\n    uint256 public constant tokenCreationRate = 1000;\r\n\r\n    // The funding cap in weis.\r\n    uint256 public constant tokenCreationCap = 820000 ether * tokenCreationRate;\r\n    uint256 public constant tokenCreationMin = 150000 ether * tokenCreationRate;\r\n\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n\r\n    // The flag indicates if the GNT contract is in Funding state.\r\n    bool public funding = true;\r\n\r\n    // Receives ETH and its own GNT endowment.\r\n    address public golemFactory;\r\n\r\n    // Has control over token migration to next version of token.\r\n    address public migrationMaster;\r\n\r\n    GNTAllocation lockedAllocation;\r\n\r\n    // The current total token supply.\r\n    uint256 totalTokens;\r\n\r\n    mapping (address => uint256) balances;\r\n\r\n    address public migrationAgent;\r\n    uint256 public totalMigrated;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\r\n    event Refund(address indexed _from, uint256 _value);\r\n\r\n    function GolemNetworkToken(address _golemFactory,\r\n                               address _migrationMaster,\r\n                               uint256 _fundingStartBlock,\r\n                               uint256 _fundingEndBlock) {\r\n\r\n        if (_golemFactory == 0) throw;\r\n        if (_migrationMaster == 0) throw;\r\n        if (_fundingStartBlock <= block.number) throw;\r\n        if (_fundingEndBlock   <= _fundingStartBlock) throw;\r\n\r\n        lockedAllocation = new GNTAllocation(_golemFactory);\r\n        migrationMaster = _migrationMaster;\r\n        golemFactory = _golemFactory;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n    }\r\n\r\n    /// @notice Transfer `_value` GNT tokens from sender's account\r\n    /// `msg.sender` to provided account address `_to`.\r\n    /// @notice This function is disabled during the funding.\r\n    /// @dev Required state: Operational\r\n    /// @param _to The address of the tokens recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool) {\r\n        // Abort if not in Operational state.\r\n        if (funding) throw;\r\n\r\n        var senderBalance = balances[msg.sender];\r\n        if (senderBalance >= _value && _value > 0) {\r\n            senderBalance -= _value;\r\n            balances[msg.sender] = senderBalance;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function totalSupply() external constant returns (uint256) {\r\n        return totalTokens;\r\n    }\r\n\r\n    function balanceOf(address _owner) external constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    // Token migration support:\r\n\r\n    /// @notice Migrate tokens to the new token contract.\r\n    /// @dev Required state: Operational Migration\r\n    /// @param _value The amount of token to be migrated\r\n    function migrate(uint256 _value) external {\r\n        // Abort if not in Operational Migration state.\r\n        if (funding) throw;\r\n        if (migrationAgent == 0) throw;\r\n\r\n        // Validate input value.\r\n        if (_value == 0) throw;\r\n        if (_value > balances[msg.sender]) throw;\r\n\r\n        balances[msg.sender] -= _value;\r\n        totalTokens -= _value;\r\n        totalMigrated += _value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n        Migrate(msg.sender, migrationAgent, _value);\r\n    }\r\n\r\n    /// @notice Set address of migration target contract and enable migration\r\n\t/// process.\r\n    /// @dev Required state: Operational Normal\r\n    /// @dev State transition: -> Operational Migration\r\n    /// @param _agent The address of the MigrationAgent contract\r\n    function setMigrationAgent(address _agent) external {\r\n        // Abort if not in Operational Normal state.\r\n        if (funding) throw;\r\n        if (migrationAgent != 0) throw;\r\n        if (msg.sender != migrationMaster) throw;\r\n        migrationAgent = _agent;\r\n    }\r\n\r\n    function setMigrationMaster(address _master) external {\r\n        if (msg.sender != migrationMaster) throw;\r\n        if (_master == 0) throw;\r\n        migrationMaster = _master;\r\n    }\r\n\r\n    // Crowdfunding:\r\n\r\n    /// @notice Create tokens when funding is active.\r\n    /// @dev Required state: Funding Active\r\n    /// @dev State transition: -> Funding Success (only if cap reached)\r\n    function create() payable external {\r\n        // Abort if not in Funding Active state.\r\n        // The checks are split (instead of using or operator) because it is\r\n        // cheaper this way.\r\n        if (!funding) throw;\r\n        if (block.number < fundingStartBlock) throw;\r\n        if (block.number > fundingEndBlock) throw;\r\n\r\n        // Do not allow creating 0 or more than the cap tokens.\r\n        if (msg.value == 0) throw;\r\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\r\n            throw;\r\n\r\n        var numTokens = msg.value * tokenCreationRate;\r\n        totalTokens += numTokens;\r\n\r\n        // Assign new tokens to the sender\r\n        balances[msg.sender] += numTokens;\r\n\r\n        // Log token creation event\r\n        Transfer(0, msg.sender, numTokens);\r\n    }\r\n\r\n    /// @notice Finalize crowdfunding\r\n    /// @dev If cap was reached or crowdfunding has ended then:\r\n    /// create GNT for the Golem Factory and developer,\r\n    /// transfer ETH to the Golem Factory address.\r\n    /// @dev Required state: Funding Success\r\n    /// @dev State transition: -> Operational Normal\r\n    function finalize() external {\r\n        // Abort if not in Funding Success state.\r\n        if (!funding) throw;\r\n        if ((block.number <= fundingEndBlock ||\r\n             totalTokens < tokenCreationMin) &&\r\n            totalTokens < tokenCreationCap) throw;\r\n\r\n        // Switch to Operational state. This is the only place this can happen.\r\n        funding = false;\r\n\r\n        // Create additional GNT for the Golem Factory and developers as\r\n        // the 18% of total number of tokens.\r\n        // All additional tokens are transfered to the account controller by\r\n        // GNTAllocation contract which will not allow using them for 6 months.\r\n        uint256 percentOfTotal = 18;\r\n        uint256 additionalTokens =\r\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\r\n        totalTokens += additionalTokens;\r\n        balances[lockedAllocation] += additionalTokens;\r\n        Transfer(0, lockedAllocation, additionalTokens);\r\n\r\n        // Transfer ETH to the Golem Factory address.\r\n        if (!golemFactory.send(this.balance)) throw;\r\n    }\r\n\r\n    /// @notice Get back the ether sent during the funding in case the funding\r\n    /// has not reached the minimum level.\r\n    /// @dev Required state: Funding Failure\r\n    function refund() external {\r\n        // Abort if not in Funding Failure state.\r\n        if (!funding) throw;\r\n        if (block.number <= fundingEndBlock) throw;\r\n        if (totalTokens >= tokenCreationMin) throw;\r\n\r\n        var gntValue = balances[msg.sender];\r\n        if (gntValue == 0) throw;\r\n        balances[msg.sender] = 0;\r\n        totalTokens -= gntValue;\r\n\r\n        var ethValue = gntValue / tokenCreationRate;\r\n        Refund(msg.sender, ethValue);\r\n        if (!msg.sender.send(ethValue)) throw;\r\n    }\r\n}\r\n\r\n\r\n/// @title Migration Agent interface\r\ncontract MigrationAgent {\r\n    function migrateFrom(address _from, uint256 _value);\r\n}\r\n\r\n\r\n/// @title GNT Allocation - Time-locked vault of tokens allocated\r\n/// to developers and Golem Factory\r\ncontract GNTAllocation {\r\n    // Total number of allocations to distribute additional tokens among\r\n    // developers and the Golem Factory. The Golem Factory has right to 20000\r\n    // allocations, developers to 10000 allocations, divides among individual\r\n    // developers by numbers specified in  `allocations` table.\r\n    uint256 constant totalAllocations = 30000;\r\n\r\n    // Addresses of developer and the Golem Factory to allocations mapping.\r\n    mapping (address => uint256) allocations;\r\n\r\n    GolemNetworkToken gnt;\r\n    uint256 unlockedAt;\r\n\r\n    uint256 tokensCreated = 0;\r\n\r\n    function GNTAllocation(address _golemFactory) internal {\r\n        gnt = GolemNetworkToken(msg.sender);\r\n        unlockedAt = now + 6 * 30 days;\r\n\r\n        // For the Golem Factory:\r\n        allocations[_golemFactory] = 20000; // 12/18 pp of 30000 allocations.\r\n\r\n        // For developers:\r\n        allocations[0x9d3F257827B17161a098d380822fa2614FF540c8] = 2500; // 25.0% of developers' allocations (10000).\r\n        allocations[0xd7406E50b73972Fa4aa533a881af68B623Ba3F66] =  730; //  7.3% of developers' allocations.\r\n        allocations[0xd15356D05A7990dE7eC94304B0fD538e550c09C0] =  730;\r\n        allocations[0x3971D17B62b825b151760E2451F818BfB64489A7] =  730;\r\n        allocations[0x95e337d09f1bc67681b1cab7ed1125ea2bae5ca8] =  730;\r\n        allocations[0x0025C58dB686b8CEce05CB8c50C1858b63Aa396E] =  730;\r\n        allocations[0xB127FC62dE6ca30aAc9D551591daEDdeBB2eFD7A] =  630; //  6.3% of developers' allocations.\r\n        allocations[0x21AF2E2c240a71E9fB84e90d71c2B2AddE0D0e81] =  630;\r\n        allocations[0x682AA1C3b3E102ACB9c97B861d595F9fbfF0f1B8] =  630;\r\n        allocations[0x6edd429c77803606cBd6Bb501CC701a6CAD6be01] =  630;\r\n        allocations[0x5E455624372FE11b39464e93d41D1F6578c3D9f6] =  310; //  3.1% of developers' allocations.\r\n        allocations[0xB7c7EaD515Ca275d53e30B39D8EBEdb3F19dA244] =  138; //  1.38% of developers' allocations.\r\n        allocations[0xD513b1c3fe31F3Fe0b1E42aa8F55e903F19f1730] =  135; //  1.35% of developers' allocations.\r\n        allocations[0x70cac7f8E404EEFce6526823452e428b5Ab09b00] =  100; //  1.0% of developers' allocations.\r\n        allocations[0xe0d5861e7be0fac6c85ecde6e8bf76b046a96149] =  100;\r\n        allocations[0x17488694D2feE4377Ec718836bb9d4910E81D9Cf] =  100;\r\n        allocations[0xb481372086dEc3ca2FCCD3EB2f462c9C893Ef3C5] =  100;\r\n        allocations[0xFB6D91E69CD7990651f26a3aa9f8d5a89159fC92] =   70; //  0.7% of developers' allocations.\r\n        allocations[0xE2ABdAe2980a1447F445cb962f9c0bef1B63EE13] =   70;\r\n        allocations[0x729A5c0232712caAf365fDd03c39cb361Bd41b1C] =   70;\r\n        allocations[0x12FBD8fef4903f62e30dD79AC7F439F573E02697] =   70;\r\n        allocations[0x657013005e5cFAF76f75d03b465cE085d402469A] =   42; //  0.42% of developers' allocations.\r\n        allocations[0xD0AF9f75EA618163944585bF56aCA98204d0AB66] =   25; //  0.25% of developers' allocations.\r\n    }\r\n\r\n    /// @notice Allow developer to unlock allocated tokens by transferring them\r\n    /// from GNTAllocation to developer's address.\r\n    function unlock() external {\r\n        if (now < unlockedAt) throw;\r\n\r\n        // During first unlock attempt fetch total number of locked tokens.\r\n        if (tokensCreated == 0)\r\n            tokensCreated = gnt.balanceOf(this);\r\n\r\n        var allocation = allocations[msg.sender];\r\n        allocations[msg.sender] = 0;\r\n        var toTransfer = tokensCreated * allocation / totalAllocations;\r\n\r\n        // Will fail if allocation (and therefore toTransfer) is 0.\r\n        if (!gnt.transfer(msg.sender, toTransfer)) throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "GolemNetworkToken", 
  "transactions": "6109", 
  "address": "0xa74476443119a942de498590fe1f2454d7d4ac0d"
 }, 
 {
  "source": "contract ExtraBalToken {\r\n    uint256 public totalSupply;\r\n\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\r\n    }\r\n\r\n    /* Allow another contract to spend some tokens in your behalf */\r\n    function approve(address _spender, uint256 _value)\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /* A contract attempts to get the coins */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\r\n        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\r\n        balanceOf[_from] -= _value;                          // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /* This unnamed function is called whenever someone tries to send ether to it */\r\n    function () {\r\n        throw;     // Prevents accidental sending of ether\r\n    }\r\n\r\n    uint constant D160 = 0x10000000000000000000000000000000000000000;\r\n\r\n    address public owner;\r\n\r\n    function ExtraBalToken() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    bool public sealed;\r\n    // The 160 LSB is the address of the balance\r\n    // The 96 MSB is the balance of that address.\r\n    function fill(uint[] data) {\r\n        if ((msg.sender != owner)||(sealed))\r\n            throw;\r\n\r\n        for (uint i=0; i<data.length; i++) {\r\n            address a = address( data[i] & (D160-1) );\r\n            uint amount = data[i] / D160;\r\n            if (balanceOf[a] == 0) {   // In case it's filled two times, it only increments once\r\n                balanceOf[a] = amount;\r\n                totalSupply += amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function seal() {\r\n        if ((msg.sender != owner)||(sealed))\r\n            throw;\r\n\r\n        sealed= true;\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "ExtraBalToken", 
  "transactions": "5639", 
  "address": "0x5c40ef6f527f4fba68368774e6130ce6515123f2"
 }, 
 {
  "source": "// Refund contract for extraBalance\r\n// Amounts to be paid are tokenized in another contract and allow using the same refund contract as for theDAO\r\n// Though it may be misleading, the names 'DAO', 'mainDAO' are kept here for the ease of code review\r\n\r\ncontract DAO {\r\n    function balanceOf(address addr) returns (uint);\r\n    function transferFrom(address from, address to, uint balance) returns (bool);\r\n    uint public totalSupply;\r\n}\r\n\r\ncontract WithdrawDAO {\r\n    DAO constant public mainDAO = DAO(0x5c40ef6f527f4fba68368774e6130ce6515123f2);\r\n    address constant public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;\r\n\r\n    function withdraw(){\r\n        uint balance = mainDAO.balanceOf(msg.sender);\r\n\r\n        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))\r\n            throw;\r\n    }\r\n\r\n    /**\r\n    * Return funds back to the curator.\r\n    */\r\n    function clawback() external {\r\n        if (msg.sender != trustee) throw;\r\n        if (!trustee.send(this.balance)) throw;\r\n    }\r\n}", 
  "balance": "121,197<b>.</b>509641546003563438 Ether", 
  "name": "WithdrawDAO", 
  "transactions": "5573", 
  "address": "0x755cdba6ae4f479f7164792b318b2a06c759833b"
 }, 
 {
  "source": "pragma solidity ^0.4.4;\r\n\r\n/**\r\n * @title Project Kudos\r\n *\r\n * Events voting system of the Virtual Accelerator.\r\n * Includes the voting for both judges and fans.\r\n *\r\n */\r\ncontract ProjectKudos {\r\n\r\n    // votes limit for judge\r\n    uint KUDOS_LIMIT_JUDGE = 1000;\r\n\r\n    // votes limit for regular user\r\n    uint KUDOS_LIMIT_USER  = 10;\r\n\r\n    // additional votes given for social account proof\r\n    uint SOCIAL_PROOF_KUDOS = 100;\r\n\r\n    // Grant Reason\r\n    uint GRANT_REASON_FACEBOOK = 0;\r\n    uint GRANT_REASON_TWITTER = 1;\r\n\r\n    // keeps project votes data\r\n    struct ProjectInfo {\r\n        mapping(address => uint) kudosByUser;\r\n        uint kudosTotal;\r\n    }\r\n\r\n    // keeps user votes data\r\n    struct UserInfo {\r\n        uint kudosLimit;\r\n        uint kudosGiven;\r\n        bool isJudge;\r\n        mapping(uint => bool) grant;\r\n    }\r\n\r\n    // keeps links between user's votes\r\n    // and projects he voted for\r\n    struct UserIndex {\r\n        bytes32[] projects;\r\n        uint[] kudos;\r\n        mapping(bytes32 => uint) kudosIdx;\r\n    }\r\n\r\n    // keeps time frames for vote period\r\n    struct VotePeriod {\r\n        uint start;\r\n        uint end;\r\n    }\r\n\r\n    // contract creator's address\r\n    address owner;\r\n\r\n    // vote period\r\n    VotePeriod votePeriod;\r\n\r\n    // user votes mapping\r\n    mapping(address => UserInfo) users;\r\n\r\n    // user index,\r\n    // helps to get votes given by one user for every project\r\n    mapping(address => UserIndex) usersIndex;\r\n\r\n    // project votes mapping\r\n    mapping(bytes32 => ProjectInfo) projects;\r\n\r\n    // emitted when vote is done\r\n    event Vote(\r\n        // address of voter\r\n        address indexed voter,\r\n        // sha3 of project code\r\n        bytes32 indexed projectCode,\r\n        // votes given\r\n        uint indexed count\r\n    );\r\n\r\n    /**\r\n     * @dev Contract's constructor.\r\n     * Stores contract's owner and sets up vote period\r\n     */\r\n    function ProjectKudos() {\r\n\r\n        owner = msg.sender;\r\n\r\n        votePeriod = VotePeriod(\r\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\r\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Registers voter to the event.\r\n     * Executable only by contract's owner.\r\n     *\r\n     * @param userAddress address of the user to register\r\n     * @param isJudge should be true if user is judge, false otherwise\r\n     */\r\n    function register(address userAddress, bool isJudge) onlyOwner {\r\n\r\n        UserInfo user = users[userAddress];\r\n\r\n        if (user.kudosLimit > 0) throw;\r\n\r\n        if (isJudge)\r\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\r\n        else\r\n            user.kudosLimit = KUDOS_LIMIT_USER;\r\n\r\n        user.isJudge = isJudge;\r\n\r\n        users[userAddress] = user;\r\n    }\r\n\r\n    /**\r\n     *  @dev Gives votes to the project.\r\n     *  Can only be executed within vote period.\r\n     *  User signed the Tx becomes votes giver.\r\n     *\r\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\r\n     *  @param kudos - votes to be given\r\n     */\r\n    function giveKudos(bytes32 projectCode, uint kudos) {\r\n\r\n        // throw if called not during the vote period\r\n        if (now < votePeriod.start) throw;\r\n        if (now >= votePeriod.end) throw;        \r\n        \r\n        UserInfo giver = users[msg.sender];\r\n\r\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\r\n\r\n        ProjectInfo project = projects[projectCode];\r\n\r\n        giver.kudosGiven += kudos;\r\n        project.kudosTotal += kudos;\r\n        project.kudosByUser[msg.sender] += kudos;\r\n\r\n        // save index of user voting history\r\n        updateUsersIndex(projectCode, project.kudosByUser[msg.sender]);\r\n\r\n        Vote(msg.sender, projectCode, kudos);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants extra kudos for identity proof.\r\n     *\r\n     * @param userToGrant address of user to grant additional\r\n     * votes for social proof\r\n     * \r\n     * @param reason granting reason,  0 - Facebook, 1 - Twitter\r\n     */         \r\n    function grantKudos(address userToGrant, uint reason) onlyOwner {\r\n\r\n        UserInfo user = users[userToGrant];\r\n\r\n        if (user.kudosLimit == 0) throw; //probably user does not exist then\r\n\r\n        if (reason != GRANT_REASON_FACEBOOK &&        // Facebook\r\n            reason != GRANT_REASON_TWITTER) throw;    // Twitter\r\n\r\n        // if user is judge his identity is known\r\n        // not reasonble to grant more kudos for social\r\n        // proof.\r\n        if (user.isJudge) throw;\r\n\r\n        // if not granted for that reason yet\r\n        if (user.grant[reason]) throw;\r\n\r\n        // grant 100 votes\r\n        user.kudosLimit += SOCIAL_PROOF_KUDOS;\r\n        \r\n        user.grant[reason] = true;\r\n    }\r\n\r\n\r\n    // ********************* //\r\n    // *   Constant Calls  * //\r\n    // ********************* //\r\n\r\n    /**\r\n     * @dev Returns total votes given to the project\r\n     *\r\n     * @param projectCode project's code\r\n     *\r\n     * @return number of give votes\r\n     */\r\n    function getProjectKudos(bytes32 projectCode) constant returns(uint) {\r\n        ProjectInfo project = projects[projectCode];\r\n        return project.kudosTotal;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array of votes given to the project\r\n     * corresponding to array of users passed in function call\r\n     *\r\n     * @param projectCode project's code\r\n     * @param users array of user addresses\r\n     *\r\n     * @return array of votes given by passed users\r\n     */\r\n    function getProjectKudosByUsers(bytes32 projectCode, address[] users) constant returns(uint[]) {\r\n        ProjectInfo project = projects[projectCode];\r\n        mapping(address => uint) kudosByUser = project.kudosByUser;\r\n        uint[] memory userKudos = new uint[](users.length);\r\n        for (uint i = 0; i < users.length; i++) {\r\n            userKudos[i] = kudosByUser[users[i]];\r\n       }\r\n\r\n       return userKudos;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns votes given by specified user\r\n     * to the list of projects ever voted by that user\r\n     *\r\n     * @param giver user's address\r\n     * @return projects array of project codes represented by bytes32 array\r\n     * @return kudos array of votes given by user,\r\n     *         index of vote corresponds to index of project from projects array\r\n     */\r\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\r\n        UserIndex idx = usersIndex[giver];\r\n        projects = idx.projects;\r\n        kudos = idx.kudos;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns votes allowed to be given by user\r\n     *\r\n     * @param addr user's address\r\n     * @return number of votes left\r\n     */\r\n    function getKudosLeft(address addr) constant returns(uint) {\r\n        UserInfo user = users[addr];\r\n        return user.kudosLimit - user.kudosGiven;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns votes given by user\r\n     *\r\n     * @param addr user's address\r\n     * @return number of votes given\r\n     */\r\n    function getKudosGiven(address addr) constant returns(uint) {\r\n        UserInfo user = users[addr];\r\n        return user.kudosGiven;\r\n    }\r\n\r\n\r\n    // ********************* //\r\n    // *   Private Calls   * //\r\n    // ********************* //\r\n\r\n    /**\r\n     * @dev Private function. Updates users index\r\n     *\r\n     * @param code project code represented by bytes32 array\r\n     * @param kudos votes total given to the project by sender\r\n     */\r\n    function updateUsersIndex(bytes32 code, uint kudos) private {\r\n\r\n        UserIndex idx = usersIndex[msg.sender];\r\n        uint i = idx.kudosIdx[code];\r\n\r\n        // add new entry to index\r\n        if (i == 0) {\r\n            i = idx.projects.length + 1;\r\n            idx.projects.length += 1;\r\n            idx.kudos.length += 1;\r\n            idx.projects[i - 1] = code;\r\n            idx.kudosIdx[code] = i;\r\n        }\r\n\r\n        idx.kudos[i - 1] = kudos;\r\n    }\r\n\r\n\r\n    // ********************* //\r\n    // *     Modifiers     * //\r\n    // ********************* //\r\n\r\n    /**\r\n     * @dev Throws if called not by contract's owner\r\n     */\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ProjectKudos", 
  "transactions": "5551", 
  "address": "0x5e569e1ecd56fe30dd97ee233ec1675b60fb6680"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "28,555<b>.</b>094123613668268371 Ether", 
  "name": "Wallet", 
  "transactions": "5422", 
  "address": "0xd73026b0494d25427f3d1a7743babe1bddf8a035"
 }, 
 {
  "source": "//pragma solidity ^0.3.6;\r\ncontract Token {\r\n\tfunction balanceOf(address user) constant returns (uint256 balance);\r\n\tfunction transfer(address receiver, uint amount) returns(bool);\r\n}\r\n\r\n// A Sub crowdfunding contract. Its only purpose is to redirect ether it receives to the \r\n// main crowdfunding contract. This mecanism is usefull to know the sponsor to\r\n// reward for an indirect donation. You can't give for someone else when you give through\r\n// these contracts\r\ncontract AltCrowdfunding {\r\n\t\r\n\tCrowdfunding mainCf ;                                       // Referenre to the main crowdfunding contract\r\n\t\r\n\tfunction AltCrowdfunding(address cf){\t\t\t\t\t\t// Construct the altContract with a reference to the main one\r\n\t\tmainCf = Crowdfunding(cf);\r\n\t}\r\n\t\r\n\tfunction(){\r\n\t\tmainCf.giveFor.value(msg.value)(msg.sender);\t\t\t// Relay Ether sent to the main crowndfunding contract\r\n\t}\r\n\t\r\n}\r\n\r\ncontract Crowdfunding {\r\n\r\n\tstruct Backer {\r\n\t\tuint weiGiven;\t\t\t\t\t\t\t\t\t\t// Amount of Ether given\r\n\t\tuint ungivenNxc ;                                 \t// (pending) If the first goal of the crowdfunding is not reached yet the NxC are stored here\r\n\t}\r\n\t\r\n\tstruct Sponsor {\r\n\t    uint nxcDirected;                                   // How much milli Nxc this sponsor sold for us\r\n\t    uint earnedNexium;                                  // How much milli Nxc this sponsor earned by solding Nexiums for us\r\n\t    address sponsorAddress;                             // Where Nexiums earned by a sponsor are sent\r\n\t    uint sponsorBonus;\r\n\t    uint backerBonus;\r\n\t}\r\n\t\r\n    //Every public variable can be read by everyone from the blockchain\r\n\t\r\n\tToken \tpublic nexium;                                  // Nexium contract reference\r\n\taddress public owner;\t\t\t\t\t               \t// Contract admin (beyond the void)\r\n\taddress public beyond;\t\t\t\t\t            \t// Address that will receive ether when the first step is be reached\r\n\taddress public bitCrystalEscrow;   \t\t\t\t\t\t// Our escrow for Bitcrystals (ie EverdreamSoft)\r\n\tuint \tpublic startingEtherValue;\t\t\t\t\t\t// How much milli Nxc are sent by ether\r\n\tuint \tpublic stepEtherValue;\t\t\t\t\t        // For every stage of the crowdfunding, the number of Nexium sent by ether is decreased by this number\r\n\tuint    public collectedEth;                            // Collected ether in wei\r\n\tuint \tpublic nxcSold;                                 // How much milli Nxc were sold \r\n\tuint \tpublic perStageNxc;                             // How much milli Nxc we much sell for each stage\r\n\tuint \tpublic nxcPerBcy;                         \t\t// How much milli Nxc we give for each Bitcrystal\r\n    uint \tpublic collectedBcy;                            // Collected Bitcrystals\r\n\tuint \tpublic minInvest;\t\t\t\t            \t// Minimum to invest (in wei)\r\n\tuint \tpublic startDate;    \t\t\t\t\t\t\t// crowndfunding startdate                               \r\n\tuint \tpublic endDate;\t\t\t\t\t\t\t\t\t// crowndfunding enddate \r\n\tbool \tpublic isLimitReached;                          // Tell if the first stage of the CrowdFunding is reached, false when not set\r\n\t\r\n\taddress[] public backerList;\t\t\t\t\t\t\t// Addresses of all backers\r\n\taddress[] public altList;\t\t\t\t\t     \t\t// List of alternative contracts for sponsoring (useless for this contract)\r\n\tmapping(address => Sponsor) public sponsorList;\t        // The sponsor linked to an alternative contract\r\n\tmapping(address => Backer) public backers;            \t// The Backer for a given address\r\n\r\n\tmodifier onlyBy(address a){\r\n\t\tif (msg.sender != a) throw;                         // Auth modifier, if the msg.sender isn't the expected address, throw.\r\n\t\t_\r\n\t}\r\n\t\r\n\tevent Gave(address);\t\t\t\t\t\t\t\t\t// \r\n\t\r\n//--------------------------------------\\\\\r\n\t\r\n\tfunction Crowdfunding() {\r\n\t\t\r\n\t\t// Constructor of the contract. set the different variables\r\n\t\t\r\n\t\tnexium = Token(0x45e42d659d9f9466cd5df622506033145a9b89bc); \t// Nexium contract address\r\n\t\tbeyond = 0x89E7a245d5267ECd5Bf4cA4C1d9D4D5A14bbd130 ;\r\n\t\towner = msg.sender;\r\n\t\tminInvest = 10 finney;\r\n\t\tstartingEtherValue = 700*1000;\r\n\t\tstepEtherValue = 25*1000;\r\n\t\tnxcPerBcy = 14;\r\n\t\tperStageNxc = 5000000 * 1000;\r\n\t\tstartDate = 1478012400 ;\r\n\t\tendDate = 1480604400 ;\r\n\t\tbitCrystalEscrow = 0x72037bf2a3fc312cde40c7f7cd7d2cef3ad8c193;\r\n\t} \r\n\r\n//--------------------------------------\\\\\r\n\t\r\n\t// Use this function to buy Nexiums for someone (can be you of course)\r\n\tfunction giveFor(address beneficiary){\r\n\t\tif (msg.value < minInvest) throw;                                      // Throw when the minimum to invest isn't reached\r\n\t\tif (endDate < now || (now < startDate && now > startDate - 3 hours )) throw;        // Check if the crowdfunding is started and not already over\r\n\t\t\r\n\t\t// Computing the current amount of Nxc we send per ether. \r\n\t\tuint currentEtherValue = getCurrEthValue();\r\n\t\t\r\n\t\t//it's possible to invest before the begining of the crowdfunding but the price is x10.\r\n\t\t//Allow backers to test the contract before the begining.\r\n\t\tif(now < startDate) currentEtherValue /= 10;\r\n\t\t\r\n\t\t// Computing the number of milli Nxc we will send to the beneficiary\r\n\t\tuint givenNxc = (msg.value * currentEtherValue)/(1 ether);\r\n\t\tnxcSold += givenNxc;                                                   //Updating the sold Nxc amount\r\n\t\tif (nxcSold >= perStageNxc) isLimitReached = true ; \r\n\t\t\r\n\t\tSponsor sp = sponsorList[msg.sender];\r\n\t\t\r\n\t\t//Check if the user gives through a sponsor contract\r\n\t\tif (sp.sponsorAddress != 0x0000000000000000000000000000000000000000) {\r\n\t\t    sp.nxcDirected += givenNxc;                                        // Update the number of milli Nxc this sponsor sold for us\r\n\t\t    \r\n\t\t    // This part compute the bonus rate NxC the sponsor will have depending on the total of Nxc he sold.\r\n\t\t    uint bonusRate = sp.nxcDirected / 80000000;\r\n\t\t    if (bonusRate > sp.sponsorBonus) bonusRate = sp.sponsorBonus;\r\n\t\t    \r\n\t\t    // Giving to the sponsor the amount of Nxc he earned by this last donation\r\n\t\t    uint sponsorNxc = (sp.nxcDirected * bonusRate)/100 - sp.earnedNexium;\r\n\t\t\tif (!giveNxc(sp.sponsorAddress, sponsorNxc))throw;\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tsp.earnedNexium += sponsorNxc;                                     // Update the number of milli Nxc this sponsor earned\r\n\t\t\tgivenNxc = (givenNxc*(100 + sp.backerBonus))/100;                  // Increase by x% the number of Nxc we will give to the backer\r\n\t\t}\r\n\t\t\r\n\t\tif (!giveNxc(beneficiary, givenNxc))throw;                             // Give to the Backer the Nxc he just earned\r\n\t\t\r\n\t\t// Add the new Backer to the list, if he gave for the first time\r\n\t\tBacker backer = backers[beneficiary];\r\n\t\tif (backer.weiGiven == 0){\r\n\t\t\tbackerList[backerList.length++] = beneficiary;\r\n\t\t}\r\n\t\tbacker.weiGiven += msg.value;                                          // Update the gave wei of this Backer\r\n\t\tcollectedEth += msg.value;                                             // Update the total wei collcted during the crowdfunding     \r\n\t\tGave(beneficiary);                                                     // Trigger an event \r\n\t}\r\n\t\r\n\t\r\n\t// If you gave ether before the first stage is reached you might have some ungiven\r\n\t// Nxc for your address. This function, if called, will give you the nexiums you didn't\r\n\t// received. /!\\ Nexium bonuses for your partner rank will not be given during the crowdfunding\r\n\tfunction claimNxc(){\r\n\t    if (!isLimitReached) throw;\r\n\t    address to = msg.sender;\r\n\t    nexium.transfer(to, backers[to].ungivenNxc);\r\n\t    backers[to].ungivenNxc = 0;\r\n\t}\r\n\t\r\n\t// This function can be called after the crowdfunding if the first goal is not reached\r\n\t// It gives back the ethers of the specified address\r\n\tfunction getBackEther(){\r\n\t    getBackEtherFor(msg.sender);\r\n\t}\r\n\t\r\n\tfunction getBackEtherFor(address account){\r\n\t    if (now > endDate && !isLimitReached){\r\n\t        uint sentBack = backers[account].weiGiven;\r\n\t        backers[account].weiGiven = 0;                                     // No DAO style re entrance ;)\r\n\t        if(!account.send(sentBack))throw;\r\n\t    } else throw ;\r\n\t}\r\n\t\r\n\t// The anonymous function automatically make a donation for the person who gave ethers\r\n\tfunction(){\r\n\t\tgiveFor(msg.sender);\r\n\t}\r\n\t\r\n//--------------------------------------\\\\\r\n\r\n    //Create a new sponsoring contract \r\n\tfunction addAlt(address sponsor, uint _sponsorBonus, uint _backerBonus)\r\n\tonlyBy(owner){\r\n\t    if (_sponsorBonus > 10 || _backerBonus > 10 || _sponsorBonus + _backerBonus > 15) throw;\r\n\t\taltList[altList.length++] = address(new AltCrowdfunding(this));\r\n\t\tsponsorList[altList[altList.length -1]] = Sponsor(0, 0, sponsor, _sponsorBonus, _backerBonus);\r\n\t}\r\n\t\r\n\t// Set the value of BCY gave by the SOG network. Only our BCY escrow can modify it.\r\n    function setBCY(uint newValue)\r\n    onlyBy(bitCrystalEscrow){\r\n        if (now < startDate || now > endDate) throw;\r\n        if (newValue != 0 && newValue < 714285714) collectedBcy = newValue; // 714285714 * 14 ~= 10 000 000 000 mili Nxc maximum to avoid wrong value\r\n        else throw;\r\n    }\r\n    \r\n    // If the minimum goal is reached, beyond the void can have the ethers stored on the contract\r\n    function withdrawEther(address to, uint amount)\r\n    onlyBy(owner){\r\n        if (!isLimitReached) throw;\r\n        var r = to.send(amount);\r\n    }\r\n    \r\n    function withdrawNxc(address to, uint amount)\r\n    onlyBy(owner){\r\n        nexium.transfer(to, amount);\r\n    }\r\n    \r\n    //If there are still Nexiums or Ethers on the contract after 100 days after the end of the crowdfunding\r\n    //This function send all of it to the multi sig of the beyond the void team (emergency case)\r\n    function blackBox(){\r\n        if (now < endDate + 100 days)throw;\r\n        nexium.transfer(beyond, nexium.balanceOf(this));\r\n        var r = beyond.send(this.balance);\r\n    }\r\n\t\r\n\t// Each time this contract send Nxc this function is called. It check if\r\n\t// the minimum goal is reached before sending any nexiums out.\r\n\tfunction giveNxc(address to, uint amount) internal returns (bool){\r\n\t    bool res;\r\n\t    if (isLimitReached){\r\n\t        if (nexium.transfer(to, amount)){\r\n\t            // If there is some ungiven Nxc remaining for this address, send it.\r\n\t            if (backers[to].ungivenNxc != 0){\r\n\t                 res = nexium.transfer(to, backers[to].ungivenNxc); \r\n\t                 backers[to].ungivenNxc = 0;\r\n\t            } else {\r\n\t                res = true;\r\n\t            }\r\n\t        } else {\r\n\t            res = false;\r\n\t        }\r\n\t\t// If the limit is not reached yet, the nexiums are not sent but stored in the contract waiting this goal being reached.\r\n\t\t// They are released when the same backer gives ether while the limit is reached, or by claiming them after the minimal goal is reached .\r\n\t    } else {\r\n\t        backers[to].ungivenNxc += amount;\r\n\t        res = true;\r\n\t    }\r\n\t    return res;\r\n\t}\r\n\t\r\n\t//--------------------------------------\\\\\r\n\t\r\n\tfunction getCurrEthValue() returns(uint){\r\n\t    return  startingEtherValue - stepEtherValue * ((nxcSold + collectedBcy * nxcPerBcy)/perStageNxc);\r\n\t}\r\n\t\r\n}", 
  "balance": "10,394<b>.</b>908827299828001824 Ether", 
  "name": "Crowdfunding", 
  "transactions": "4394", 
  "address": "0x20d42f2e99a421147acf198d775395cac2e8b03d"
 }, 
 {
  "source": "// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        address oraclizeAddr = OAR.getAddress();\r\n        if (oraclizeAddr == 0){\r\n            oraclize_setNetwork(networkID_auto);\r\n            oraclizeAddr = OAR.getAddress();\r\n        }\r\n        oraclize = OraclizeI(oraclizeAddr);\r\n        _\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   }\r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\r\n    uint public edge = 200; //edge percentage (10000 = 100%)\r\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint public minBet = 1 finney;\r\n    uint public maxInvestors = 5; //maximum number of investors\r\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\r\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 25000;\r\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 7 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBetted;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address owner;\r\n    address houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) bets;\r\n    bytes32[] betsKeys;\r\n\r\n    uint public amountWagered = 0;\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLoses = 0;\r\n    bool profitDistributed;\r\n\r\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event BetLost(address playerAddress, uint numberRolled);\r\n    event EmergencyWithdrawalProposed();\r\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event FailedSend(address receiver, uint amount);\r\n    event ValueIsTooBig();\r\n\r\n    function Dice(uint pwinInitial,\r\n                  uint edgeInitial,\r\n                  uint maxWinInitial,\r\n                  uint minBetInitial,\r\n                  uint maxInvestorsInitial,\r\n                  uint houseEdgeInitial,\r\n                  uint divestFeeInitial,\r\n                  uint emergencyWithdrawalRatioInitial\r\n                  ) {\r\n\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n\r\n        pwin = pwinInitial;\r\n        edge = edgeInitial;\r\n        maxWin = maxWinInitial;\r\n        minBet = minBetInitial;\r\n        maxInvestors = maxInvestorsInitial;\r\n        houseEdge = houseEdgeInitial;\r\n        divestFee = divestFeeInitial;\r\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        Bet thisBet = bets[myid];\r\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\r\n             _\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        Bet thisBet = bets[myid];\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\r\n            return;\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\r\n        if (getBalance(currentInvestor) >= 0) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier rejectValue {\r\n        if (msg.value != 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (newGasLimit < 25000) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        Bet thisBet = bets[myid];\r\n        if (thisBet.numberRolled > 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _\r\n    }\r\n\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll() constant returns(uint) {\r\n        return invested + investorsProfit - investorsLoses;\r\n    }\r\n\r\n    function getMinInvestment() constant returns(uint) {\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n\r\n        uint minInvestment = getMinInvestment();\r\n\r\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id) constant returns(address, uint, uint) {\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets() constant returns(uint) {\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount() constant returns(uint) {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount() constant returns(uint) {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLosesShare(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\r\n    }\r\n\r\n    function searchSmallestInvestor() constant returns(uint) {\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value) private {\r\n        if (this.balance < value) {\r\n            ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addInvestorAtID(uint id) private {\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function profitDistribution() private onlyIfProfitNotDistributed {\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint losesOfInvestor = getLosesShare(currentInvestor);\r\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\r\n            copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLoses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function() {\r\n        bet();\r\n    }\r\n\r\n    function bet() onlyIfNotStopped onlyMoreThanZero {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}'\r\n            bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\",\"BAMe+COA7GTmPrm1MtEyeRfPpOjXWs99NXtPmkY1LL7BEyA5Ir/oIYHZ5v8cfJ7gzkBJY7sMBqyUKcPIcORQ8CPC4x11Nmlys12n8zMopJBROF+19EDhLEaJR4pMwFvhlW/mkhFHb1hxB3ZR/toj//x+l6fi+h0eXWxx2qqKulId4KY+VcsYIJb/seH+7qEWmu78HQ6LXSdkRAa0lG6tkNFpB0feuh2VztWxd3CC/j1MIT1l0laucp2zFD2FfJngwpix99iYcNq9mvHhDxYpR9eGSRMZ9BnLgsvIW/QB3Zk=\", ORACLIZE_GAS_LIMIT + safeGas);\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback (bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        Bet thisBet = bets[myid];\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(thisBet, numberRolled);\r\n        isLosingBet(thisBet, numberRolled);\r\n        amountWagered += thisBet.amountBetted;\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\r\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\r\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n        investorsLoses += (winAmount - thisBet.amountBetted);\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\r\n        BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest() onlyInvestors rejectValue {\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n        invested -= investors[currentID].amountInvested;\r\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n        amountToReturn -= divestFeeAmount;\r\n\r\n        delete investors[currentID];\r\n        delete investorIDs[currentInvestor];\r\n        //Reorder investors\r\n\r\n        if (currentID != numInvestors) {\r\n            // Get last investor\r\n            Investor lastInvestor = investors[numInvestors];\r\n            //Set last investor ID to investorID of divesting account\r\n            investorIDs[lastInvestor.investorAddress] = currentID;\r\n            //Copy investor at the new position in the mapping\r\n            investors[currentID] = lastInvestor;\r\n            //Delete old position in the mappping\r\n            delete investors[numInvestors];\r\n        }\r\n\r\n        numInvestors--;\r\n        safeSend(currentInvestor, amountToReturn);\r\n        safeSend(houseAddress, divestFeeAmount);\r\n    }\r\n\r\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped\r\n        rejectValue {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract() onlyOwner rejectValue {\r\n        isStopped = true;\r\n    }\r\n\r\n    function resumeContract() onlyOwner rejectValue {\r\n        isStopped = false;\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\r\n        houseAddress = newHouse;\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit)\r\n        rejectValue {\r\n        safeGas = newGasLimit;\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        rejectValue {\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner\r\n        rejectValue {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed\r\n        rejectValue {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdrawal = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\r\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "4121", 
  "address": "0x2ab9f67a27f606272189b307052694d3a2b158ba"
 }, 
 {
  "source": "pragma solidity ^0.4.2;\r\n\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Constant {\r\n    function totalSupply() constant returns (uint supply);\r\n    function balanceOf( address who ) constant returns (uint value);\r\n    function allowance(address owner, address spender) constant returns (uint _allowance);\r\n}\r\ncontract ERC20Stateful {\r\n    function transfer( address to, uint value) returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n}\r\ncontract ERC20Events {\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}\r\n\r\ncontract Assertive {\r\n    function assert(bool assertion) internal {\r\n        if (!assertion) throw;\r\n    }\r\n}\r\n\r\ncontract FallbackFailer {\r\n  function () {\r\n    throw;\r\n  }\r\n}\r\n\r\ncontract MutexUser {\r\n    bool private lock;\r\n    modifier exclusive {\r\n        if (lock) throw;\r\n        lock = true;\r\n        _;\r\n        lock = false;\r\n    }\r\n}\r\n\r\n// A simple direct exchange order manager.\r\n\r\ncontract EventfulMarket {\r\n    event ItemUpdate( uint id );\r\n    event Trade( uint sell_how_much, address indexed sell_which_token,\r\n                 uint buy_how_much, address indexed buy_which_token );\r\n}\r\n\r\ncontract SimpleMarket is EventfulMarket\r\n                       , Assertive\r\n                       , FallbackFailer\r\n                       , MutexUser\r\n{\r\n    struct OfferInfo {\r\n        uint sell_how_much;\r\n        ERC20 sell_which_token;\r\n        uint buy_how_much;\r\n        ERC20 buy_which_token;\r\n        address owner;\r\n        bool active;\r\n    }\r\n    mapping( uint => OfferInfo ) public offers;\r\n\r\n    uint public last_offer_id;\r\n\r\n    function next_id() internal returns (uint) {\r\n        last_offer_id++; return last_offer_id;\r\n    }\r\n\r\n    modifier can_offer {\r\n        _;\r\n    }\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        _;\r\n    }\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(getOwner(id) == msg.sender);\r\n        _;\r\n    }\r\n    function isActive(uint id) constant returns (bool active) {\r\n        return offers[id].active;\r\n    }\r\n    function getOwner(uint id) constant returns (address owner) {\r\n        return offers[id].owner;\r\n    }\r\n    function getOffer( uint id ) constant returns (uint, ERC20, uint, ERC20) {\r\n      var offer = offers[id];\r\n      return (offer.sell_how_much, offer.sell_which_token,\r\n              offer.buy_how_much, offer.buy_which_token);\r\n    }\r\n\r\n    // non underflowing subtraction\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    // non overflowing multiplication\r\n    function safeMul(uint a, uint b) internal returns (uint c) {\r\n        c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n    }\r\n\r\n    function trade( address seller, uint sell_how_much, ERC20 sell_which_token,\r\n                    address buyer,  uint buy_how_much,  ERC20 buy_which_token )\r\n        internal\r\n    {\r\n        var seller_paid_out = buy_which_token.transferFrom( buyer, seller, buy_how_much );\r\n        assert(seller_paid_out);\r\n        var buyer_paid_out = sell_which_token.transfer( buyer, sell_how_much );\r\n        assert(buyer_paid_out);\r\n        Trade( sell_how_much, sell_which_token, buy_how_much, buy_which_token );\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer( uint sell_how_much, ERC20 sell_which_token\r\n                  , uint buy_how_much,  ERC20 buy_which_token )\r\n        can_offer\r\n        exclusive\r\n        returns (uint id)\r\n    {\r\n        assert(sell_how_much > 0);\r\n        assert(sell_which_token != ERC20(0x0));\r\n        assert(buy_how_much > 0);\r\n        assert(buy_which_token != ERC20(0x0));\r\n        assert(sell_which_token != buy_which_token);\r\n\r\n        OfferInfo memory info;\r\n        info.sell_how_much = sell_how_much;\r\n        info.sell_which_token = sell_which_token;\r\n        info.buy_how_much = buy_how_much;\r\n        info.buy_which_token = buy_which_token;\r\n        info.owner = msg.sender;\r\n        info.active = true;\r\n        id = next_id();\r\n        offers[id] = info;\r\n\r\n        var seller_paid = sell_which_token.transferFrom( msg.sender, this, sell_how_much );\r\n        assert(seller_paid);\r\n\r\n        ItemUpdate(id);\r\n    }\r\n    // Accept given `quantity` of an offer. Transfers funds from caller to\r\n    // offer maker, and from market to caller.\r\n    function buy( uint id, uint quantity )\r\n        can_buy(id)\r\n        exclusive\r\n        returns ( bool success )\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n\r\n        // inferred quantity that the buyer wishes to spend\r\n        uint spend = safeMul(quantity, offer.buy_how_much) / offer.sell_how_much;\r\n\r\n        if ( spend > offer.buy_how_much || quantity > offer.sell_how_much ) {\r\n            // buyer wants more than is available\r\n            success = false;\r\n        } else if ( spend == offer.buy_how_much && quantity == offer.sell_how_much ) {\r\n            // buyer wants exactly what is available\r\n            delete offers[id];\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                   msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            success = true;\r\n        } else if ( spend > 0 && quantity > 0 ) {\r\n            // buyer wants a fraction of what is available\r\n            offers[id].sell_how_much = safeSub(offer.sell_how_much, quantity);\r\n            offers[id].buy_how_much = safeSub(offer.buy_how_much, spend);\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                    msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            success = true;\r\n        } else {\r\n            // buyer wants an unsatisfiable amount (less than 1 integer)\r\n            success = false;\r\n        }\r\n    }\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel( uint id )\r\n        can_cancel(id)\r\n        exclusive\r\n        returns ( bool success )\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n        delete offers[id];\r\n\r\n        var seller_refunded = offer.sell_which_token.transfer( offer.owner , offer.sell_how_much );\r\n        assert(seller_refunded);\r\n\r\n        ItemUpdate(id);\r\n        success = true;\r\n    }\r\n}\r\n\r\n// Simple Market with a market lifetime. When the lifetime has elapsed,\r\n// offers can only be cancelled (offer and buy will throw).\r\n\r\ncontract ExpiringMarket is SimpleMarket {\r\n    uint public close_time;\r\n    function ExpiringMarket(uint lifetime) {\r\n        close_time = getTime() + lifetime;\r\n    }\r\n    function getTime() constant returns (uint) {\r\n        return block.timestamp;\r\n    }\r\n    function isClosed() constant returns (bool closed) {\r\n        return (getTime() > close_time);\r\n    }\r\n\r\n    // after market lifetime has elapsed, no new offers are allowed\r\n    modifier can_offer {\r\n        assert(!isClosed());\r\n        _;\r\n    }\r\n    // after close, no new buys are allowed\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        assert(!isClosed());\r\n        _;\r\n    }\r\n    // after close, anyone can cancel an offer\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(isClosed() || (msg.sender == getOwner(id)));\r\n        _;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ExpiringMarket", 
  "transactions": "3767", 
  "address": "0xa1b5eedc73a978d181d1ea322ba20f0474bb2a25"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "0 Ether", 
  "name": "Wallet", 
  "transactions": "3720", 
  "address": "0x6a3625143c7508742ed58697dd5ab9fcfcc78df8"
 }, 
 {
  "source": "// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        address oraclizeAddr = OAR.getAddress();\r\n        if (oraclizeAddr == 0){\r\n            oraclize_setNetwork(networkID_auto);\r\n            oraclizeAddr = OAR.getAddress();\r\n        }\r\n        oraclize = OraclizeI(oraclizeAddr);\r\n        _\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   }\r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\r\n    uint public edge = 200; //edge percentage (10000 = 100%)\r\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint public minBet = 1 finney;\r\n    uint public maxInvestors = 5; //maximum number of investors\r\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\r\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 25000;\r\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 7 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBetted;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address owner;\r\n    address houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) bets;\r\n    bytes32[] betsKeys;\r\n\r\n    uint public amountWagered = 0;\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLoses = 0;\r\n    bool profitDistributed;\r\n\r\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event BetLost(address playerAddress, uint numberRolled);\r\n    event EmergencyWithdrawalProposed();\r\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event FailedSend(address receiver, uint amount);\r\n    event ValueIsTooBig();\r\n\r\n    function Dice(uint pwinInitial,\r\n                  uint edgeInitial,\r\n                  uint maxWinInitial,\r\n                  uint minBetInitial,\r\n                  uint maxInvestorsInitial,\r\n                  uint houseEdgeInitial,\r\n                  uint divestFeeInitial,\r\n                  uint emergencyWithdrawalRatioInitial\r\n                  ) {\r\n\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n\r\n        pwin = pwinInitial;\r\n        edge = edgeInitial;\r\n        maxWin = maxWinInitial;\r\n        minBet = minBetInitial;\r\n        maxInvestors = maxInvestorsInitial;\r\n        houseEdge = houseEdgeInitial;\r\n        divestFee = divestFeeInitial;\r\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        Bet thisBet = bets[myid];\r\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\r\n             _\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        Bet thisBet = bets[myid];\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\r\n            return;\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\r\n        if (getBalance(currentInvestor) >= 0) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier rejectValue {\r\n        if (msg.value != 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (newGasLimit < 25000) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        Bet thisBet = bets[myid];\r\n        if (thisBet.numberRolled > 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _\r\n    }\r\n\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll() constant returns(uint) {\r\n        return invested + investorsProfit - investorsLoses;\r\n    }\r\n\r\n    function getMinInvestment() constant returns(uint) {\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n\r\n        uint minInvestment = getMinInvestment();\r\n\r\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id) constant returns(address, uint, uint) {\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets() constant returns(uint) {\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount() constant returns(uint) {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount() constant returns(uint) {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLosesShare(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\r\n    }\r\n\r\n    function searchSmallestInvestor() constant returns(uint) {\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value) private {\r\n        if (this.balance < value) {\r\n            ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addInvestorAtID(uint id) private {\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function profitDistribution() private onlyIfProfitNotDistributed {\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint losesOfInvestor = getLosesShare(currentInvestor);\r\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\r\n            copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLoses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function() {\r\n        bet();\r\n    }\r\n\r\n    function bet() onlyIfNotStopped onlyMoreThanZero {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}'\r\n            bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\",\"BEcosMZz8Ae1B5UK80b8W1Lz0TQJiaaOFzYqDf00FtJ3Nqy6C4JgY4KlavaMh+QDQRHJrBDHBznTT+GClNKbeSAv8THZDdyIR58a4GME53+OI1VNoV0SzpKwdVWkVrQnrHr8VyzMFd8XrqicVlN5fcC+39WqzEKaSguPaWotB5XSfgTaj1t/0b6P+V3ma+AIXVbacP7MOeFq/dA4Y80KhYZalvdnau9KUX4YJX9oAw5fSExp++1MhEzmda0RMpU5MPm2OrbdJOnOVD3C3DYxWFXGZXImYBRCzp8f7Fhc6+U=\", ORACLIZE_GAS_LIMIT + safeGas);\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback (bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        Bet thisBet = bets[myid];\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(thisBet, numberRolled);\r\n        isLosingBet(thisBet, numberRolled);\r\n        amountWagered += thisBet.amountBetted;\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\r\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\r\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n        investorsLoses += (winAmount - thisBet.amountBetted);\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\r\n        BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest() onlyInvestors rejectValue {\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n        invested -= investors[currentID].amountInvested;\r\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n        amountToReturn -= divestFeeAmount;\r\n\r\n        delete investors[currentID];\r\n        delete investorIDs[currentInvestor];\r\n        //Reorder investors\r\n\r\n        if (currentID != numInvestors) {\r\n            // Get last investor\r\n            Investor lastInvestor = investors[numInvestors];\r\n            //Set last investor ID to investorID of divesting account\r\n            investorIDs[lastInvestor.investorAddress] = currentID;\r\n            //Copy investor at the new position in the mapping\r\n            investors[currentID] = lastInvestor;\r\n            //Delete old position in the mappping\r\n            delete investors[numInvestors];\r\n        }\r\n\r\n        numInvestors--;\r\n        safeSend(currentInvestor, amountToReturn);\r\n        safeSend(houseAddress, divestFeeAmount);\r\n    }\r\n\r\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped\r\n        rejectValue {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract() onlyOwner rejectValue {\r\n        isStopped = true;\r\n    }\r\n\r\n    function resumeContract() onlyOwner rejectValue {\r\n        isStopped = false;\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\r\n        houseAddress = newHouse;\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit)\r\n        rejectValue {\r\n        safeGas = newGasLimit;\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        rejectValue {\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner\r\n        rejectValue {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed\r\n        rejectValue {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdrawal = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\r\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "3649", 
  "address": "0x75a931567048edd4f349fa1a1cfbc4b4dca352c9"
 }, 
 {
  "source": "// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        address oraclizeAddr = OAR.getAddress();\r\n        if (oraclizeAddr == 0){\r\n            oraclize_setNetwork(networkID_auto);\r\n            oraclizeAddr = OAR.getAddress();\r\n        }\r\n        oraclize = OraclizeI(oraclizeAddr);\r\n        _\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   }\r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\r\n    uint public edge = 200; //edge percentage (10000 = 100%)\r\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint public minBet = 1 finney;\r\n    uint public maxInvestors = 5; //maximum number of investors\r\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\r\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 25000;\r\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 7 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBetted;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address owner;\r\n    address houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) bets;\r\n    bytes32[] betsKeys;\r\n\r\n    uint public amountWagered = 0;\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLoses = 0;\r\n    bool profitDistributed;\r\n\r\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event BetLost(address playerAddress, uint numberRolled);\r\n    event EmergencyWithdrawalProposed();\r\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event FailedSend(address receiver, uint amount);\r\n    event ValueIsTooBig();\r\n\r\n    function Dice(uint pwinInitial,\r\n                  uint edgeInitial,\r\n                  uint maxWinInitial,\r\n                  uint minBetInitial,\r\n                  uint maxInvestorsInitial,\r\n                  uint houseEdgeInitial,\r\n                  uint divestFeeInitial,\r\n                  uint emergencyWithdrawalRatioInitial\r\n                  ) {\r\n\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n\r\n        pwin = pwinInitial;\r\n        edge = edgeInitial;\r\n        maxWin = maxWinInitial;\r\n        minBet = minBetInitial;\r\n        maxInvestors = maxInvestorsInitial;\r\n        houseEdge = houseEdgeInitial;\r\n        divestFee = divestFeeInitial;\r\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        Bet thisBet = bets[myid];\r\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\r\n             _\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        Bet thisBet = bets[myid];\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\r\n            return;\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\r\n        if (getBalance(currentInvestor) >= 0) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier rejectValue {\r\n        if (msg.value != 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (newGasLimit < 25000) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        Bet thisBet = bets[myid];\r\n        if (thisBet.numberRolled > 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _\r\n    }\r\n\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll() constant returns(uint) {\r\n        return invested + investorsProfit - investorsLoses;\r\n    }\r\n\r\n    function getMinInvestment() constant returns(uint) {\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n\r\n        uint minInvestment = getMinInvestment();\r\n\r\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id) constant returns(address, uint, uint) {\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets() constant returns(uint) {\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount() constant returns(uint) {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount() constant returns(uint) {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLosesShare(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\r\n    }\r\n\r\n    function searchSmallestInvestor() constant returns(uint) {\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value) private {\r\n        if (this.balance < value) {\r\n            ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addInvestorAtID(uint id) private {\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function profitDistribution() private onlyIfProfitNotDistributed {\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint losesOfInvestor = getLosesShare(currentInvestor);\r\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\r\n            copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLoses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function() {\r\n        bet();\r\n    }\r\n\r\n    function bet() onlyIfNotStopped onlyMoreThanZero {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}'\r\n            bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\",\"BMqCkR6ERfTgjv9BtaRd2S2NWirIAz7TB6ALz0XbvdVWCgTtEPbrjZLdT35E/8dE1+e5+/gBjWoIqKWNideh2+YbwbcGrpBL5YqcGEKc01w1UjgKFcGtzDPcKaSBpnfm2flusxOpZ0p5EldkN3ljODfLdkk9PnHfHCObTrxWYCKUq54Zx7VOLbcZMTJDF8MQxhBeTamalSWUS9R7t2vNYmem8Wjp9TFKrMk7skOr31HS0rPC5T7/iiekUXIvPgukMf9ufONnUddphAGI3mMN6yH6UqE9REMn8U91/jcjIbw=\", ORACLIZE_GAS_LIMIT + safeGas);\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback (bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        Bet thisBet = bets[myid];\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(thisBet, numberRolled);\r\n        isLosingBet(thisBet, numberRolled);\r\n        amountWagered += thisBet.amountBetted;\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\r\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\r\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n        investorsLoses += (winAmount - thisBet.amountBetted);\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\r\n        BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest() onlyInvestors rejectValue {\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n        invested -= investors[currentID].amountInvested;\r\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n        amountToReturn -= divestFeeAmount;\r\n\r\n        delete investors[currentID];\r\n        delete investorIDs[currentInvestor];\r\n        //Reorder investors\r\n\r\n        if (currentID != numInvestors) {\r\n            // Get last investor\r\n            Investor lastInvestor = investors[numInvestors];\r\n            //Set last investor ID to investorID of divesting account\r\n            investorIDs[lastInvestor.investorAddress] = currentID;\r\n            //Copy investor at the new position in the mapping\r\n            investors[currentID] = lastInvestor;\r\n            //Delete old position in the mappping\r\n            delete investors[numInvestors];\r\n        }\r\n\r\n        numInvestors--;\r\n        safeSend(currentInvestor, amountToReturn);\r\n        safeSend(houseAddress, divestFeeAmount);\r\n    }\r\n\r\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped\r\n        rejectValue {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract() onlyOwner rejectValue {\r\n        isStopped = true;\r\n    }\r\n\r\n    function resumeContract() onlyOwner rejectValue {\r\n        isStopped = false;\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\r\n        houseAddress = newHouse;\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit)\r\n        rejectValue {\r\n        safeGas = newGasLimit;\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        rejectValue {\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner\r\n        rejectValue {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed\r\n        rejectValue {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdrawal = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\r\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "3595", 
  "address": "0xb95dd00b76c15b11ae82e875e9719029cd4d2110"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "199,212<b>.</b>781964919760154727 Ether", 
  "name": "Wallet", 
  "transactions": "3545", 
  "address": "0x154af3e01ec56bc55fd585622e33e3dfb8a248d8"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function __callback(bytes32 myid, string result) {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32 myid, string result, bytes proof) {\r\n    }\r\n    \r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 5000; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 90; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BGFVFgEmxZTIpg1u+Oaakn9M02RNztU4zgU23g78Jw9jUDjV6nFv5lVOPgn8wQ4a3WD1M0GvC1WWvWfJisUkzOlmSnPZOXTJsxsUKz80DfQZlPmHZ6SE5Nw4TKvwFPfRKKVnr3lk4bAwu/iiU3IBqXZdRfd3R9U=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "811<b>.</b>808605440047198931 Ether", 
  "name": "Dice", 
  "transactions": "3463", 
  "address": "0xdd98b423dc61a756e1070de151b1485425505954"
 }, 
 {
  "source": "// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        address oraclizeAddr = OAR.getAddress();\r\n        if (oraclizeAddr == 0){\r\n            oraclize_setNetwork(networkID_auto);\r\n            oraclizeAddr = OAR.getAddress();\r\n        }\r\n        oraclize = OraclizeI(oraclizeAddr);\r\n        _\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   }\r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\r\n    uint public edge = 200; //edge percentage (10000 = 100%)\r\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint public minBet = 1 finney;\r\n    uint public maxInvestors = 5; //maximum number of investors\r\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\r\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 25000;\r\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 7 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBetted;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address owner;\r\n    address houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) bets;\r\n    bytes32[] betsKeys;\r\n\r\n    uint public amountWagered = 0;\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLoses = 0;\r\n    bool profitDistributed;\r\n\r\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event BetLost(address playerAddress, uint numberRolled);\r\n    event EmergencyWithdrawalProposed();\r\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event FailedSend(address receiver, uint amount);\r\n    event ValueIsTooBig();\r\n\r\n    function Dice(uint pwinInitial,\r\n                  uint edgeInitial,\r\n                  uint maxWinInitial,\r\n                  uint minBetInitial,\r\n                  uint maxInvestorsInitial,\r\n                  uint houseEdgeInitial,\r\n                  uint divestFeeInitial,\r\n                  uint emergencyWithdrawalRatioInitial\r\n                  ) {\r\n\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n\r\n        pwin = pwinInitial;\r\n        edge = edgeInitial;\r\n        maxWin = maxWinInitial;\r\n        minBet = minBetInitial;\r\n        maxInvestors = maxInvestorsInitial;\r\n        houseEdge = houseEdgeInitial;\r\n        divestFee = divestFeeInitial;\r\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        Bet thisBet = bets[myid];\r\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\r\n             _\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        Bet thisBet = bets[myid];\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\r\n            return;\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\r\n        if (getBalance(currentInvestor) >= 0) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier rejectValue {\r\n        if (msg.value != 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (newGasLimit < 25000) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        Bet thisBet = bets[myid];\r\n        if (thisBet.numberRolled > 0) throw;\r\n        _\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _\r\n    }\r\n\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll() constant returns(uint) {\r\n        return invested + investorsProfit - investorsLoses;\r\n    }\r\n\r\n    function getMinInvestment() constant returns(uint) {\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n\r\n        uint minInvestment = getMinInvestment();\r\n\r\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id) constant returns(address, uint, uint) {\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets() constant returns(uint) {\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount() constant returns(uint) {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount() constant returns(uint) {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLosesShare(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor) constant returns (uint) {\r\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\r\n    }\r\n\r\n    function searchSmallestInvestor() constant returns(uint) {\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value) private {\r\n        if (this.balance < value) {\r\n            ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addInvestorAtID(uint id) private {\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function profitDistribution() private onlyIfProfitNotDistributed {\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint losesOfInvestor = getLosesShare(currentInvestor);\r\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\r\n            copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLoses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function() {\r\n        bet();\r\n    }\r\n\r\n    function bet() onlyIfNotStopped onlyMoreThanZero {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}'\r\n            bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\",\"BBX1PCQ9134839wTz10OWxXCaZaGk92yF6TES8xA+8IC7xNBlJq5AL0uW3rev7IoApA5DMFmCfKGikjnNbNglKKvwjENYPB8TBJN9tDgdcYNxdWnsYARKMqmjrJKYbBAiws+UU6HrJXUWirO+dBSSJbmjIg+9vmBjSq8KveiBzSGmuQhu7/hSg5rSsSP/r+MhR/Q5ECrOHi+CkP/qdSUTA/QhCCjdzFu+7t3Hs7NU34a+l7JdvDlvD8hoNxyKooMDYNbUA8/eFmPv2d538FN6KJQp+RKr4w4VtAMHdejrLM=\", ORACLIZE_GAS_LIMIT + safeGas);\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback (bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        Bet thisBet = bets[myid];\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(thisBet, numberRolled);\r\n        isLosingBet(thisBet, numberRolled);\r\n        amountWagered += thisBet.amountBetted;\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\r\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\r\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n        investorsLoses += (winAmount - thisBet.amountBetted);\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\r\n        BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest() onlyInvestors rejectValue {\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n        invested -= investors[currentID].amountInvested;\r\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n        amountToReturn -= divestFeeAmount;\r\n\r\n        delete investors[currentID];\r\n        delete investorIDs[currentInvestor];\r\n        //Reorder investors\r\n\r\n        if (currentID != numInvestors) {\r\n            // Get last investor\r\n            Investor lastInvestor = investors[numInvestors];\r\n            //Set last investor ID to investorID of divesting account\r\n            investorIDs[lastInvestor.investorAddress] = currentID;\r\n            //Copy investor at the new position in the mapping\r\n            investors[currentID] = lastInvestor;\r\n            //Delete old position in the mappping\r\n            delete investors[numInvestors];\r\n        }\r\n\r\n        numInvestors--;\r\n        safeSend(currentInvestor, amountToReturn);\r\n        safeSend(houseAddress, divestFeeAmount);\r\n    }\r\n\r\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped\r\n        rejectValue {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract() onlyOwner rejectValue {\r\n        isStopped = true;\r\n    }\r\n\r\n    function resumeContract() onlyOwner rejectValue {\r\n        isStopped = false;\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\r\n        houseAddress = newHouse;\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit)\r\n        rejectValue {\r\n        safeGas = newGasLimit;\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        rejectValue {\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner\r\n        rejectValue {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed\r\n        rejectValue {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdrawal = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\r\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "3441", 
  "address": "0x4b92a948ced9d457b4655abf62ed930a090f8566"
 }, 
 {
  "source": "/// @title DigixDAO Contract Interfaces\r\n\r\ncontract ConfigInterface {\r\n  address public owner;\r\n  mapping (address => bool) admins;\r\n  mapping (bytes32 => address) addressMap;\r\n  mapping (bytes32 => bool) boolMap;\r\n  mapping (bytes32 => bytes32) bytesMap;\r\n  mapping (bytes32 => uint256) uintMap;\r\n\r\n  /// @notice setConfigAddress sets configuration `_key` to `_val` \r\n  /// @param _key The key name of the configuration.\r\n  /// @param _val The value of the configuration.\r\n  /// @return Whether the configuration setting was successful or not.\r\n  function setConfigAddress(bytes32 _key, address _val) returns (bool success);\r\n\r\n  /// @notice setConfigBool sets configuration `_key` to `_val` \r\n  /// @param _key The key name of the configuration.\r\n  /// @param _val The value of the configuration.\r\n  /// @return Whether the configuration setting was successful or not.\r\n  function setConfigBool(bytes32 _key, bool _val) returns (bool success);\r\n\r\n  /// @notice setConfigBytes sets configuration `_key` to `_val`\r\n  /// @param _key The key name of the configuration.\r\n  /// @param _val The value of the configuration.\r\n  /// @return Whether the configuration setting was successful or not.\r\n  function setConfigBytes(bytes32 _key, bytes32 _val) returns (bool success);\r\n\r\n  /// @notice setConfigUint `_key` to `_val`\r\n  /// @param _key The key name of the configuration.\r\n  /// @param _val The value of the configuration.\r\n  /// @return Whether the configuration setting was successful or not.\r\n  function setConfigUint(bytes32 _key, uint256 _val) returns (bool success);\r\n\r\n  /// @notice getConfigAddress gets configuration `_key`'s value\r\n  /// @param _key The key name of the configuration.\r\n  /// @return The configuration value \r\n  function getConfigAddress(bytes32 _key) returns (address val);\r\n\r\n  /// @notice getConfigBool gets configuration `_key`'s value\r\n  /// @param _key The key name of the configuration.\r\n  /// @return The configuration value \r\n  function getConfigBool(bytes32 _key) returns (bool val);\r\n\r\n  /// @notice getConfigBytes gets configuration `_key`'s value\r\n  /// @param _key The key name of the configuration.\r\n  /// @return The configuration value \r\n  function getConfigBytes(bytes32 _key) returns (bytes32 val);\r\n\r\n  /// @notice getConfigUint gets configuration `_key`'s value\r\n  /// @param _key The key name of the configuration.\r\n  /// @return The configuration value \r\n  function getConfigUint(bytes32 _key) returns (uint256 val);\r\n\r\n  /// @notice addAdmin sets `_admin` as configuration admin\r\n  /// @return Whether the configuration setting was successful or not.  \r\n  function addAdmin(address _admin) returns (bool success);\r\n\r\n  /// @notice removeAdmin removes  `_admin`'s rights\r\n  /// @param _admin The key name of the configuration.\r\n  /// @return Whether the configuration setting was successful or not.  \r\n  function removeAdmin(address _admin) returns (bool success);\r\n\r\n}\r\n\r\ncontract TokenInterface {\r\n\r\n  struct User {\r\n    bool locked;\r\n    uint256 balance;\r\n    uint256 badges;\r\n    mapping (address => uint256) allowed;\r\n  }\r\n\r\n  mapping (address => User) users;\r\n  mapping (address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n  mapping (address => bool) seller;\r\n\r\n  address config;\r\n  address owner;\r\n  address dao;\r\n  bool locked;\r\n\r\n  /// @return total amount of tokens\r\n  uint256 public totalSupply;\r\n  uint256 public totalBadges;\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n  /// @param _owner The address from which the badge count will be retrieved\r\n  /// @return The badges count\r\n  function badgesOf(address _owner) constant returns (uint256 badge);\r\n\r\n  /// @notice send `_value` tokens to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of tokens to be transfered\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n  /// @notice send `_value` badges to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of tokens to be transfered\r\n  /// @return Whether the transfer was successful or not\r\n  function sendBadge(address _to, uint256 _value) returns (bool success);\r\n\r\n  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of tokens to be transfered\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of tokens to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n  /// @notice mint `_amount` of tokens to `_owner`\r\n  /// @param _owner The address of the account receiving the tokens\r\n  /// @param _amount The amount of tokens to mint\r\n  /// @return Whether or not minting was successful\r\n  function mint(address _owner, uint256 _amount) returns (bool success);\r\n\r\n  /// @notice mintBadge Mint `_amount` badges to `_owner`\r\n  /// @param _owner The address of the account receiving the tokens\r\n  /// @param _amount The amount of tokens to mint\r\n  /// @return Whether or not minting was successful\r\n  function mintBadge(address _owner, uint256 _amount) returns (bool success);\r\n\r\n  function registerDao(address _dao) returns (bool success);\r\n\r\n  function registerSeller(address _tokensales) returns (bool success);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event SendBadge(address indexed _from, address indexed _to, uint256 _amount);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract TokenSalesInterface {\r\n\r\n  struct SaleProxy {\r\n    address payout;\r\n    bool isProxy;\r\n  }\r\n\r\n  struct SaleStatus {\r\n    bool founderClaim;\r\n    uint256 releasedTokens;\r\n    uint256 releasedBadges;\r\n    uint256 claimers;\r\n  }\r\n\r\n  struct Info {\r\n    uint256 totalWei;\r\n    uint256 totalCents;\r\n    uint256 realCents;\r\n    uint256 amount;\r\n  }\r\n\r\n  struct SaleConfig {\r\n    uint256 startDate;\r\n    uint256 periodTwo;\r\n    uint256 periodThree;\r\n    uint256 endDate;\r\n    uint256 goal;\r\n    uint256 cap;\r\n    uint256 badgeCost;\r\n    uint256 founderAmount;\r\n    address founderWallet;\r\n  }\r\n\r\n  struct Buyer {\r\n    uint256 centsTotal;\r\n    uint256 weiTotal;\r\n    bool claimed;\r\n  }\r\n\r\n  Info saleInfo;\r\n  SaleConfig saleConfig;\r\n  SaleStatus saleStatus;\r\n\r\n  address config;\r\n  address owner;\r\n  bool locked;\r\n\r\n  uint256 public ethToCents;\r\n\r\n  mapping (address => Buyer) buyers;\r\n  mapping (address => SaleProxy) proxies;\r\n\r\n  /// @notice Calculates the parts per billion 1\u00e2\u0081\u201e1,000,000,000 of `_a` to `_b`\r\n  /// @param _a The antecedent\r\n  /// @param _c The consequent\r\n  /// @return Part per billion value\r\n  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b);\r\n\r\n\r\n  /// @notice Calculates the share from `_total` based on `_contrib` \r\n  /// @param _contrib The contributed amount in USD\r\n  /// @param _total The total amount raised in USD\r\n  /// @return Total number of shares\r\n  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share);\r\n\r\n  /// @notice Calculates the current USD cents value of `_wei` \r\n  /// @param _wei the amount of wei\r\n  /// @return The USD cents value\r\n  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue);\r\n\r\n  function proxyPurchase(address _user) returns (bool success);\r\n\r\n  /// @notice Send msg.value purchase for _user.  \r\n  /// @param _user The account to be credited\r\n  /// @return Success if purchase was accepted\r\n  function purchase(address _user, uint256 _amount) private returns (bool success);\r\n\r\n  /// @notice Get crowdsale information for `_user`\r\n  /// @param _user The account to be queried\r\n  /// @return `centstotal` the total amount of USD cents contributed\r\n  /// @return `weitotal` the total amount in wei contributed\r\n  /// @return `share` the current token shares earned\r\n  /// @return `badges` the number of proposer badges earned\r\n  /// @return `claimed` is true if the tokens and badges have been claimed\r\n  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \r\n\r\n  /// @notice Get the crowdsale information from msg.sender (see userInfo)\r\n  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \r\n\r\n  /// @notice get the total amount of wei raised for the crowdsale\r\n  /// @return The amount of wei raised\r\n  function totalWei() public constant returns (uint);\r\n\r\n  /// @notice get the total USD value in cents raised for the crowdsale\r\n  /// @return the amount USD cents\r\n  function totalCents() public constant returns (uint);\r\n\r\n  /// @notice get the current crowdsale information\r\n  /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\r\n  /// @return `two` The unix timestamp for the start of the second period modifier\r\n  /// @return `three` The unix timestamp for the start of the third period modifier\r\n  /// @return `endsale` The unix timestamp of the end of crowdsale\r\n  /// @return `totalwei` The total amount of wei raised\r\n  /// @return `totalcents` The total number of USD cents raised\r\n  /// @return `amount` The amount of DGD tokens available for the crowdsale\r\n  /// @return `goal` The USD value goal for the crowdsale\r\n  /// @return `famount` Founders endowment\r\n  /// @return `faddress` Founder wallet address\r\n  /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\r\n\r\n  function claimFor(address _user) returns (bool success); \r\n\r\n  /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\r\n  function claim() returns (bool success);\r\n\r\n  function claimFounders() returns (bool success);\r\n\r\n  /// @notice See if the crowdsale goal has been reached\r\n  function goalReached() public constant returns (bool reached);\r\n\r\n  /// @notice Get the current sale period\r\n  /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\r\n  function getPeriod() public constant returns (uint saleperiod);\r\n\r\n  /// @notice Get the date for the start of the crowdsale\r\n  /// @return `date` The unix timestamp for the start\r\n  function startDate() public constant returns (uint date);\r\n  \r\n  /// @notice Get the date for the second reward period of the crowdsale\r\n  /// @return `date` The unix timestamp for the second period\r\n  function periodTwo() public constant returns (uint date);\r\n\r\n  /// @notice Get the date for the final period of the crowdsale\r\n  /// @return `date` The unix timestamp for the final period\r\n  function periodThree() public constant returns (uint date);\r\n\r\n  /// @notice Get the date for the end of the crowdsale\r\n  /// @return `date` The unix timestamp for the end of the crowdsale\r\n  function endDate() public constant returns (uint date);\r\n\r\n  /// @notice Check if crowdsale has ended\r\n  /// @return `ended` If the crowdsale has ended\r\n  \r\n  function isEnded() public constant returns (bool ended);\r\n\r\n  /// @notice Send raised funds from the crowdsale to the DAO\r\n  /// @return `success` if the send succeeded\r\n  function sendFunds() public returns (bool success);\r\n\r\n  //function regProxy(address _payment, address _payout) returns (bool success);\r\n  function regProxy(address _payout) returns (bool success);\r\n\r\n  function getProxy(address _payout) public returns (address proxy);\r\n  \r\n  function getPayout(address _proxy) public returns (address payout, bool isproxy);\r\n\r\n  function unlock() public returns (bool success);\r\n\r\n  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\r\n\r\n  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\r\n\r\n  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\r\n  \r\n  event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\r\n  event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\r\n\r\n}\r\n\r\ncontract ProxyPayment {\r\n\r\n  address payout;\r\n  address tokenSales; \r\n  address owner;\r\n\r\n  function ProxyPayment(address _payout, address _tokenSales) {\r\n    payout = _payout;\r\n    tokenSales = _tokenSales;\r\n    owner = _payout;\r\n  }\r\n\r\n  function () {\r\n    if (!TokenSalesInterface(tokenSales).proxyPurchase.value(msg.value).gas(106000)(payout)) throw;\r\n  }\r\n\r\n}\r\n\r\ncontract TokenSales is TokenSalesInterface {\r\n\r\n  modifier ifOwner() {\r\n    if (msg.sender != owner) throw;\r\n    _\r\n  }\r\n\r\n  modifier ifOOrigin() {\r\n    if (tx.origin != owner) throw;\r\n    _\r\n  }\r\n\r\n  mapping (address => address) proxyPayouts;\r\n  uint256 public WEI_PER_ETH = 1000000000000000000;\r\n  uint256 public BILLION = 1000000000;\r\n  uint256 public CENTS = 100;\r\n\r\n\r\n  function TokenSales(address _config) {\r\n    owner = msg.sender;\r\n    config = _config;\r\n    saleStatus.founderClaim = false;\r\n    saleStatus.releasedTokens = 0;\r\n    saleStatus.releasedBadges = 0;\r\n    saleStatus.claimers = 0;\r\n    saleConfig.startDate = ConfigInterface(_config).getConfigUint(\"sale1:period1\");\r\n    saleConfig.periodTwo = ConfigInterface(_config).getConfigUint(\"sale1:period2\");\r\n    saleConfig.periodThree = ConfigInterface(_config).getConfigUint(\"sale1:period3\");\r\n    saleConfig.endDate = ConfigInterface(_config).getConfigUint(\"sale1:end\");\r\n    saleConfig.founderAmount = ConfigInterface(_config).getConfigUint(\"sale1:famount\") * BILLION;\r\n    saleConfig.founderWallet = ConfigInterface(_config).getConfigAddress(\"sale1:fwallet\");\r\n    saleConfig.goal = ConfigInterface(_config).getConfigUint(\"sale1:goal\") * CENTS;\r\n    saleConfig.cap = ConfigInterface(_config).getConfigUint(\"sale1:cap\") * CENTS;\r\n    saleConfig.badgeCost = ConfigInterface(_config).getConfigUint(\"sale1:badgecost\") * CENTS;\r\n    saleInfo.amount = ConfigInterface(_config).getConfigUint(\"sale1:amount\") * BILLION;\r\n    saleInfo.totalWei = 0;\r\n    saleInfo.totalCents = 0;\r\n    saleInfo.realCents;\r\n    saleStatus.founderClaim = false;\r\n    locked = true;\r\n  }\r\n\r\n  function () {\r\n    if (getPeriod() == 0) throw;\r\n    uint256 _amount = msg.value;\r\n    address _sender;\r\n    if (proxies[msg.sender].isProxy == true) {\r\n      _sender = proxies[msg.sender].payout;\r\n    } else {\r\n      _sender = msg.sender;\r\n    }\r\n    if (!purchase(_sender, _amount)) throw;\r\n  }\r\n\r\n  function proxyPurchase(address _user) returns (bool success) {\r\n    return purchase(_user, msg.value);\r\n  }\r\n\r\n  function purchase(address _user, uint256 _amount) private returns (bool success) {\r\n    uint256 _cents = weiToCents(_amount);\r\n    if ((saleInfo.realCents + _cents) > saleConfig.cap) return false;\r\n    uint256 _wei = _amount;\r\n    uint256 _modifier;\r\n    uint _period = getPeriod();\r\n    if ((_period == 0) || (_cents == 0)) {\r\n      return false;\r\n    } else {\r\n      if (_period == 3) _modifier = 100;\r\n      if (_period == 2) _modifier = 115;\r\n      if (_period == 1) _modifier = 130;\r\n      uint256 _creditwei = _amount;\r\n      uint256 _creditcents = (weiToCents(_creditwei) * _modifier * 10000) / 1000000 ;\r\n      buyers[_user].centsTotal += _creditcents;\r\n      buyers[_user].weiTotal += _creditwei; \r\n      saleInfo.totalCents += _creditcents;\r\n      saleInfo.realCents += _cents;\r\n      saleInfo.totalWei += _creditwei;\r\n      Purchase(ethToCents, _modifier, _creditcents); \r\n      return true;\r\n    }\r\n  }\r\n\r\n  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b) {\r\n    b = (BILLION * _a + _c / 2) / _c;\r\n    return b;\r\n  }\r\n\r\n  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share) {\r\n    uint256 _ppb = ppb(_contrib, _total);\r\n    share = ((_ppb * saleInfo.amount) / BILLION);\r\n    return share;\r\n  }\r\n\r\n  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue) {\r\n    centsvalue = ((_wei * 100000 / WEI_PER_ETH) * ethToCents) / 100000;\r\n    return centsvalue;\r\n  }\r\n\r\n  function setEthToCents(uint256 _eth) ifOwner returns (bool success) {\r\n    ethToCents = _eth;\r\n    success = true;\r\n    return success;\r\n  }\r\n\r\n\r\n  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers) {\r\n    return (saleStatus.founderClaim, saleStatus.releasedTokens, saleStatus.releasedBadges, saleStatus.claimers);\r\n  }\r\n\r\n  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount) {\r\n    return (saleInfo.totalWei, saleInfo.totalCents, saleInfo.realCents, saleInfo.amount);\r\n  }\r\n\r\n\r\n  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet) {\r\n    return (saleConfig.startDate, saleConfig.periodTwo, saleConfig.periodThree, saleConfig.endDate, saleConfig.goal, saleConfig.cap, saleConfig.badgeCost, saleConfig.founderAmount, saleConfig.founderWallet);\r\n  }\r\n\r\n  function goalReached() public constant returns (bool reached) {\r\n    reached = (saleInfo.totalCents >= saleConfig.goal);\r\n    return reached;\r\n  }\r\n\r\n  function claim() returns (bool success) {\r\n    return claimFor(msg.sender);\r\n  }\r\n\r\n  function claimFor(address _user) returns (bool success) {\r\n    if ( (now < saleConfig.endDate) || (buyers[_user].claimed == true) ) {\r\n      return true;\r\n    }\r\n  \r\n    if (!goalReached()) {\r\n      if (!address(_user).send(buyers[_user].weiTotal)) throw;\r\n      buyers[_user].claimed = true;\r\n      return true;\r\n    }\r\n\r\n    if (goalReached()) {\r\n      address _tokenc = ConfigInterface(config).getConfigAddress(\"ledger\");\r\n      uint256 _tokens = calcShare(buyers[_user].centsTotal, saleInfo.totalCents); \r\n      uint256 _badges = buyers[_user].centsTotal / saleConfig.badgeCost;\r\n      if ((TokenInterface(_tokenc).mint(msg.sender, _tokens)) && (TokenInterface(_tokenc).mintBadge(_user, _badges))) {\r\n        saleStatus.releasedTokens += _tokens;\r\n        saleStatus.releasedBadges += _badges;\r\n        saleStatus.claimers += 1;\r\n        buyers[_user].claimed = true;\r\n        Claim(_user, _tokens, _badges);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  function claimFounders() returns (bool success) {\r\n    if (saleStatus.founderClaim == true) return false;\r\n    if (now < saleConfig.endDate) return false;\r\n    if (!goalReached()) return false;\r\n    address _tokenc = ConfigInterface(config).getConfigAddress(\"ledger\");\r\n    uint256 _tokens = saleConfig.founderAmount;\r\n    uint256 _badges = 4;\r\n    address _faddr = saleConfig.founderWallet;\r\n    if ((TokenInterface(_tokenc).mint(_faddr, _tokens)) && (TokenInterface(_tokenc).mintBadge(_faddr, _badges))) {\r\n      saleStatus.founderClaim = true;\r\n      saleStatus.releasedTokens += _tokens;\r\n      saleStatus.releasedBadges += _badges;\r\n      saleStatus.claimers += 1;\r\n      Claim(_faddr, _tokens, _badges);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function getPeriod() public constant returns (uint saleperiod) {\r\n    if ((now > saleConfig.endDate) || (now < saleConfig.startDate)) {\r\n      saleperiod = 0;\r\n      return saleperiod;\r\n    }\r\n    if (now >= saleConfig.periodThree) {\r\n      saleperiod = 3;\r\n      return saleperiod;\r\n    }\r\n    if (now >= saleConfig.periodTwo) {\r\n      saleperiod = 2;\r\n      return saleperiod;\r\n    }\r\n    if (now < saleConfig.periodTwo) {\r\n      saleperiod = 1;\r\n      return saleperiod;\r\n    }\r\n  }\r\n\r\n  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\r\n    share = calcShare(buyers[_user].centsTotal, saleInfo.totalCents);\r\n    badges = buyers[_user].centsTotal / saleConfig.badgeCost;\r\n    return (buyers[_user].centsTotal, buyers[_user].weiTotal, share, badges, buyers[_user].claimed);\r\n  }\r\n\r\n  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\r\n    return userInfo(msg.sender);\r\n  }\r\n\r\n  function totalWei() public constant returns (uint) {\r\n    return saleInfo.totalWei;\r\n  }\r\n\r\n  function totalCents() public constant returns (uint) {\r\n    return saleInfo.totalCents;\r\n  }\r\n\r\n  function startDate() public constant returns (uint date) {\r\n    return saleConfig.startDate;\r\n  }\r\n  \r\n  function periodTwo() public constant returns (uint date) {\r\n    return saleConfig.periodTwo;\r\n  }\r\n\r\n  function periodThree() public constant returns (uint date) {\r\n    return saleConfig.periodThree;\r\n  }\r\n\r\n  function endDate() public constant returns (uint date) {\r\n    return saleConfig.endDate;\r\n  }\r\n\r\n  function isEnded() public constant returns (bool ended) {\r\n    return (now >= endDate());\r\n  }\r\n  \r\n  function sendFunds() public returns (bool success) {\r\n    if (locked) return false;\r\n    if (!goalReached()) return false;\r\n    if (!isEnded()) return false;\r\n    address _dao = ConfigInterface(config).getConfigAddress(\"sale1:dao\");\r\n    if (_dao == 0x0000000000000000000000000000000000000000) return false;\r\n    return _dao.send(totalWei());\r\n  }\r\n\r\n  function regProxy(address _payout) ifOOrigin returns (bool success) {\r\n    address _proxy = new ProxyPayment(_payout, address(this));\r\n    proxies[_proxy].payout = _payout;\r\n    proxies[_proxy].isProxy = true;\r\n    proxyPayouts[_payout] = _proxy;\r\n    return true;\r\n  }\r\n  \r\n  function getProxy(address _payout) public returns (address proxy) {\r\n    return proxyPayouts[_payout];\r\n  }\r\n\r\n  function getPayout(address _proxy) public returns (address payout, bool isproxy) {\r\n    return (proxies[_proxy].payout, proxies[_proxy].isProxy);\r\n  }\r\n\r\n  function unlock() ifOwner public returns (bool success) {\r\n    locked = false;\r\n    return true;\r\n  }\r\n}", 
  "balance": "466,645<b>.</b>808531885422905454 Ether", 
  "name": "TokenSales", 
  "transactions": "3316", 
  "address": "0xf0160428a8552ac9bb7e050d90eeade4ddd52843"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function __callback(bytes32 myid, string result) {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32 myid, string result, bytes proof) {\r\n    }\r\n    \r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 7500; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 90; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BMmkEKUccgE4/k+IKb650CLwQ/ACeowJ6a0erQDDqXn1XoTiKRXkw0T3ddPc5l6yUJ8/lEUd3DVG7nwvC/N9jY5NGgeNU4Xvi6HpWjqrevinSkadL3RL0v2w9fr87hd/sURn77W7W8WPoxVH+K8E74+0XHf5vak=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "236<b>.</b>680644278908125437 Ether", 
  "name": "Dice", 
  "transactions": "2821", 
  "address": "0x49fddeae0b521dab8d0c4b77e7161094f971320d"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n/*\r\n * Token - is a smart contract interface \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract TokenInterface {\r\n\r\n        \r\n    // total amount of tokens\r\n    uint totalSupply;\r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    \r\n    function transfer(address to, uint256 value) returns (bool success);\r\n\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how much is \r\n     *               permitted to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permitted to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n\r\n    // events notifications\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/*\r\n * StandardToken - is a smart contract  \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: \r\n *         https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is TokenInterface {\r\n\r\n\r\n    // token ownership\r\n    mapping (address => uint256) balances;\r\n\r\n    // spending permision management\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    \r\n    \r\n    function StandardToken(){\r\n    }\r\n    \r\n    \r\n    /**\r\n     * transfer() - transfer tokens from msg.sender balance \r\n     *              to requested account\r\n     *\r\n     *  @param to    - target address to transfer tokens\r\n     *  @param value - ammount of tokens to transfer\r\n     *\r\n     *  @return - success / failure of the transaction\r\n     */    \r\n    function transfer(address to, uint256 value) returns (bool success) {\r\n        \r\n        \r\n        if (balances[msg.sender] >= value && value > 0) {\r\n\r\n            // do actual tokens transfer       \r\n            balances[msg.sender] -= value;\r\n            balances[to]         += value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            \r\n            return false; \r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    /**\r\n     * transferFrom() - \r\n     *\r\n     *  @param from  - \r\n     *  @param to    - \r\n     *  @param value - \r\n     *\r\n     *  @return \r\n     */\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success) {\r\n    \r\n        if ( balances[from] >= value && \r\n             allowed[from][msg.sender] >= value && \r\n             value > 0) {\r\n                                          \r\n    \r\n            // do the actual transfer\r\n            balances[from] -= value;    \r\n            balances[to] =+ value;            \r\n            \r\n\r\n            // addjust the permision, after part of \r\n            // permited to spend value was used\r\n            allowed[from][msg.sender] -= value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { \r\n            \r\n            return false; \r\n        }\r\n    }\r\n\r\n    \r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success) {\r\n        \r\n        // now spender can use balance in \r\n        // ammount of value from owner balance\r\n        allowed[msg.sender][spender] = value;\r\n        \r\n        // rise event about the transaction\r\n        Approval(msg.sender, spender, value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how mouch is \r\n     *               permited to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permited to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining) {\r\n      return allowed[owner][spender];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @title Hacker Gold\r\n * \r\n * The official token powering the hack.ether.camp virtual accelerator.\r\n * This is the only way to acquire tokens from startups during the event.\r\n *\r\n * Whitepaper https://hack.ether.camp/whitepaper\r\n *\r\n */\r\ncontract HackerGold is StandardToken {\r\n\r\n    // Name of the token    \r\n    string public name = \"HackerGold\";\r\n\r\n    // Decimal places\r\n    uint8  public decimals = 3;\r\n    // Token abbreviation        \r\n    string public symbol = \"HKG\";\r\n    \r\n    // 1 ether = 200 hkg\r\n    uint BASE_PRICE = 200;\r\n    // 1 ether = 150 hkg\r\n    uint MID_PRICE = 150;\r\n    // 1 ether = 100 hkg\r\n    uint FIN_PRICE = 100;\r\n    // Safety cap\r\n    uint SAFETY_LIMIT = 4000000 ether;\r\n    // Zeros after the point\r\n    uint DECIMAL_ZEROS = 1000;\r\n    \r\n    // Total value in wei\r\n    uint totalValue;\r\n    \r\n    // Address of multisig wallet holding ether from sale\r\n    address wallet;\r\n\r\n    // Structure of sale increase milestones\r\n    struct milestones_struct {\r\n      uint p1;\r\n      uint p2; \r\n      uint p3;\r\n      uint p4;\r\n      uint p5;\r\n      uint p6;\r\n    }\r\n    // Milestones instance\r\n    milestones_struct milestones;\r\n    \r\n    /**\r\n     * Constructor of the contract.\r\n     * \r\n     * Passes address of the account holding the value.\r\n     * HackerGold contract itself does not hold any value\r\n     * \r\n     * @param multisig address of MultiSig wallet which will hold the value\r\n     */\r\n    function HackerGold(address multisig) {\r\n        \r\n        wallet = multisig;\r\n\r\n        // set time periods for sale\r\n        milestones = milestones_struct(\r\n        \r\n          1476799200,  // P1: GMT: 18-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        );\r\n                \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Fallback function: called on ether sent.\r\n     * \r\n     * It calls to createHKG function with msg.sender \r\n     * as a value for holder argument\r\n     */\r\n    function () payable {\r\n        createHKG(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Creates HKG tokens.\r\n     * \r\n     * Runs sanity checks including safety cap\r\n     * Then calculates current price by getPrice() function, creates HKG tokens\r\n     * Finally sends a value of transaction to the wallet\r\n     * \r\n     * Note: due to lack of floating point types in Solidity,\r\n     * contract assumes that last 3 digits in tokens amount are stood after the point.\r\n     * It means that if stored HKG balance is 100000, then its real value is 100 HKG\r\n     * \r\n     * @param holder token holder\r\n     */\r\n    function createHKG(address holder) payable {\r\n        \r\n        if (now < milestones.p1) throw;\r\n        if (now >= milestones.p6) throw;\r\n        if (msg.value == 0) throw;\r\n    \r\n        // safety cap\r\n        if (getTotalValue() + msg.value > SAFETY_LIMIT) throw; \r\n    \r\n        uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n        totalSupply += tokens;\r\n        balances[holder] += tokens;\r\n        totalValue += msg.value;\r\n        \r\n        if (!wallet.send(msg.value)) throw;\r\n    }\r\n    \r\n    /**\r\n     * Denotes complete price structure during the sale.\r\n     *\r\n     * @return HKG amount per 1 ETH for the current moment in time\r\n     */\r\n    function getPrice() constant returns (uint result) {\r\n        \r\n        if (now < milestones.p1) return 0;\r\n        \r\n        if (now >= milestones.p1 && now < milestones.p2) {\r\n        \r\n            return BASE_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p2 && now < milestones.p3) {\r\n            \r\n            uint days_in = 1 + (now - milestones.p2) / 1 days; \r\n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p3 && now < milestones.p4) {\r\n        \r\n            return MID_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p4 && now < milestones.p5) {\r\n            \r\n            days_in = 1 + (now - milestones.p4) / 1 days; \r\n            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p5 && now < milestones.p6) {\r\n        \r\n            return FIN_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p6){\r\n\r\n            return 0;\r\n        }\r\n\r\n     }\r\n    \r\n    /**\r\n     * Returns total stored HKG amount.\r\n     * \r\n     * Contract assumes that last 3 digits of this value are behind the decimal place. i.e. 10001 is 10.001\r\n     * Thus, result of this function should be divided by 1000 to get HKG value\r\n     * \r\n     * @return result stored HKG amount\r\n     */\r\n    function getTotalSupply() constant returns (uint result) {\r\n        return totalSupply;\r\n    } \r\n\r\n    /**\r\n     * It is used for test purposes.\r\n     * \r\n     * Returns the result of 'now' statement of Solidity language\r\n     * \r\n     * @return unix timestamp for current moment in time\r\n     */\r\n    function getNow() constant returns (uint result) {\r\n        return now;\r\n    }\r\n\r\n    /**\r\n     * Returns total value passed through the contract\r\n     * \r\n     * @return result total value in wei\r\n     */\r\n    function getTotalValue() constant returns (uint result) {\r\n        return totalValue;  \r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "HackerGold", 
  "transactions": "2593", 
  "address": "0xb582baaf5e749d6aa98a22355a9d08b4c4d013c8"
 }, 
 {
  "source": "contract WavesPresale {\r\n    address public owner;\r\n    \r\n    struct Sale\r\n    {\r\n        uint amount;\r\n        uint date;\r\n    }\r\n\r\n    mapping (bytes16 => Sale) public sales;\r\n    uint32 public numberOfSales;\r\n    uint public totalTokens;\r\n\r\n    function WavesPresale() {\r\n        owner = msg.sender;\r\n        numberOfSales = 0;\r\n    }\r\n\r\n    function changeOwner(address newOwner) {\r\n        if (msg.sender != owner) return;\r\n\r\n        owner = newOwner;\r\n    }\r\n\r\n    function newSale(bytes16 txidHash, uint amount, uint timestamp) {\r\n        if (msg.sender != owner) return;\r\n\r\n        if (sales[txidHash].date == 0) {\r\n            sales[txidHash] = Sale({\r\n                    amount: amount,\r\n                    date: timestamp\r\n                });\r\n            numberOfSales += 1;\r\n            totalTokens += amount;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function getSaleDate(bytes16 txidHash) constant returns (uint, uint) {\r\n    \treturn (sales[txidHash].amount, sales[txidHash].date);\r\n    }\r\n\r\n    function () {\r\n        // This function gets executed if a\r\n        // transaction with invalid data is sent to\r\n        // the contract or just ether without data.\r\n        // We revert the send so that no-one\r\n        // accidentally loses money when using the\r\n        // contract.\r\n        throw;\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "WavesPresale", 
  "transactions": "2582", 
  "address": "0x5bc7e5694ee5d6ea32a0da36efb56a177190a53a"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n/*\r\nThis vSlice token contract is based on the ERC20 token contract. Additional\r\nfunctionality has been integrated:\r\n* the contract Lockable, which is used as a parent of the Token contract\r\n* the function mintTokens(), which makes use of the currentSwapRate() and safeToAdd() helpers\r\n* the function disableTokenSwapLock()\r\n*/\r\n\r\ncontract Lockable {\r\n    uint public numOfCurrentEpoch;\r\n    uint public creationTime;\r\n    uint public constant UNLOCKED_TIME = 25 days;\r\n    uint public constant LOCKED_TIME = 5 days;\r\n    uint public constant EPOCH_LENGTH = 30 days;\r\n    bool public lock;\r\n    bool public tokenSwapLock;\r\n\r\n    event Locked();\r\n    event Unlocked();\r\n\r\n    // This modifier should prevent tokens transfers while the tokenswap\r\n    // is still ongoing\r\n    modifier isTokenSwapOn {\r\n        if (tokenSwapLock) throw;\r\n        _;\r\n    }\r\n\r\n    // This modifier checks and, if needed, updates the value of current\r\n    // token contract epoch, before executing a token transfer of any\r\n    // kind\r\n    modifier isNewEpoch {\r\n        if (numOfCurrentEpoch * EPOCH_LENGTH + creationTime < now ) {\r\n            numOfCurrentEpoch = (now - creationTime) / EPOCH_LENGTH + 1;\r\n        }\r\n        _;\r\n    }\r\n\r\n    // This modifier check whether the contract should be in a locked\r\n    // or unlocked state, then acts and updates accordingly if\r\n    // necessary\r\n    modifier checkLock {\r\n        if ((creationTime + numOfCurrentEpoch * UNLOCKED_TIME) +\r\n        (numOfCurrentEpoch - 1) * LOCKED_TIME < now) {\r\n            // avoids needless lock state change and event spamming\r\n            if (lock) throw;\r\n\r\n            lock = true;\r\n            Locked();\r\n            return;\r\n        }\r\n        else {\r\n            // only set to false if in a locked state, to avoid\r\n            // needless state change and event spam\r\n            if (lock) {\r\n                lock = false;\r\n                Unlocked();\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    function Lockable() {\r\n        creationTime = now;\r\n        numOfCurrentEpoch = 1;\r\n        tokenSwapLock = true;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint);\r\n    function balanceOf(address who) constant returns (uint);\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n\r\n    function transfer(address to, uint value) returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Token is ERC20, Lockable {\r\n\r\n  mapping( address => uint ) _balances;\r\n  mapping( address => mapping( address => uint ) ) _approvals;\r\n  uint _supply;\r\n  address public walletAddress;\r\n\r\n  event TokenMint(address newTokenHolder, uint amountOfTokens);\r\n  event TokenSwapOver();\r\n\r\n  modifier onlyFromWallet {\r\n      if (msg.sender != walletAddress) throw;\r\n      _;\r\n  }\r\n\r\n  function Token( uint initial_balance, address wallet) {\r\n    _balances[msg.sender] = initial_balance;\r\n    _supply = initial_balance;\r\n    walletAddress = wallet;\r\n  }\r\n\r\n  function totalSupply() constant returns (uint supply) {\r\n    return _supply;\r\n  }\r\n\r\n  function balanceOf( address who ) constant returns (uint value) {\r\n    return _balances[who];\r\n  }\r\n\r\n  function allowance(address owner, address spender) constant returns (uint _allowance) {\r\n    return _approvals[owner][spender];\r\n  }\r\n\r\n  // A helper to notify if overflow occurs\r\n  function safeToAdd(uint a, uint b) internal returns (bool) {\r\n    return (a + b >= a && a + b >= b);\r\n  }\r\n\r\n  function transfer( address to, uint value)\r\n    isTokenSwapOn\r\n    isNewEpoch\r\n    checkLock\r\n    returns (bool ok) {\r\n\r\n    if( _balances[msg.sender] < value ) {\r\n        throw;\r\n    }\r\n    if( !safeToAdd(_balances[to], value) ) {\r\n        throw;\r\n    }\r\n\r\n    _balances[msg.sender] -= value;\r\n    _balances[to] += value;\r\n    Transfer( msg.sender, to, value );\r\n    return true;\r\n  }\r\n\r\n  function transferFrom( address from, address to, uint value)\r\n    isTokenSwapOn\r\n    isNewEpoch\r\n    checkLock\r\n    returns (bool ok) {\r\n    // if you don't have enough balance, throw\r\n    if( _balances[from] < value ) {\r\n        throw;\r\n    }\r\n    // if you don't have approval, throw\r\n    if( _approvals[from][msg.sender] < value ) {\r\n        throw;\r\n    }\r\n    if( !safeToAdd(_balances[to], value) ) {\r\n        throw;\r\n    }\r\n    // transfer and return true\r\n    _approvals[from][msg.sender] -= value;\r\n    _balances[from] -= value;\r\n    _balances[to] += value;\r\n    Transfer( from, to, value );\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint value)\r\n    isTokenSwapOn\r\n    isNewEpoch\r\n    checkLock\r\n    returns (bool ok) {\r\n    _approvals[msg.sender][spender] = value;\r\n    Approval( msg.sender, spender, value );\r\n    return true;\r\n  }\r\n\r\n  // The function currentSwapRate() returns the current exchange rate\r\n  // between vSlice tokens and Ether during the token swap period\r\n  function currentSwapRate() constant returns(uint) {\r\n      if (creationTime + 1 weeks > now) {\r\n          return 130;\r\n      }\r\n      else if (creationTime + 2 weeks > now) {\r\n          return 120;\r\n      }\r\n      else if (creationTime + 4 weeks > now) {\r\n          return 100;\r\n      }\r\n      else {\r\n          return 0;\r\n      }\r\n  }\r\n\r\n  // The function mintTokens is only usable by the chosen wallet\r\n  // contract to mint a number of tokens proportional to the\r\n  // amount of ether sent to the wallet contract. The function\r\n  // can only be called during the tokenswap period\r\n  function mintTokens(address newTokenHolder, uint etherAmount)\r\n    external\r\n    onlyFromWallet {\r\n\r\n        uint tokensAmount = currentSwapRate() * etherAmount;\r\n        if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw;\r\n        if(!safeToAdd(_supply,tokensAmount)) throw;\r\n\r\n        _balances[newTokenHolder] += tokensAmount;\r\n        _supply += tokensAmount;\r\n\r\n        TokenMint(newTokenHolder, tokensAmount);\r\n  }\r\n\r\n  // The function disableTokenSwapLock() is called by the wallet\r\n  // contract once the token swap has reached its end conditions\r\n  function disableTokenSwapLock()\r\n    external\r\n    onlyFromWallet {\r\n        tokenSwapLock = false;\r\n        TokenSwapOver();\r\n  }\r\n}", 
  "balance": "0 Ether", 
  "name": "Token", 
  "transactions": "2561", 
  "address": "0x5c543e7ae0a1104f78406c340e9c64fd9fce5170"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function __callback(bytes32 myid, string result) {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32 myid, string result, bytes proof) {\r\n    }\r\n    \r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 4000; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 90; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BIxxSk7/a7poZUlLstBS3dBn4S3Z1SwCpAkhPfT5ZM8TpCkJIHCgbpiOlLR3aJZhFtP27av3lqqnOl6PqJKX4hQx4ASiqrD8TsuViJg2/6HDzu4/IuS21zHmeNAZOLvaSUgB+zr6B4TILVqsf96HU5zx9Skv4Dk=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "1,102<b>.</b>51024632129304287 Ether", 
  "name": "Dice", 
  "transactions": "2495", 
  "address": "0x1e2fbe6be9eb39fc894d38be976111f332172d83"
 }, 
 {
  "source": "/**\r\n * Overflow aware uint math functions.\r\n *\r\n * Inspired by https://github.com/MakerDAO/maker-otc/blob/master/contracts/simple_market.sol\r\n */\r\ncontract SafeMath {\r\n  //internals\r\n\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\n/**\r\n * ERC 20 token\r\n *\r\n * https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n/**\r\n * ERC 20 token\r\n *\r\n * https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is Token {\r\n\r\n    /**\r\n     * Reviewed:\r\n     * - Interger overflow = OK, checked\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        //if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n}\r\n\r\n\r\n/**\r\n * First blood crowdsale crowdsale contract.\r\n *\r\n * Security criteria evaluated against http://ethereum.stackexchange.com/questions/8551/methodological-security-review-of-a-smart-contract\r\n *\r\n *\r\n */\r\ncontract FirstBloodToken is StandardToken, SafeMath {\r\n\r\n    string public name = \"FirstBlood Token\";\r\n    string public symbol = \"1ST\";\r\n    uint public decimals = 18;\r\n    uint public startBlock; //crowdsale start block (set in constructor)\r\n    uint public endBlock; //crowdsale end block (set in constructor)\r\n\r\n    // Initial founder address (set in constructor)\r\n    // All deposited ETH will be instantly forwarded to this address.\r\n    // Address is a multisig wallet.\r\n    address public founder = 0x0;\r\n\r\n    // signer address (for clickwrap agreement)\r\n    // see function() {} for comments\r\n    address public signer = 0x0;\r\n\r\n    uint public etherCap = 465313 * 10**18; //max amount raised during crowdsale (5.5M USD worth of ether will be measured with a moving average market price at beginning of the crowdsale)\r\n    uint public transferLockup = 370285; //transfers are locked for this many blocks after endBlock (assuming 14 second blocks, this is 2 months)\r\n    uint public founderLockup = 2252571; //founder allocation cannot be created until this many blocks after endBlock (assuming 14 second blocks, this is 1 year)\r\n    uint public bountyAllocation = 2500000 * 10**18; //2.5M tokens allocated post-crowdsale for the bounty fund\r\n    uint public ecosystemAllocation = 5 * 10**16; //5% of token supply allocated post-crowdsale for the ecosystem fund\r\n    uint public founderAllocation = 10 * 10**16; //10% of token supply allocated post-crowdsale for the founder allocation\r\n    bool public bountyAllocated = false; //this will change to true when the bounty fund is allocated\r\n    bool public ecosystemAllocated = false; //this will change to true when the ecosystem fund is allocated\r\n    bool public founderAllocated = false; //this will change to true when the founder fund is allocated\r\n    uint public presaleTokenSupply = 0; //this will keep track of the token supply created during the crowdsale\r\n    uint public presaleEtherRaised = 0; //this will keep track of the Ether raised during the crowdsale\r\n    bool public halted = false; //the founder address can set this to true to halt the crowdsale due to emergency\r\n    event Buy(address indexed sender, uint eth, uint fbt);\r\n    event Withdraw(address indexed sender, address to, uint eth);\r\n    event AllocateFounderTokens(address indexed sender);\r\n    event AllocateBountyAndEcosystemTokens(address indexed sender);\r\n\r\n    function FirstBloodToken(address founderInput, address signerInput, uint startBlockInput, uint endBlockInput) {\r\n        founder = founderInput;\r\n        signer = signerInput;\r\n        startBlock = startBlockInput;\r\n        endBlock = endBlockInput;\r\n    }\r\n\r\n    /**\r\n     * Security review\r\n     *\r\n     * - Integer overflow: does not apply, blocknumber can't grow that high\r\n     * - Division is the last operation and constant, should not cause issues\r\n     * - Price function plotted https://github.com/Firstbloodio/token/issues/2\r\n     */\r\n    function price() constant returns(uint) {\r\n        if (block.number>=startBlock && block.number<startBlock+250) return 170; //power hour\r\n        if (block.number<startBlock || block.number>endBlock) return 100; //default price\r\n        return 100 + 4*(endBlock - block.number)/(endBlock - startBlock + 1)*67/4; //crowdsale price\r\n    }\r\n\r\n    // price() exposed for unit tests\r\n    function testPrice(uint blockNumber) constant returns(uint) {\r\n        if (blockNumber>=startBlock && blockNumber<startBlock+250) return 170; //power hour\r\n        if (blockNumber<startBlock || blockNumber>endBlock) return 100; //default price\r\n        return 100 + 4*(endBlock - blockNumber)/(endBlock - startBlock + 1)*67/4; //crowdsale price\r\n    }\r\n\r\n    // Buy entry point\r\n    function buy(uint8 v, bytes32 r, bytes32 s) {\r\n        buyRecipient(msg.sender, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * Main token buy function.\r\n     *\r\n     * Security review\r\n     *\r\n     * - Integer math: ok - using SafeMath\r\n     *\r\n     * - halt flag added - ok\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test halting, buying, and failing\r\n     * - Test buying on behalf of a recipient\r\n     * - Test buy\r\n     * - Test unhalting, buying, and succeeding\r\n     * - Test buying after the sale ends\r\n     *\r\n     */\r\n    function buyRecipient(address recipient, uint8 v, bytes32 r, bytes32 s) {\r\n        bytes32 hash = sha256(msg.sender);\r\n        if (ecrecover(hash,v,r,s) != signer) throw;\r\n        if (block.number<startBlock || block.number>endBlock || safeAdd(presaleEtherRaised,msg.value)>etherCap || halted) throw;\r\n        uint tokens = safeMul(msg.value, price());\r\n        balances[recipient] = safeAdd(balances[recipient], tokens);\r\n        totalSupply = safeAdd(totalSupply, tokens);\r\n        presaleEtherRaised = safeAdd(presaleEtherRaised, msg.value);\r\n\r\n        if (!founder.call.value(msg.value)()) throw; //immediately send Ether to founder address\r\n\r\n        Buy(recipient, msg.value, tokens);\r\n    }\r\n\r\n    /**\r\n     * Set up founder address token balance.\r\n     *\r\n     * allocateBountyAndEcosystemTokens() must be calld first.\r\n     *\r\n     * Security review\r\n     *\r\n     * - Integer math: ok - only called once with fixed parameters\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test bounty and ecosystem allocation\r\n     * - Test bounty and ecosystem allocation twice\r\n     *\r\n     */\r\n    function allocateFounderTokens() {\r\n        if (msg.sender!=founder) throw;\r\n        if (block.number <= endBlock + founderLockup) throw;\r\n        if (founderAllocated) throw;\r\n        if (!bountyAllocated || !ecosystemAllocated) throw;\r\n        balances[founder] = safeAdd(balances[founder], presaleTokenSupply * founderAllocation / (1 ether));\r\n        totalSupply = safeAdd(totalSupply, presaleTokenSupply * founderAllocation / (1 ether));\r\n        founderAllocated = true;\r\n        AllocateFounderTokens(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Set up founder address token balance.\r\n     *\r\n     * Set up bounty pool.\r\n     *\r\n     * Security review\r\n     *\r\n     * - Integer math: ok - only called once with fixed parameters\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test founder token allocation too early\r\n     * - Test founder token allocation on time\r\n     * - Test founder token allocation twice\r\n     *\r\n     */\r\n    function allocateBountyAndEcosystemTokens() {\r\n        if (msg.sender!=founder) throw;\r\n        if (block.number <= endBlock) throw;\r\n        if (bountyAllocated || ecosystemAllocated) throw;\r\n        presaleTokenSupply = totalSupply;\r\n        balances[founder] = safeAdd(balances[founder], presaleTokenSupply * ecosystemAllocation / (1 ether));\r\n        totalSupply = safeAdd(totalSupply, presaleTokenSupply * ecosystemAllocation / (1 ether));\r\n        balances[founder] = safeAdd(balances[founder], bountyAllocation);\r\n        totalSupply = safeAdd(totalSupply, bountyAllocation);\r\n        bountyAllocated = true;\r\n        ecosystemAllocated = true;\r\n        AllocateBountyAndEcosystemTokens(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Emergency Stop crowdsale.\r\n     *\r\n     *  Applicable tests:\r\n     *\r\n     * - Test unhalting, buying, and succeeding\r\n     */\r\n    function halt() {\r\n        if (msg.sender!=founder) throw;\r\n        halted = true;\r\n    }\r\n\r\n    function unhalt() {\r\n        if (msg.sender!=founder) throw;\r\n        halted = false;\r\n    }\r\n\r\n    /**\r\n     * Change founder address (where crowdsale ETH is being forwarded).\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test founder change by hacker\r\n     * - Test founder change\r\n     * - Test founder token allocation twice\r\n     *\r\n     */\r\n\r\n    function changeFounder(address newFounder) {\r\n        if (msg.sender!=founder) throw;\r\n        founder = newFounder;\r\n    }\r\n\r\n    /**\r\n     * ERC 20 Standard Token interface transfer function\r\n     *\r\n     * Prevent transfers until freeze period is over.\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test restricted early transfer\r\n     * - Test transfer after restricted period\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (block.number <= endBlock + transferLockup && msg.sender!=founder) throw;\r\n        return super.transfer(_to, _value);\r\n    }\r\n    /**\r\n     * ERC 20 Standard Token interface transfer function\r\n     *\r\n     * Prevent transfers until freeze period is over.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (block.number <= endBlock + transferLockup && msg.sender!=founder) throw;\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Do not allow direct deposits.\r\n     *\r\n     * All crowdsale depositors must have read the legal agreement.\r\n     * This is confirmed by having them signing the terms of service on the website.\r\n     * They give their crowdsale Ethereum source address on the website.\r\n     * Website signs this address using crowdsale private key (different from founders key).\r\n     * buy() takes this signature as input and rejects all deposits that do not have\r\n     * signature you receive after reading terms of service.\r\n     *\r\n     */\r\n    function() {\r\n        throw;\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "FirstBloodToken", 
  "transactions": "2324", 
  "address": "0xaf30d2a7e90d7dc361c8c4585e9bb7d2f6f15bc7"
 }, 
 {
  "source": "/*\r\nThe Pluton Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans.\r\n\r\nPluton contract extends HumanStandardToken, https://github.com/consensys/tokens\r\n\r\n.*/\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract HumanStandardToken is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function HumanStandardToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        ) {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\r\n\r\n// Creates 20,000,000.000000000000000000 Pluton (PLU) Tokens\r\ncontract Pluton is HumanStandardToken(20000000000000000000000000, \"Pluton\", 18, \"PLU\") {}", 
  "balance": "0<b>.</b>0000000000000996 Ether", 
  "name": "Pluton", 
  "transactions": "2192", 
  "address": "0xd8912c10681d8b21fd3742244f44658dba12264e"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function __callback(bytes32 myid, string result) {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32 myid, string result, bytes proof) {\r\n    }\r\n    \r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 500; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 90; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BIm/tGMbfbvgqpywDDC201Jxob7/6+sSkRBtfCXN94GO0C7uD4eQ+aF+9xNJOigntWu8QHXU6XovJqRMEGHhnEnoaVqVWSqH1U1UFyE6WySavcbOb/h8hOfXv+jYBRuhkQr+tHXYrt1wx0P0dRdeCxbLp1nDuq8=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "980<b>.</b>157406066183758146 Ether", 
  "name": "Dice", 
  "transactions": "2095", 
  "address": "0x4e646a576917a6a47d5b0896c3e207693870869d"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function __callback(bytes32 myid, string result) {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32 myid, string result, bytes proof) {\r\n    }\r\n    \r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 9000; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 90; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BIYkzb1GQzRZFNsTzF7fh+n8VmT8GEyW3mHYlrU8It5O6/bam6/LVVxqkury8YZDJPjm0mWQeqQGebGAVSFrFw16/VHJ65QMFBfIHN2frhav/d10ARqECjoOvse5v4/DIT3LQUHPEx0Z/5UdtqYTQydW/pbC5BM=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "221<b>.</b>296049283494382001 Ether", 
  "name": "Dice", 
  "transactions": "2062", 
  "address": "0x7da90089a73edd14c75b0c827cb54f4248d47ecc"
 }, 
 {
  "source": "contract WavesPresale {\r\n    address public owner;\r\n    \r\n    struct Sale\r\n    {\r\n        uint amount;\r\n        uint date;\r\n    }\r\n\r\n    mapping (bytes16 => Sale) public sales;\r\n    uint32 public numberOfSales;\r\n    uint public totalTokens;\r\n\r\n    function WavesPresale() {\r\n        owner = msg.sender;\r\n        numberOfSales = 0;\r\n    }\r\n\r\n    function changeOwner(address newOwner) {\r\n        if (msg.sender != owner) return;\r\n\r\n        owner = newOwner;\r\n    }\r\n\r\n    function newSale(bytes16 txidHash, uint amount, uint timestamp) {\r\n        if (msg.sender != owner) return;\r\n\r\n        sales[txidHash] = Sale({\r\n                amount: amount,\r\n                date: timestamp\r\n            });\r\n        numberOfSales += 1;\r\n        totalTokens += amount;\r\n    }\r\n\r\n    function getSaleDate(bytes16 txidHash) constant returns (uint, uint) {\r\n    \treturn (sales[txidHash].amount, sales[txidHash].date);\r\n    }\r\n\r\n    function () {\r\n        // This function gets executed if a\r\n        // transaction with invalid data is sent to\r\n        // the contract or just ether without data.\r\n        // We revert the send so that no-one\r\n        // accidentally loses money when using the\r\n        // contract.\r\n        throw;\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "WavesPresale", 
  "transactions": "2052", 
  "address": "0xbd37672116c2f4c14ba5a23921bdc57860e64aa0"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function __callback(bytes32 myid, string result) {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32 myid, string result, bytes proof) {\r\n    }\r\n    \r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 1000; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 90; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BJ5a3yY9W3QsrTn/ChMwRJBtt+I5S4aEM6RVELUydl2tlqEjYIHoiWFnaatIUAQ76prgz1uoWI4Zpdj0gNMSS3n/vn7br6SMy9zpLZCRVqPS7TIcYHMJdLAn9AuzvsQv/htDTK0G1AnYcVppBzI+Zrii74hk7Ew=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "685<b>.</b>632382188904744837 Ether", 
  "name": "Dice", 
  "transactions": "2025", 
  "address": "0xe8a51be86ad96447d45ddeddc55013f25157688c"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "62<b>.</b>3265429560690858 Ether", 
  "name": "Wallet", 
  "transactions": "1872", 
  "address": "0xa74569544173c98538c8f4cf5e0a1eaabcee3bb0"
 }, 
 {
  "source": "contract WavesPresale {\r\n    address public owner;\r\n    \r\n    struct Sale\r\n    {\r\n        uint amount;\r\n        uint date;\r\n    }\r\n\r\n    mapping (bytes16 => Sale) public sales;\r\n    uint32 public numberOfSales;\r\n    uint public totalTokens;\r\n\r\n    function WavesPresale() {\r\n        owner = msg.sender;\r\n        numberOfSales = 0;\r\n    }\r\n\r\n    function changeOwner(address newOwner) {\r\n        if (msg.sender != owner) return;\r\n\r\n        owner = newOwner;\r\n    }\r\n\r\n    function newSale(bytes16 txidHash, uint amount, uint timestamp) {\r\n        if (msg.sender != owner) return;\r\n\r\n        if (sales[txidHash].date == 0) {\r\n            sales[txidHash] = Sale({\r\n                    amount: amount,\r\n                    date: timestamp\r\n                });\r\n            numberOfSales += 1;\r\n            totalTokens += amount;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function getSaleDate(bytes16 txidHash) constant returns (uint, uint) {\r\n    \treturn (sales[txidHash].amount, sales[txidHash].date);\r\n    }\r\n\r\n    function () {\r\n        // This function gets executed if a\r\n        // transaction with invalid data is sent to\r\n        // the contract or just ether without data.\r\n        // We revert the send so that no-one\r\n        // accidentally loses money when using the\r\n        // contract.\r\n        throw;\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "WavesPresale", 
  "transactions": "1764", 
  "address": "0x407113f6b520f3ac72386cfb0eee9ed3930512c0"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function __callback(bytes32 myid, string result) {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32 myid, string result, bytes proof) {\r\n    }\r\n    \r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 2500; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 90; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BAPd7MVcodOtp7oRYI6q3VKlPp5hPpOeFECuC+oSY+4/npq1FVtYWRftet71WkFM7ISf9SeaEhX+T4NH0h1rJT1KXJSewrMYT1tGbKJAcF+09CXKeB0Qw27lyZ2KIdG86GpaYdp4gbuSjIkDEqWnuSe1laEAitg=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "846<b>.</b>438622645884945151 Ether", 
  "name": "Dice", 
  "transactions": "1622", 
  "address": "0xe642b6f79041c60d8447679b3a499f18d8b03b81"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 1000; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 25; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BLY3bF2NWtUYMqKj+13fIJ+rR4IzmlNAP9UM1nmbCiivwFXmm3lU86zjsIldadlHwkH9H8ephiQ/FNgEraMknyVhlceoT1WgJv3h1iP87fRK34yqARHV8p/qKoYG1RE1lJ6IKI1oUvDqCfllxkf+u9vvWN188fs=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "1585", 
  "address": "0xc3b643bb85318b6a0e1b46c30365adacdf9469c2"
 }, 
 {
  "source": "// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60)>0){\r\n            OAR = OraclizeAddrResolverI(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract mortal {\r\n    address owner;\r\n\r\n    function mortal() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function kill() {\r\n        if (msg.sender == owner) suicide(owner);\r\n    }\r\n}\r\n\r\n\r\ncontract slot is mortal, usingOraclize {\r\n    /** which oraclize ID belong to which player address?**/\r\n    mapping (bytes32 => address) players; \r\n    /** the amount of gas to be sent to oraclize**/\r\n    uint32 public oraclizeGas;\r\n    /** probabilities of the different results (absolute frequency out of 1.000.000 spins)**/\r\n    uint32[] public probabilities;\r\n    /** the prize per probability (shifted by two digits -> 375 is acutually 3.75)*/\r\n    uint32[] public prizes;\r\n    /** the amount of ether per bet **/\r\n    mapping (bytes32 => uint) bets;\r\n    /** tell the listeners the result\r\n    first value: type, second value: player address, third value: oraclize ID**/\r\n    event gameResult(uint, address);// 0-> %5; 1 -> 80%; 2 -> loss, 3->error in callback;\r\n\r\n    \r\n    /** **/\r\n    function slot() payable{\r\n        probabilities.push(4);\r\n        probabilities.push(50);\r\n        probabilities.push(200);\r\n        probabilities.push(600);\r\n        probabilities.push(1000);\r\n        probabilities.push(2000);\r\n        probabilities.push(4000);\r\n        probabilities.push(30000);\r\n        probabilities.push(90000);\r\n        prizes.push(5000);\r\n        prizes.push(2500);\r\n        prizes.push(2000);\r\n        prizes.push(1900);\r\n        prizes.push(1800);\r\n        prizes.push(1700);\r\n        prizes.push(1600);\r\n        prizes.push(1500);\r\n        prizes.push(375);\r\n        oraclizeGas = 100000;\r\n    }\r\n    \r\n    /**\r\n     * If more than 0.1 ether and less than 1 ether is sent and the contracts holds enough to pay out the player in case of a win, a random number is asked from oraclize.\r\n     * */\r\n\r\n    function() payable {\r\n        if(msg.sender!=owner){//owner should be able to send funds to the contract anytime\r\n            if(msg.value<100000000000000000||msg.value>1000000000000000000) throw;//bet has to lie between 0.1 and 1 ETH\r\n            if(address(this).balance < msg.value/100*prizes[0]) throw; //make sure the contract is able to pay out the player in case he wins\r\n            bytes32 oid = oraclize_query(\"URL\",\"https://www.random.org/integers/?num=1&min=1&max=1000000&col=1&base=10&format=plain&rnd=new\", oraclizeGas);\r\n            bets[oid] = msg.value;\r\n            players[oid] = msg.sender;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The random number from Oraclizes decides the game result.\r\n     * If Oraclize sends a message instead of the requested number, the bet is returned to the player.\r\n     * */\r\n    function __callback(bytes32 myid, string result) {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        if (players[myid]==0x0) throw;\r\n        uint random = convertToInt(result);\r\n        if(random==0){//result not a number, return bet\r\n            if(!players[myid].send(bets[myid])) throw;\r\n            gameResult(101,players[myid]);\r\n            delete players[myid];\r\n            return;\r\n        }\r\n        uint range = 0;\r\n        for(uint i = 0; i<probabilities.length; i++){\r\n            range+=probabilities[i];\r\n            if(random<=range){\r\n                if(!players[myid].send(bets[myid]/100*prizes[i])){\r\n                    gameResult(100,players[myid]);//100 -> error\r\n                    throw;\r\n                } \r\n                gameResult(i, players[myid]);\r\n                delete players[myid];\r\n                return;\r\n            }\r\n        }\r\n\r\n        //else player loses everything\r\n        gameResult(probabilities.length, players[myid]);\r\n        \r\n        delete players[myid];\r\n        \r\n    }\r\n    \r\n    /**\r\n     * sets the amount of gas to be sent to oraclize\r\n     * */\r\n    function setOraclizeGas(uint32 newGas){\r\n        if(!(msg.sender==owner)) throw;\r\n    \toraclizeGas = newGas;\r\n    }\r\n    \r\n    /** set the probabilities of the results (absolute frequencies out of 1.000.000 spins) **/\r\n    function setProbabilities(uint32[] probs){\r\n        if(!(msg.sender==owner)) throw;\r\n        probabilities=probs;\r\n    }\r\n    \r\n    /** set the prizes of the results (shifted by 2 digits -> 375 means 3.75)**/\r\n    function setPrizes(uint32[] priz){\r\n        if(!(msg.sender==owner)) throw;\r\n        prizes=priz;\r\n    }\r\n    \r\n    /**\r\n     * allows the owner to collect the accumulated losses\r\n     * */\r\n    function collectFees(uint amount){\r\n        if(!(msg.sender==owner)) throw;\r\n        if( address(this).balance < amount) throw;\r\n        if(!owner.send(amount)) throw;\r\n    }\r\n    \r\n    /**\r\n     * converts a string to an integer (there may only be digits)\r\n     * */\r\n    function convertToInt(string _a) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if((bresult[i] >= 58)&&(bresult[i] <= 126)) return 0;//its a message, no pure int\r\n        }\r\n        return mint;\r\n    }\r\n}", 
  "balance": "48<b>.</b>49739385422940522 Ether", 
  "name": "slot", 
  "transactions": "1581", 
  "address": "0x76bc9e61a1904b82cbf70d1fd9c0f8a120483bbb"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "75<b>.</b>59179922 Ether", 
  "name": "Wallet", 
  "transactions": "1530", 
  "address": "0x7907d0e8665a7f74f9418758cd001fc51830d816"
 }, 
 {
  "source": "/**\r\n * Overflow aware uint math functions.\r\n *\r\n * Inspired by https://github.com/MakerDAO/maker-otc/blob/master/contracts/simple_market.sol\r\n */\r\npragma solidity ^0.4.2;\r\n\r\ncontract SafeMath {\r\n  //internals\r\n\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\n/**\r\n * ERC 20 token\r\n *\r\n * https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n/**\r\n * ERC 20 token\r\n *\r\n * https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is Token {\r\n\r\n    /**\r\n     * Reviewed:\r\n     * - Interger overflow = OK, checked\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        //if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n}\r\n\r\n\r\n/**\r\n * Arcade City crowdsale crowdsale contract.\r\n *\r\n * Security criteria evaluated against http://ethereum.stackexchange.com/questions/8551/methodological-security-review-of-a-smart-contract\r\n *\r\n *\r\n */\r\ncontract ARCToken is StandardToken, SafeMath {\r\n\r\n    string public name = \"Arcade Token\";\r\n    string public symbol = \"ARC\";\r\n    uint public decimals = 18;\r\n    uint public startBlock; //crowdsale start block (set in constructor)\r\n    uint public endBlock; //crowdsale end block (set in constructor)\r\n\r\n    // Initial multisig address (set in constructor)\r\n    // All deposited ETH will be instantly forwarded to this address.\r\n    // Address is a multisig wallet.\r\n    address public multisig = 0x0;\r\n\r\n    address public founder = 0x0;\r\n    address public developer = 0x0;\r\n    address public rewards = 0x0;\r\n    bool public rewardAddressesSet = false;\r\n\r\n    address public owner = 0x0;\r\n    bool public marketactive = false;\r\n\r\n    uint public etherCap = 672000 * 10**18; //max amount raised during crowdsale (8.5M USD worth of ether will be measured with a moving average market price at beginning of the crowdsale)\r\n    uint public rewardsAllocation = 2; //2% tokens allocated post-crowdsale for swarm rewards\r\n    uint public developerAllocation = 6 ; //6% of token supply allocated post-crowdsale for the developer fund\r\n    uint public founderAllocation = 8; //8% of token supply allocated post-crowdsale for the founder allocation\r\n    bool public allocated = false; //this will change to true when the rewards are allocated\r\n    uint public presaleTokenSupply = 0; //this will keep track of the token supply created during the crowdsale\r\n    uint public presaleEtherRaised = 0; //this will keep track of the Ether raised during the crowdsale\r\n    bool public halted = false; //the founder address can set this to true to halt the crowdsale due to emergency\r\n    event Buy(address indexed sender, uint eth, uint fbt);\r\n\r\n    function ARCToken(address multisigInput, uint startBlockInput, uint endBlockInput) {\r\n        owner = msg.sender;\r\n        multisig = multisigInput;\r\n\r\n        startBlock = startBlockInput;\r\n        endBlock = endBlockInput;\r\n    }\r\n\r\n    function setRewardAddresses(address founderInput, address developerInput, address rewardsInput){\r\n        if (msg.sender != owner) throw;\r\n        if (rewardAddressesSet) throw;\r\n        founder = founderInput;\r\n        developer = developerInput;\r\n        rewards = rewardsInput;\r\n        rewardAddressesSet = true;\r\n    }\r\n\r\n    function price() constant returns(uint) {\r\n        return testPrice(block.number);        \r\n    }\r\n\r\n    // price() exposed for unit tests\r\n    function testPrice(uint blockNumber) constant returns(uint) {\r\n        if (blockNumber>=startBlock && blockNumber<startBlock+250) return 125; //power hour\r\n        if (blockNumber<startBlock || blockNumber>endBlock) return 75; //default price\r\n        return 75 + 4*(endBlock - blockNumber)/(endBlock - startBlock + 1)*34/4; //crowdsale price\r\n    }\r\n\r\n    /**\r\n     * Main token buy function.\r\n     *\r\n     * Security review\r\n     *\r\n     * - Integer math: ok - using SafeMath\r\n     *\r\n     * - halt flag added - ok\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test halting, buying, and failing\r\n     * - Test buying on behalf of a recipient\r\n     * - Test buy\r\n     * - Test unhalting, buying, and succeeding\r\n     * - Test buying after the sale ends\r\n     *\r\n     */\r\n    function buyRecipient(address recipient) {\r\n        if (block.number<startBlock || block.number>endBlock || safeAdd(presaleEtherRaised,msg.value)>etherCap || halted) throw;\r\n        uint tokens = safeMul(msg.value, price());\r\n        balances[recipient] = safeAdd(balances[recipient], tokens);\r\n        totalSupply = safeAdd(totalSupply, tokens);\r\n        presaleEtherRaised = safeAdd(presaleEtherRaised, msg.value);\r\n\r\n        if (!multisig.send(msg.value)) throw; //immediately send Ether to multisig address\r\n\r\n        // if etherCap is reached - activate the market\r\n        if (presaleEtherRaised == etherCap && !marketactive){\r\n            marketactive = true;\r\n        }\r\n\r\n        Buy(recipient, msg.value, tokens);\r\n\r\n    }\r\n\r\n    /**\r\n     * Set up founder address token balance.\r\n     *\r\n     * allocateBountyAndEcosystemTokens() must be calld first.\r\n     *\r\n     * Security review\r\n     *\r\n     * - Integer math: ok - only called once with fixed parameters\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test bounty and ecosystem allocation\r\n     * - Test bounty and ecosystem allocation twice\r\n     *\r\n     */\r\n    function allocateTokens() {\r\n        // make sure founder/developer/rewards addresses are configured\r\n        if(founder == 0x0 || developer == 0x0 || rewards == 0x0) throw;\r\n        // owner/founder/developer/rewards addresses can call this function\r\n        if (msg.sender != owner && msg.sender != founder && msg.sender != developer && msg.sender != rewards ) throw;\r\n        // it should only continue if endBlock has passed OR presaleEtherRaised has reached the cap\r\n        if (block.number <= endBlock && presaleEtherRaised < etherCap) throw;\r\n        if (allocated) throw;\r\n        presaleTokenSupply = totalSupply;\r\n        // total token allocations add up to 16% of total coins, so formula is reward=allocation_in_percent/84 .\r\n        balances[founder] = safeAdd(balances[founder], presaleTokenSupply * founderAllocation / 84 );\r\n        totalSupply = safeAdd(totalSupply, presaleTokenSupply * founderAllocation / 84);\r\n        \r\n        balances[developer] = safeAdd(balances[developer], presaleTokenSupply * developerAllocation / 84);\r\n        totalSupply = safeAdd(totalSupply, presaleTokenSupply * developerAllocation / 84);\r\n        \r\n        balances[rewards] = safeAdd(balances[rewards], presaleTokenSupply * rewardsAllocation / 84);\r\n        totalSupply = safeAdd(totalSupply, presaleTokenSupply * rewardsAllocation / 84);\r\n\r\n        allocated = true;\r\n\r\n    }\r\n\r\n    /**\r\n     * Emergency Stop crowdsale.\r\n     *\r\n     *  Applicable tests:\r\n     *\r\n     * - Test unhalting, buying, and succeeding\r\n     */\r\n    function halt() {\r\n        if (msg.sender!=founder && msg.sender != developer) throw;\r\n        halted = true;\r\n    }\r\n\r\n    function unhalt() {\r\n        if (msg.sender!=founder && msg.sender != developer) throw;\r\n        halted = false;\r\n    }\r\n\r\n    /**\r\n     * ERC 20 Standard Token interface transfer function\r\n     *\r\n     * Prevent transfers until token sale is over.\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test transfer after restricted period\r\n     * - Test transfer after market activated\r\n     */\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (block.number <= endBlock && marketactive == false) throw;\r\n        return super.transfer(_to, _value);\r\n    }\r\n    /**\r\n     * ERC 20 Standard Token interface transfer function\r\n     *\r\n     * Prevent transfers until token sale is over.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (block.number <= endBlock && marketactive == false) throw;\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Direct deposits buys tokens\r\n     */\r\n    function() payable {\r\n        buyRecipient(msg.sender);\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "ARCToken", 
  "transactions": "1514", 
  "address": "0xac709fcb44a43c35f0da4e3163b117a17f3770f5"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n/*\r\nThis vSlice token contract is based on the ERC20 token contract. Additional\r\nfunctionality has been integrated:\r\n* the contract Lockable, which is used as a parent of the Token contract\r\n* the function mintTokens(), which makes use of the currentSwapRate() and safeToAdd() helpers\r\n* the function disableTokenSwapLock()\r\n*/\r\n\r\ncontract Lockable {\r\n    uint public numOfCurrentEpoch;\r\n    uint public creationTime;\r\n    uint public constant UNLOCKED_TIME = 25 days;\r\n    uint public constant LOCKED_TIME = 5 days;\r\n    uint public constant EPOCH_LENGTH = 30 days;\r\n    bool public lock;\r\n    bool public tokenSwapLock;\r\n\r\n    event Locked();\r\n    event Unlocked();\r\n\r\n    // This modifier should prevent tokens transfers while the tokenswap\r\n    // is still ongoing\r\n    modifier isTokenSwapOn {\r\n        if (tokenSwapLock) throw;\r\n        _;\r\n    }\r\n\r\n    // This modifier checks and, if needed, updates the value of current\r\n    // token contract epoch, before executing a token transfer of any\r\n    // kind\r\n    modifier isNewEpoch {\r\n        if (numOfCurrentEpoch * EPOCH_LENGTH + creationTime < now ) {\r\n            numOfCurrentEpoch = (now - creationTime) / EPOCH_LENGTH + 1;\r\n        }\r\n        _;\r\n    }\r\n\r\n    // This modifier check whether the contract should be in a locked\r\n    // or unlocked state, then acts and updates accordingly if\r\n    // necessary\r\n    modifier checkLock {\r\n        if ((creationTime + numOfCurrentEpoch * UNLOCKED_TIME) +\r\n        (numOfCurrentEpoch - 1) * LOCKED_TIME < now) {\r\n            // avoids needless lock state change and event spamming\r\n            if (lock) throw;\r\n\r\n            lock = true;\r\n            Locked();\r\n            return;\r\n        }\r\n        else {\r\n            // only set to false if in a locked state, to avoid\r\n            // needless state change and event spam\r\n            if (lock) {\r\n                lock = false;\r\n                Unlocked();\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    function Lockable() {\r\n        creationTime = now;\r\n        numOfCurrentEpoch = 1;\r\n        tokenSwapLock = true;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint);\r\n    function balanceOf(address who) constant returns (uint);\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n\r\n    function transfer(address to, uint value) returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Token is ERC20, Lockable {\r\n\r\n  mapping( address => uint ) _balances;\r\n  mapping( address => mapping( address => uint ) ) _approvals;\r\n  uint _supply;\r\n  address public walletAddress;\r\n\r\n  event TokenMint(address newTokenHolder, uint amountOfTokens);\r\n  event TokenSwapOver();\r\n\r\n  modifier onlyFromWallet {\r\n      if (msg.sender != walletAddress) throw;\r\n      _;\r\n  }\r\n\r\n  function Token( uint initial_balance, address wallet) {\r\n    _balances[msg.sender] = initial_balance;\r\n    _supply = initial_balance;\r\n    walletAddress = wallet;\r\n  }\r\n\r\n  function totalSupply() constant returns (uint supply) {\r\n    return _supply;\r\n  }\r\n\r\n  function balanceOf( address who ) constant returns (uint value) {\r\n    return _balances[who];\r\n  }\r\n\r\n  function allowance(address owner, address spender) constant returns (uint _allowance) {\r\n    return _approvals[owner][spender];\r\n  }\r\n\r\n  // A helper to notify if overflow occurs\r\n  function safeToAdd(uint a, uint b) internal returns (bool) {\r\n    return (a + b >= a && a + b >= b);\r\n  }\r\n\r\n  function transfer( address to, uint value)\r\n    isTokenSwapOn\r\n    isNewEpoch\r\n    checkLock\r\n    returns (bool ok) {\r\n\r\n    if( _balances[msg.sender] < value ) {\r\n        throw;\r\n    }\r\n    if( !safeToAdd(_balances[to], value) ) {\r\n        throw;\r\n    }\r\n\r\n    _balances[msg.sender] -= value;\r\n    _balances[to] += value;\r\n    Transfer( msg.sender, to, value );\r\n    return true;\r\n  }\r\n\r\n  function transferFrom( address from, address to, uint value)\r\n    isTokenSwapOn\r\n    isNewEpoch\r\n    checkLock\r\n    returns (bool ok) {\r\n    // if you don't have enough balance, throw\r\n    if( _balances[from] < value ) {\r\n        throw;\r\n    }\r\n    // if you don't have approval, throw\r\n    if( _approvals[from][msg.sender] < value ) {\r\n        throw;\r\n    }\r\n    if( !safeToAdd(_balances[to], value) ) {\r\n        throw;\r\n    }\r\n    // transfer and return true\r\n    _approvals[from][msg.sender] -= value;\r\n    _balances[from] -= value;\r\n    _balances[to] += value;\r\n    Transfer( from, to, value );\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint value)\r\n    isTokenSwapOn\r\n    isNewEpoch\r\n    checkLock\r\n    returns (bool ok) {\r\n    _approvals[msg.sender][spender] = value;\r\n    Approval( msg.sender, spender, value );\r\n    return true;\r\n  }\r\n\r\n  // The function currentSwapRate() returns the current exchange rate\r\n  // between vSlice tokens and Ether during the token swap period\r\n  function currentSwapRate() constant returns(uint) {\r\n      if (creationTime + 1 weeks > now) {\r\n          return 130;\r\n      }\r\n      else if (creationTime + 2 weeks > now) {\r\n          return 120;\r\n      }\r\n      else if (creationTime + 4 weeks > now) {\r\n          return 100;\r\n      }\r\n      else {\r\n          return 0;\r\n      }\r\n  }\r\n\r\n  // The function mintTokens is only usable by the chosen wallet\r\n  // contract to mint a number of tokens proportional to the\r\n  // amount of ether sent to the wallet contract. The function\r\n  // can only be called during the tokenswap period\r\n  function mintTokens(address newTokenHolder, uint etherAmount)\r\n    external\r\n    onlyFromWallet {\r\n\r\n        uint tokensAmount = currentSwapRate() * etherAmount;\r\n        if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw;\r\n        if(!safeToAdd(_supply,tokensAmount)) throw;\r\n\r\n        _balances[newTokenHolder] += tokensAmount;\r\n        _supply += tokensAmount;\r\n\r\n        TokenMint(newTokenHolder, tokensAmount);\r\n  }\r\n\r\n  // The function disableTokenSwapLock() is called by the wallet\r\n  // contract once the token swap has reached its end conditions\r\n  function disableTokenSwapLock()\r\n    external\r\n    onlyFromWallet {\r\n        tokenSwapLock = false;\r\n        TokenSwapOver();\r\n  }\r\n}\r\n\r\npragma solidity ^0.4.0;\r\n\r\n/*\r\nThe standard Wallet contract, retrievable at\r\nhttps://github.com/ethereum/dapp-bin/blob/master/wallet/wallet.sol has been\r\nmodified to include additional functionality, in particular:\r\n* An additional parent of wallet contract called tokenswap, implementing almost\r\nall the changes:\r\n    - Functions for starting and stopping the tokenswap\r\n    - A set-only-once function for the token contract\r\n    - buyTokens(), which calls mintTokens() in the token contract\r\n    - Modifiers for enforcing tokenswap time limits and max ether cap\r\n* the wallet fallback function calls the buyTokens function\r\n* the wallet contract cannot selfdestruct during the tokenswap\r\n*/\r\n\r\ncontract multiowned {\r\n\r\n\t// TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n\t// EVENTS\r\n\r\n    // this contract only has six types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n\t// MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _;\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _;\r\n    }\r\n\r\n\t// METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n\r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n\r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n\r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n\r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n\r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n\r\n    // Gets an owner by 0-indexed position (using numOwners as the count)\r\n    function getOwner(uint ownerIndex) external constant returns (address) {\r\n        return address(m_owners[ownerIndex + 1]);\r\n    }\r\n\r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n\r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        return !(pending.ownersDone & ownerIndexBit == 0);\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n\r\n   \t// FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n\r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n\t// MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _;\r\n    }\r\n\r\n\t// METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // resets the amount already spent today. needs many of the owners to confirm.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\r\n        m_spentToday = 0;\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        // overflow protection                    // dailyLimit check\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n\t// FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n\t// EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address _from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n\r\n    // FUNCTIONS\r\n\r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\ncontract tokenswap is multisig, multiowned {\r\n    Token public tokenCtr;\r\n    bool public tokenSwap;\r\n    uint public constant SWAP_LENGTH = 4  weeks;\r\n    uint public constant MAX_ETH = 700000 ether;\r\n    uint public amountRaised;\r\n\r\n    modifier isZeroValue {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier isOverCap {\r\n\tif (amountRaised + msg.value > MAX_ETH) throw;\r\n        _;\r\n    }\r\n\r\n    modifier isSwapStopped {\r\n        if (!tokenSwap) throw;\r\n        _;\r\n    }\r\n\r\n    modifier areConditionsSatisfied {\r\n\t// End token swap if sale period ended\r\n\tif (tokenCtr.creationTime() + SWAP_LENGTH < now) {\r\n            tokenCtr.disableTokenSwapLock();\r\n            tokenSwap = false;\r\n        }\r\n        else {\r\n            _;\r\n\t        // Check if cap has been reached in this tx\r\n            if (amountRaised == MAX_ETH) {\r\n                tokenCtr.disableTokenSwapLock();\r\n                tokenSwap = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function safeToAdd(uint a, uint b) internal returns (bool) {\r\n      return (a + b >= a && a + b >= b);\r\n    }\r\n\r\n    function startTokenSwap() onlyowner {\r\n        tokenSwap = true;\r\n    }\r\n\r\n    function stopTokenSwap() onlyowner {\r\n        tokenSwap = false;\r\n    }\r\n\r\n    function setTokenContract(address newTokenContractAddr) onlyowner {\r\n        if (newTokenContractAddr == address(0x0)) throw;\r\n        // Allow setting only once\r\n        if (tokenCtr != address(0x0)) throw;\r\n\r\n        tokenCtr = Token(newTokenContractAddr);\r\n    }\r\n\r\n    function buyTokens(address _beneficiary)\r\n    payable\r\n    isZeroValue\r\n    isOverCap\r\n    isSwapStopped\r\n    areConditionsSatisfied {\r\n        Deposit(msg.sender, msg.value);\r\n        tokenCtr.mintTokens(_beneficiary, msg.value);\r\n        if (!safeToAdd(amountRaised, msg.value)) throw;\r\n        amountRaised += msg.value;\r\n    }\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit, tokenswap {\r\n\r\n\t// TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n\r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data)) external {\r\n        //ensure owners can't prematurely stop token sale\r\n        //and then render tokens untradable, as without this\r\n        //check, the tokenSwapLock would never get disiabled\r\n        //if this fires\r\n        if (tokenCtr.tokenSwapLock()) throw;\r\n\r\n        suicide(_to);\r\n    }\r\n\r\n    // gets called when no other function matches\r\n    function()\r\n    payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // Disallow the wallet contract from calling token contract once it's set\r\n        // so tokens can't be minted arbitrarily once the sale starts.\r\n        // Tokens can be minted for premine before the sale opens and tokenCtr is set.\r\n        if (_to == address(tokenCtr)) throw;\r\n\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            if(!_to.call.value(_value)(_data))\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n\r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n\t// FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "176,334<b>.</b>446052786849213317 Ether", 
  "name": "Wallet", 
  "transactions": "1451", 
  "address": "0x8bccc9ba2e5706e24a36dda02ca2a846e39a7bbf"
 }, 
 {
  "source": "/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n*/\r\n\r\ncontract AmIOnTheFork{\r\n    function forked() constant returns(bool);\r\n}\r\n\r\n\r\ncontract Oraclize {\r\n    mapping (address => uint) reqc;\r\n    \r\n    address public cbAddress = 0x26588a9301b0428d95e6fc3a5024fce8bec12d51;\r\n    \r\n    address constant AmIOnTheForkAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;\r\n    \r\n    event Log1(address sender, bytes32 cid, uint timestamp, string datasource, string arg, uint gaslimit, byte proofType, uint gasPrice);\r\n    event Log2(address sender, bytes32 cid, uint timestamp, string datasource, string arg1, string arg2, uint gaslimit, byte proofType, uint gasPrice);\r\n    \r\n    address owner;\r\n    \r\n    modifier onlyadmin {\r\n        if ((msg.sender != owner)&&(msg.sender != cbAddress)) throw;\r\n        _\r\n    }\r\n    \r\n    function addDSource(string dsname, uint multiplier) {\r\n        addDSource(dsname, 0x00, multiplier);\r\n    }\r\n    \r\n    function addDSource(string dsname, byte proofType, uint multiplier) onlyadmin {\r\n        bytes32 dsname_hash = sha3(dsname, proofType);\r\n        dsources[dsources.length++] = dsname_hash;\r\n        price_multiplier[dsname_hash] = multiplier;\r\n    }\r\n\r\n    mapping (bytes32 => bool) coupons;\r\n    bytes32 coupon;\r\n    \r\n    function createCoupon(string _code) onlyadmin {\r\n        coupons[sha3(_code)] = true;\r\n    }\r\n    \r\n    function deleteCoupon(string _code) onlyadmin {\r\n        coupons[sha3(_code)] = false;\r\n    }\r\n    \r\n    function multisetProofType(uint[] _proofType, address[] _addr) onlyadmin {\r\n        for (uint i=0; i<_addr.length; i++) addr_proofType[_addr[i]] = byte(_proofType[i]);\r\n    }\r\n    \r\n    function multisetCustomGasPrice(uint[] _gasPrice, address[] _addr) onlyadmin {\r\n        for (uint i=0; i<_addr.length; i++) addr_gasPrice[_addr[i]] = _gasPrice[i];\r\n    }\r\n\r\n    uint gasprice = 20000000000;\r\n    \r\n    function setGasPrice(uint newgasprice) onlyadmin {\r\n        gasprice = newgasprice;\r\n    }\r\n    \r\n    function setBasePrice(uint new_baseprice) onlyadmin { //0.001 usd in ether\r\n        baseprice = new_baseprice;\r\n        for (uint i=0; i<dsources.length; i++) price[dsources[i]] = new_baseprice*price_multiplier[dsources[i]];\r\n    }\r\n\r\n    function setBasePrice(uint new_baseprice, bytes proofID) onlyadmin { //0.001 usd in ether\r\n        baseprice = new_baseprice;\r\n        for (uint i=0; i<dsources.length; i++) price[dsources[i]] = new_baseprice*price_multiplier[dsources[i]];\r\n    }\r\n    \r\n    function withdrawFunds(address _addr) onlyadmin {\r\n        _addr.send(this.balance);\r\n    }\r\n    \r\n    function() onlyadmin {}\r\n    \r\n    function Oraclize() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier costs(string datasource, uint gaslimit) {\r\n        uint price = getPrice(datasource, gaslimit, msg.sender);\r\n        if (msg.value >= price){\r\n            uint diff = msg.value - price;\r\n            if (diff > 0) msg.sender.send(diff);\r\n            _\r\n        } else throw;\r\n    }\r\n\r\n    mapping (address => byte) addr_proofType;\r\n    mapping (address => uint) addr_gasPrice;\r\n    uint public baseprice;\r\n    mapping (bytes32 => uint) price;\r\n    mapping (bytes32 => uint) price_multiplier;\r\n    bytes32[] dsources;\r\n    function useCoupon(string _coupon) {\r\n        coupon = sha3(_coupon);\r\n    }\r\n    \r\n    function setProofType(byte _proofType) {\r\n        addr_proofType[msg.sender] = _proofType;\r\n    }\r\n    \r\n    function setCustomGasPrice(uint _gasPrice) {\r\n        addr_gasPrice[msg.sender] = _gasPrice;\r\n    }\r\n    \r\n    function getPrice(string _datasource) public returns (uint _dsprice) {\r\n        return getPrice(_datasource, msg.sender);\r\n    }\r\n    \r\n    function getPrice(string _datasource, uint _gaslimit) public returns (uint _dsprice) {\r\n        return getPrice(_datasource, _gaslimit, msg.sender);\r\n    }\r\n    \r\n    function getPrice(string _datasource, address _addr) private returns (uint _dsprice) {\r\n        return getPrice(_datasource, 200000, _addr);\r\n    }\r\n    \r\n    function getPrice(string _datasource, uint _gaslimit, address _addr) private returns (uint _dsprice) {\r\n        if ((_gaslimit <= 200000)&&(reqc[_addr] == 0)&&(tx.origin != cbAddress)) return 0;\r\n        if ((coupon != 0)&&(coupons[coupon] == true)) return 0;\r\n        _dsprice = price[sha3(_datasource, addr_proofType[_addr])];\r\n        uint gasprice_ = addr_gasPrice[_addr];\r\n        if (gasprice_ == 0) gasprice_ = gasprice; \r\n        _dsprice += _gaslimit*gasprice_;\r\n        return _dsprice;\r\n    }\r\n    \r\n    function query(string _datasource, string _arg) returns (bytes32 _id) {\r\n        return query1(0, _datasource, _arg, 200000);\r\n    }\r\n    \r\n    function query1(string _datasource, string _arg) returns (bytes32 _id) {\r\n        return query1(0, _datasource, _arg, 200000);\r\n    }\r\n    \r\n    function query2(string _datasource, string _arg1, string _arg2) returns (bytes32 _id) {\r\n        return query2(0, _datasource, _arg1, _arg2, 200000);\r\n    }\r\n    \r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id) {\r\n        return query1(_timestamp, _datasource, _arg, 200000);\r\n    }\r\n    \r\n    function query1(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id) {\r\n        return query1(_timestamp, _datasource, _arg, 200000);\r\n    }\r\n    \r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id) {\r\n        return query2(_timestamp, _datasource, _arg1, _arg2, 200000);\r\n    }\r\n    \r\n    function query(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id) {\r\n        return query1(_timestamp, _datasource, _arg, _gaslimit);\r\n    }\r\n    \r\n    function query1(uint _timestamp, string _datasource, string _arg, uint _gaslimit) costs(_datasource, _gaslimit) returns (bytes32 _id) {\r\n\tif ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)) throw;\r\n\tbool forkFlag = AmIOnTheFork(AmIOnTheForkAddress).forked();\r\n        _id = sha3(forkFlag, this, msg.sender, reqc[msg.sender]);\r\n        reqc[msg.sender]++;\r\n        Log1(msg.sender, _id, _timestamp, _datasource, _arg, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\r\n        return _id;\r\n    }\r\n    \r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) costs(_datasource, _gaslimit) returns (bytes32 _id) {\r\n\tif ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)) throw;\r\n\tbool forkFlag = AmIOnTheFork(AmIOnTheForkAddress).forked();\r\n        _id = sha3(forkFlag, this, msg.sender, reqc[msg.sender]);\r\n        reqc[msg.sender]++;\r\n        Log2(msg.sender, _id, _timestamp, _datasource, _arg1, _arg2, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\r\n        return _id;\r\n    }\r\n    \r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id) {\r\n        return query(_timestamp, _datasource, _arg, _gaslimit);\r\n    }\r\n    \r\n    function query1_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id) {\r\n        return query1(_timestamp, _datasource, _arg, _gaslimit);\r\n    }\r\n    \r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id) {\r\n        return query2(_timestamp, _datasource, _arg1, _arg2, _gaslimit);\r\n    }\r\n}", 
  "balance": "117<b>.</b>58319419882243611 Ether", 
  "name": "Oraclize", 
  "transactions": "1439", 
  "address": "0x001a589dda0d6be37632925eaf1256986b2c6ad0"
 }, 
 {
  "source": "pragma solidity ^0.4.2;\r\n\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Constant {\r\n    function totalSupply() constant returns (uint supply);\r\n    function balanceOf( address who ) constant returns (uint value);\r\n    function allowance(address owner, address spender) constant returns (uint _allowance);\r\n}\r\ncontract ERC20Stateful {\r\n    function transfer( address to, uint value) returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n}\r\ncontract ERC20Events {\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}\r\n\r\ncontract Assertive {\r\n    function assert(bool assertion) internal {\r\n        if (!assertion) throw;\r\n    }\r\n}\r\n\r\ncontract FallbackFailer {\r\n  function () {\r\n    throw;\r\n  }\r\n}\r\n\r\ncontract MutexUser {\r\n    bool private lock;\r\n    modifier exclusive {\r\n        if (lock) throw;\r\n        lock = true;\r\n        _;\r\n        lock = false;\r\n    }\r\n}\r\n\r\n// A simple direct exchange order manager.\r\n\r\ncontract EventfulMarket {\r\n    event ItemUpdate( uint id );\r\n    event Trade( uint sell_how_much, address indexed sell_which_token,\r\n                 uint buy_how_much, address indexed buy_which_token );\r\n}\r\n\r\ncontract SimpleMarket is EventfulMarket\r\n                       , Assertive\r\n                       , FallbackFailer\r\n                       , MutexUser\r\n{\r\n    struct OfferInfo {\r\n        uint sell_how_much;\r\n        ERC20 sell_which_token;\r\n        uint buy_how_much;\r\n        ERC20 buy_which_token;\r\n        address owner;\r\n        bool active;\r\n    }\r\n    mapping( uint => OfferInfo ) public offers;\r\n\r\n    uint public last_offer_id;\r\n\r\n    function next_id() internal returns (uint) {\r\n        last_offer_id++; return last_offer_id;\r\n    }\r\n\r\n    modifier can_offer {\r\n        _;\r\n    }\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        _;\r\n    }\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(getOwner(id) == msg.sender);\r\n        _;\r\n    }\r\n    function isActive(uint id) constant returns (bool active) {\r\n        return offers[id].active;\r\n    }\r\n    function getOwner(uint id) constant returns (address owner) {\r\n        return offers[id].owner;\r\n    }\r\n    function getOffer( uint id ) constant returns (uint, ERC20, uint, ERC20) {\r\n      var offer = offers[id];\r\n      return (offer.sell_how_much, offer.sell_which_token,\r\n              offer.buy_how_much, offer.buy_which_token);\r\n    }\r\n\r\n    // non underflowing subtraction\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    // non overflowing multiplication\r\n    function safeMul(uint a, uint b) internal returns (uint c) {\r\n        c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n    }\r\n\r\n    function trade( address seller, uint sell_how_much, ERC20 sell_which_token,\r\n                    address buyer,  uint buy_how_much,  ERC20 buy_which_token )\r\n        internal\r\n    {\r\n        var seller_paid_out = buy_which_token.transferFrom( buyer, seller, buy_how_much );\r\n        assert(seller_paid_out);\r\n        var buyer_paid_out = sell_which_token.transfer( buyer, sell_how_much );\r\n        assert(buyer_paid_out);\r\n        Trade( sell_how_much, sell_which_token, buy_how_much, buy_which_token );\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer( uint sell_how_much, ERC20 sell_which_token\r\n                  , uint buy_how_much,  ERC20 buy_which_token )\r\n        can_offer\r\n        exclusive\r\n        returns (uint id)\r\n    {\r\n        assert(sell_how_much > 0);\r\n        assert(sell_which_token != ERC20(0x0));\r\n        assert(buy_how_much > 0);\r\n        assert(buy_which_token != ERC20(0x0));\r\n        assert(sell_which_token != buy_which_token);\r\n\r\n        OfferInfo memory info;\r\n        info.sell_how_much = sell_how_much;\r\n        info.sell_which_token = sell_which_token;\r\n        info.buy_how_much = buy_how_much;\r\n        info.buy_which_token = buy_which_token;\r\n        info.owner = msg.sender;\r\n        info.active = true;\r\n        id = next_id();\r\n        offers[id] = info;\r\n\r\n        var seller_paid = sell_which_token.transferFrom( msg.sender, this, sell_how_much );\r\n        assert(seller_paid);\r\n\r\n        ItemUpdate(id);\r\n    }\r\n    // Accept given `quantity` of an offer. Transfers funds from caller to\r\n    // offer maker, and from market to caller.\r\n    function buy( uint id, uint quantity )\r\n        can_buy(id)\r\n        exclusive\r\n        returns ( bool success )\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n\r\n        // inferred quantity that the buyer wishes to spend\r\n        uint spend = safeMul(quantity, offer.buy_how_much) / offer.sell_how_much;\r\n\r\n        if ( spend > offer.buy_how_much || quantity > offer.sell_how_much ) {\r\n            // buyer wants more than is available\r\n            success = false;\r\n        } else if ( spend == offer.buy_how_much && quantity == offer.sell_how_much ) {\r\n            // buyer wants exactly what is available\r\n            delete offers[id];\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                   msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            success = true;\r\n        } else if ( spend > 0 && quantity > 0 ) {\r\n            // buyer wants a fraction of what is available\r\n            offers[id].sell_how_much = safeSub(offer.sell_how_much, quantity);\r\n            offers[id].buy_how_much = safeSub(offer.buy_how_much, spend);\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                    msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            success = true;\r\n        } else {\r\n            // buyer wants an unsatisfiable amount (less than 1 integer)\r\n            success = false;\r\n        }\r\n    }\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel( uint id )\r\n        can_cancel(id)\r\n        exclusive\r\n        returns ( bool success )\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n        delete offers[id];\r\n\r\n        var seller_refunded = offer.sell_which_token.transfer( offer.owner , offer.sell_how_much );\r\n        assert(seller_refunded);\r\n\r\n        ItemUpdate(id);\r\n        success = true;\r\n    }\r\n}\r\n\r\n// Simple Market with a market lifetime. When the lifetime has elapsed,\r\n// offers can only be cancelled (offer and buy will throw).\r\n\r\ncontract ExpiringMarket is SimpleMarket {\r\n    uint public close_time;\r\n    function ExpiringMarket(uint lifetime) {\r\n        close_time = getTime() + lifetime;\r\n    }\r\n    function getTime() constant returns (uint) {\r\n        return block.timestamp;\r\n    }\r\n    function isClosed() constant returns (bool closed) {\r\n        return (getTime() > close_time);\r\n    }\r\n\r\n    // after market lifetime has elapsed, no new offers are allowed\r\n    modifier can_offer {\r\n        assert(!isClosed());\r\n        _;\r\n    }\r\n    // after close, no new buys are allowed\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        assert(!isClosed());\r\n        _;\r\n    }\r\n    // after close, anyone can cancel an offer\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(isClosed() || (msg.sender == getOwner(id)));\r\n        _;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ExpiringMarket", 
  "transactions": "1395", 
  "address": "0x1292714f89f535c066d483e92a54b360f3df7589"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "0 Ether", 
  "name": "Wallet", 
  "transactions": "1368", 
  "address": "0xb6fe398f94406c298c5cca9efc3670994c0ad409"
 }, 
 {
  "source": "//                       , ; ,   .-'\"\"\"'-.   , ; ,\r\n//                       \\\\|/  .'          '.  \\|//\r\n//                        \\-;-/   ()   ()   \\-;-/\r\n//                        // ;               ; \\\\\r\n//                       //__; :.         .; ;__\\\\\r\n//                      `-----\\'.'-.....-'.'/-----'\r\n//                             '.'.-.-,_.'.'\r\n//                               '(  (..-'\r\n//                                 '-'\r\n//   WHYSOS3RIOUS   PRESENTS :   \r\n//   The ROULETH \r\n//\r\n//  Play the Roulette on ethereum blockchain !\r\n//  (or become an investor in the Casino and share the profits/losses.) \r\n//\r\n//\r\n//   Full GUI on website with all info to play : \r\n//                   \r\n//                  www.Rouleth.com\r\n//\r\n//\r\n//   All documentation on playing and investing are on the website.\r\n//\r\n//   News : www.reddit.com/r/Rouleth\r\n//   twitter : https://twitter.com/TheRouleth\r\n//\r\n//   Github : https://github.com/Bunjin/Rouleth\r\n//\r\n//   check latest contract version on website\r\n//   V 1.2\r\n//\r\n// *** coded by WhySoS3rious, 2016.                                       ***//\r\n// *** please do not copy without authorization                          ***//\r\n// *** contact : reddit    /u/WhySoS3rious                               ***//\r\n//\r\n//\r\n//  Stake : Variable, check on website for the max bet.\r\n\r\ncontract Rouleth\r\n{\r\n\r\n    //Variables, Structure\r\n    address developer;\r\n    uint8 blockDelay; //nb of blocks to wait before spin\r\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\r\n    uint256 maxGamble; //max gamble value manually set by config\r\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\r\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\r\n    uint casinoStatisticalLimit;\r\n    //Current gamble value possibly lower than config (<payroll/(casinoStatisticalLimit*35))\r\n    uint256 currentMaxGamble; \r\n    //Gambles\r\n    enum BetTypes{number, color, parity, dozen, column, lowhigh} \r\n    struct Gamble\r\n    {\r\n\taddress player;\r\n        bool spinned; //Was the rouleth spinned ?\r\n\tbool win;\r\n\t//Possible bet types\r\n        BetTypes betType;\r\n\tuint8 input; //stores number, color, dozen or oddeven\r\n\tuint256 wager;\r\n\tuint256 blockNumber; //block of bet -1\r\n        uint8 wheelResult;\r\n    }\r\n    Gamble[] private gambles;\r\n    uint firstActiveGamble; //pointer to track the first non spinned and non expired gamble.\r\n    //Tracking progress of players\r\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\r\n    enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; //records current status of player\r\n\r\n    //**********************************************\r\n    //        Management & Config FUNCTIONS        //\r\n    //**********************************************\r\n    function  Rouleth() private //creation settings\r\n    { \r\n        developer = msg.sender;\r\n        blockDelay=2; //delay to wait between bet and spin\r\n\tblockExpiration=200; //delay after which gamble expires\r\n        maxGamble=500 finney; //configurable max bet\r\n        maxBetsPerBlock=5; // limit of bets per block, to prevent multiple bets per miners\r\n        casinoStatisticalLimit=20;\r\n    }\r\n\t\r\n    modifier onlyDeveloper() \r\n    {\r\n\tif (msg.sender!=developer) throw;\r\n\t_\r\n    }\r\n\t\r\n    function changeDeveloper(address new_dev)\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\tdeveloper=new_dev;\r\n    }\r\n\r\n\r\n    //Activate, Deactivate Betting\r\n    enum States{active, inactive} States private state;\r\n\t\r\n    function disableBetting()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        state=States.inactive;\r\n    }\r\n    function enableBetting()\r\n    onlyDeveloper\r\n    noEthSent\r\n    {\r\n        state=States.active;\r\n    }\r\n    \r\n    modifier onlyActive\r\n    {\r\n        if (state==States.inactive) throw;\r\n        _\r\n    }\r\n\r\n    //Change some settings within safety bounds\r\n    function changeSettings(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMaxGamble, uint8 newMaxInvestor, uint256 newMinInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\r\n    noEthSent\r\n    onlyDeveloper\r\n\t{\r\n\t        // changes the statistical multiplier that guarantees the long run casino survival\r\n\t        if (newCasinoStatLimit<10) throw;\r\n\t        casinoStatisticalLimit=newCasinoStatLimit;\r\n\t        //Max number of bets per block to prevent miner cheating\r\n\t        maxBetsPerBlock=newMaxBetsBlock;\r\n                //MAX BET : limited by payroll/(casinoStatisticalLimit*35) for statiscal confidence in longevity of casino\r\n\t\tif (newMaxGamble<=0) throw; \r\n\t\telse { maxGamble=newMaxGamble; }\r\n                //MAX NB of INVESTORS (can only increase and max of 149)\r\n                if (newMaxInvestor<setting_maxInvestors || newMaxInvestor>149) throw;\r\n                else { setting_maxInvestors=newMaxInvestor;}\r\n                //MIN INVEST : \r\n                setting_minInvestment=newMinInvestment;\r\n                //Invest LOCK PERIOD\r\n                if (setting_lockPeriod>90 days) throw; //3 months max\r\n                setting_lockPeriod=newLockPeriod;\r\n\t\t//Delay before roll :\r\n\t\tif (blockDelay<1) throw;\r\n\t\tblockDelay=newBlockDelay;\r\n                updateMaxBet();\r\n\t\tif (newBlockExpiration<50) throw;\r\n\t\tblockExpiration=newBlockExpiration;\r\n\t}\r\n \r\n\r\n    //**********************************************\r\n    //                 BETTING FUNCTIONS                    //\r\n    //**********************************************\r\n\r\n//***//basic betting without Mist or contract call\r\n    //activates when the player only sends eth to the contract\r\n    //without specifying any type of bet.\r\n    function () \r\n   {\r\n       //if player is not playing : bet on Red\r\n       if (playerStatus[msg.sender]==Status.waitingForBet)  betOnColor(true,false);\r\n       //if player is already playing, spin the wheel\r\n       else spinTheWheel();\r\n    } \r\n\r\n    function updateMaxBet() private\r\n    {\r\n    //check that maxGamble setting is still within safety bounds\r\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \r\n\t\t{ \r\n\t\t\tcurrentMaxGamble=maxGamble;\r\n                }\r\n\telse\r\n\t\t{ \r\n\t\t\tcurrentMaxGamble = payroll/(casinoStatisticalLimit*35);\r\n\t\t}\r\n     }\r\n\r\n//***//Guarantees that gamble is under (statistical) safety limits for casino survival.\r\n    function checkBetValue() private returns(uint256 playerBetValue)\r\n    {\r\n        updateMaxBet();\r\n\t\tif (msg.value > currentMaxGamble) //if above max, send difference back\r\n\t\t{\r\n\t\t\tif (msg.sender.send(msg.value-currentMaxGamble)==false) throw;\r\n\t\t    playerBetValue=currentMaxGamble;\r\n\t\t}\r\n                else\r\n                { playerBetValue=msg.value; }\r\n         return;\r\n       }\r\n\r\n\r\n    //check number of bets in block (to prevent miner cheating)\r\n    modifier checkNbBetsCurrentBlock()\r\n    {\r\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\r\n        else nbBetsCurrentBlock=0;\r\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\r\n        _\r\n    }\r\n    //check that the player is not playing already (unless it has expired)\r\n    modifier checkWaitingForBet{\r\n        //if player is already in gamble\r\n        if (playerStatus[msg.sender]!=Status.waitingForBet)\r\n        {\r\n             //case not expired\r\n             if (gambles[gambleIndex[msg.sender]].blockNumber+blockExpiration>block.number) throw;\r\n             //case expired\r\n             else\r\n             {\r\n                  //add bet to PL and reset status\r\n                  solveBet(msg.sender, 255, false, 0) ;\r\n\r\n              }\r\n        }\r\n\t_\r\n\t}\r\n\r\n    function updateStatusPlayer() private\r\n    expireGambles\r\n    {\r\n\tplayerStatus[msg.sender]=Status.waitingForSpin;\r\n\tgambleIndex[msg.sender]=gambles.length;\r\n     }\r\n\r\n//***//bet on Number\t\r\n    function betOnNumber(uint8 numberChosen)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        updateStatusPlayer();\r\n        //check that number chosen is valid and records bet\r\n        if (numberChosen>36) throw;\r\n        //adapts wager to casino limits\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.number, numberChosen, betValue, block.number, 37));\r\n    }\r\n\r\n//***// function betOnColor\r\n\t//bet type : color\r\n\t//input : 0 for red\r\n\t//input : 1 for black\r\n    function betOnColor(bool Red, bool Black)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        updateStatusPlayer();\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Red) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Black) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.color, input, betValue, block.number, 37));\r\n    }\r\n\r\n//***// function betOnLow_High\r\n\t//bet type : lowhigh\r\n\t//input : 0 for low\r\n\t//input : 1 for low\r\n    function betOnLowHigh(bool Low, bool High)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        updateStatusPlayer();\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Low) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (High) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.lowhigh, input, betValue, block.number, 37));\r\n    }\r\n\r\n//***// function betOnOdd_Even\r\n\t//bet type : parity\r\n     //input : 0 for even\r\n    //input : 1 for odd\r\n    function betOnOddEven(bool Odd, bool Even)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        updateStatusPlayer();\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Even) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Odd) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.parity, input, betValue, block.number, 37));\r\n    }\r\n\r\n\r\n//***// function betOnDozen\r\n//     //bet type : dozen\r\n//     //input : 0 for first dozen\r\n//     //input : 1 for second dozen\r\n//     //input : 2 for third dozen\r\n    function betOnDozen(bool First, bool Second, bool Third)\r\n    {\r\n         betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\r\n    }\r\n\r\n\r\n// //***// function betOnColumn\r\n//     //bet type : column\r\n//     //input : 0 for first column\r\n//     //input : 1 for second column\r\n//     //input : 2 for third column\r\n    function betOnColumn(bool First, bool Second, bool Third)\r\n    {\r\n         betOnColumnOrDozen(First, Second, Third, BetTypes.column);\r\n     }\r\n\r\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    { \r\n        updateStatusPlayer();\r\n        uint8 count;\r\n        uint8 input;\r\n        if (First) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Second) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (Third) \r\n        {\r\n             count+=1; \r\n             input=2;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, bet, input, betValue, block.number, 37));\r\n    }\r\n\r\n    //**********************************************\r\n    // Spin The Wheel & Check Result FUNCTIONS//\r\n    //**********************************************\r\n\r\n\tevent Win(address player, uint8 result, uint value_won);\r\n\tevent Loss(address player, uint8 result, uint value_loss);\r\n\r\n    //check that player has to spin the wheel\r\n    modifier checkWaitingForSpin{\r\n        if (playerStatus[msg.sender]!=Status.waitingForSpin) throw;\r\n\t_\r\n\t}\r\n    //Prevents accidental sending of Eth when you shouldn't\r\n    modifier noEthSent()\r\n    {\r\n        if (msg.value>0) \r\n\t\t{\r\n\t\t\t\tif (msg.sender.send(msg.value)==false) throw;\r\n\t\t}\r\n        _\r\n    }\r\n\r\n//***//function to spin\r\n    function spinTheWheel()\r\n    noEthSent\r\n    checkWaitingForSpin\r\n    {\r\n        //check that the player waited for the delay before spin\r\n        //and also that the bet is not expired\r\n\tuint playerblock = gambles[gambleIndex[msg.sender]].blockNumber;\r\n\tif (block.number<playerblock+blockDelay || block.number>playerblock+blockExpiration) throw;\r\n        else\r\n\t{\r\n\t    uint8 wheelResult;\r\n            //Spin the wheel, Reset player status and record result\r\n\t    wheelResult = uint8(uint256(block.blockhash(playerblock+blockDelay))%37);\r\n\t    gambles[gambleIndex[msg.sender]].wheelResult=wheelResult;\r\n            //check result against bet and pay if win\r\n\t    checkBetResult(wheelResult, gambles[gambleIndex[msg.sender]].betType);\r\n\t    updateFirstActiveGamble();\r\n\t}\r\n    }\r\n\r\n//update pointer of first gamble not spinned\r\nfunction updateFirstActiveGamble() private\r\n     {\r\n              for (uint k=firstActiveGamble; k<=firstActiveGamble+50; k++) \r\n              //limit the update to 50 to cap the gas cost and share the work among users\r\n              {\r\n                 if (k>=gambles.length || !gambles[k].spinned)\r\n                 {\r\n                    firstActiveGamble=k;\r\n                    break; \r\n                 }\r\n              }\r\n }\r\n\t\r\n//checks if there are expired gambles\r\nmodifier expireGambles{\r\n    if (  gambles.length!=0 && gambles.length-1>=firstActiveGamble \r\n          && gambles[firstActiveGamble].blockNumber + blockExpiration <= block.number \r\n          && !gambles[firstActiveGamble].spinned )  \r\n    { \r\n\tsolveBet(gambles[firstActiveGamble].player, 255, false, 0); //expires\r\n    }\r\n        updateFirstActiveGamble(); //update pointer\r\n        _\r\n}\r\n\t\r\n\r\n     //CHECK BETS FUNCTIONS private\r\n     function checkBetResult(uint8 result, BetTypes betType) private\r\n     {\r\n          //bet on Number\r\n          if (betType==BetTypes.number) checkBetNumber(result);\r\n          else if (betType==BetTypes.parity) checkBetParity(result);\r\n          else if (betType==BetTypes.color) checkBetColor(result);\r\n\t else if (betType==BetTypes.lowhigh) checkBetLowhigh(result);\r\n\t else if (betType==BetTypes.dozen) checkBetDozen(result);\r\n\telse if (betType==BetTypes.column) checkBetColumn(result);\r\n          updateMaxBet(); \r\n     }\r\n\r\n     // function solve Bet once result is determined : sends to winner, adds loss to profit\r\n     function solveBet(address player, uint8 result, bool win, uint8 multiplier) private\r\n     {\r\n        playerStatus[player]=Status.waitingForBet;\r\n        gambles[gambleIndex[player]].spinned=true;\r\n\tuint bet_v = gambles[gambleIndex[player]].wager;\r\n            if (win)\r\n            {\r\n                  if (player!=gambles[gambleIndex[player]].player) throw; //security failcheck\r\n\t\t  gambles[gambleIndex[player]].win=true;\r\n\t\t  uint win_v = multiplier*bet_v;\r\n                  lossSinceChange+=win_v-bet_v;\r\n\t\t  Win(player, result, win_v);\r\n\t\t\t\tif (player.send(win_v)==false) throw;\r\n             }\r\n            else\r\n            {\r\n\t\tLoss(player, result, bet_v);\r\n                profitSinceChange+=bet_v;\r\n            }\r\n\r\n      }\r\n\r\n\r\n     // checkbeton number(input)\r\n    // bet type : number\r\n    // input : chosen number\r\n     function checkBetNumber(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t    if (result==gambles[gambleIndex[msg.sender]].input)\r\n\t    {\r\n                  win=true;  \r\n             }\r\n             solveBet(msg.sender, result,win,36);\r\n     }\r\n\r\n\r\n     // checkbet on oddeven\r\n    // bet type : parity\r\n    // input : 0 for even, 1 for odd\r\n     function checkBetParity(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t    if (result%2==gambles[gambleIndex[msg.sender]].input && result!=0)\r\n\t    {\r\n                  win=true;                \r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n        \r\n     }\r\n\t\r\n     // checkbet on lowhigh\r\n     // bet type : lowhigh\r\n     // input : 0 low, 1 high\r\n     function checkBetLowhigh(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t\t if (result!=0 && ( (result<19 && gambles[gambleIndex[msg.sender]].input==0)\r\n\t\t\t || (result>18 && gambles[gambleIndex[msg.sender]].input==1)\r\n\t\t\t ) )\r\n\t    {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n     }\r\n\r\n     // checkbet on color\r\n     // bet type : color\r\n     // input : 0 red, 1 black\r\n      uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\r\n      function checkBetColor(uint8 result) private\r\n      {\r\n             bool red;\r\n             //check if red\r\n             for (uint8 k; k<18; k++)\r\n             { \r\n                    if (red_list[k]==result) \r\n                    { \r\n                          red=true; \r\n                          break;\r\n                    }\r\n             }\r\n             bool win;\r\n             //win\r\n             if ( result!=0\r\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && red)  \r\n                || ( gambles[gambleIndex[msg.sender]].input==1 && !red)  ) )\r\n             {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n       }\r\n\r\n     // checkbet on dozen\r\n     // bet type : dozen\r\n     // input : 0 first, 1 second, 2 third\r\n     function checkBetDozen(uint8 result) private\r\n     { \r\n            bool win;\r\n            //win on first dozen\r\n     \t\t if ( result!=0 &&\r\n                      ( (result<13 && gambles[gambleIndex[msg.sender]].input==0)\r\n     \t\t\t||\r\n                     (result>12 && result<25 && gambles[gambleIndex[msg.sender]].input==1)\r\n                    ||\r\n                     (result>24 && gambles[gambleIndex[msg.sender]].input==2) ) )\r\n     \t    {\r\n                   win=true;                \r\n             }\r\n             solveBet(msg.sender,result,win,3);\r\n     }\r\n\r\n     // checkbet on column\r\n     // bet type : column\r\n     // input : 0 first, 1 second, 2 third\r\n      function checkBetColumn(uint8 result) private\r\n      {\r\n             bool win;\r\n             //win\r\n             if ( result!=0\r\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && result%3==1)  \r\n                || ( gambles[gambleIndex[msg.sender]].input==1 && result%3==2)\r\n                || ( gambles[gambleIndex[msg.sender]].input==2 && result%3==0)  ) )\r\n             {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,3);\r\n      }\r\n\r\n\r\n//INVESTORS FUNCTIONS\r\n\r\n\r\n//total casino payroll\r\n    uint256 payroll;\r\n//Profit Loss since last investor change\r\n    uint256 profitSinceChange;\r\n    uint256 lossSinceChange;\r\n//investor struct array (hard capped to 150)\r\n    uint8 setting_maxInvestors = 50;\r\n    struct Investor\r\n    {\r\n\t    address investor;\r\n\t    uint256 time;\r\n    }\t\r\n\t\r\n    Investor[250] private investors ;\r\n    //Balances of the investors\r\n    mapping (address=>uint256) balance; \r\n    //Investor lockPeriod\r\n    //lock time to avoid invest and withdraw for refresh only\r\n    //also time during which you cannot be outbet by a new investor if it is full\r\n    uint256 setting_lockPeriod=30 days ;\r\n    uint256 setting_minInvestment=10 ether; //min amount to send when using invest()\r\n    //if full and unlocked position, indicates the cheapest amount to outbid\r\n    //otherwise cheapestUnlockedPosition=255\r\n    uint8 cheapestUnlockedPosition; \r\n    uint256 minCurrentInvest; \r\n    //record open position index\r\n    // =255 if full\r\n    uint8 openPosition;\r\n\t\r\n    event newInvest(address player, uint invest_v);\r\n\r\n\r\n     function invest()\r\n     {\r\n          // check that min 10 ETH is sent (variable setting)\r\n          if (msg.value<setting_minInvestment) throw;\r\n          // check if already investor\r\n          bool alreadyInvestor;\r\n          // reset the position counters to values out of bounds\r\n          openPosition=255;\r\n          cheapestUnlockedPosition=255;\r\n          minCurrentInvest=1000000000 ether;\r\n          // update balances before altering the investor shares\r\n          updateBalances();\r\n          // loop over investor's array to find if already investor, \r\n          // or openPosition and cheapest UnlockedPosition\r\n          for (uint8 k = 0; k<setting_maxInvestors; k++)\r\n          { \r\n               //captures an index of an open position\r\n               if (investors[k].investor==0) openPosition=k; \r\n               //captures if already an investor \r\n               else if (investors[k].investor==msg.sender)\r\n               {\r\n                    investors[k].time=now; //refresh time invest\r\n                    alreadyInvestor=true;\r\n                }\r\n               //captures the index of the investor with the min investment (after lock period)\r\n               else if (investors[k].time+setting_lockPeriod<now && balance[investors[k].investor]<minCurrentInvest && investors[k].investor!=developer)\r\n               {\r\n                    cheapestUnlockedPosition=k;\r\n                    minCurrentInvest=balance[investors[k].investor];\r\n                }\r\n           }\r\n           //case New investor\r\n           if (alreadyInvestor==false)\r\n           {\r\n                    //case : investor array not full, record new investor\r\n                    if (openPosition!=255) investors[openPosition]=Investor(msg.sender, now);\r\n                    //case : investor array full\r\n                    else\r\n                    {\r\n                         //subcase : investor has not outbid or all positions under lock period\r\n                         if (msg.value<=minCurrentInvest || cheapestUnlockedPosition==255) throw;\r\n                         //subcase : investor outbid, record investor change and refund previous\r\n                         else\r\n                         {\r\n                              address previous = investors[cheapestUnlockedPosition].investor;\r\n                              balance[previous]=0;\r\n                              investors[cheapestUnlockedPosition]=Investor(msg.sender, now);\r\n                              if (previous.send(balance[previous])==false) throw;\r\n                          }\r\n                     }\r\n            }\r\n          //add investment to balance of investor and to payroll\r\n\r\n          uint256 maintenanceFees=2*msg.value/100; //2% maintenance fees\r\n          uint256 netInvest=msg.value - maintenanceFees;\r\n          newInvest(msg.sender, netInvest);\r\n          balance[msg.sender]+=netInvest; //add invest to balance\r\n          payroll+=netInvest;\r\n          //send maintenance fees to developer \r\n          if (developer.send(maintenanceFees)==false) throw;\r\n          updateMaxBet();\r\n      }\r\n\r\n//***// Withdraw function (only after lockPeriod)\r\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\r\n    // if your withdraw brings your balance under the min investment required,\r\n    // your balance is fully withdrawn\r\n\tevent withdraw(address player, uint withdraw_v);\r\n\t\r\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\r\n    noEthSent\r\n    {\r\n        //before withdraw, update balances of the investors with the Profit and Loss sinceChange\r\n        updateBalances();\r\n\t//check that amount requested is authorized  \r\n\tif (amountToWithdrawInWei>balance[msg.sender]) throw;\r\n        //retrieve investor ID\r\n        uint8 investorID=255;\r\n        for (uint8 k = 0; k<setting_maxInvestors; k++)\r\n        {\r\n               if (investors[k].investor==msg.sender)\r\n               {\r\n                    investorID=k;\r\n                    break;\r\n               }\r\n        }\r\n           if (investorID==255) throw; //stop if not an investor\r\n           //check if investment lock period is over\r\n           if (investors[investorID].time+setting_lockPeriod>now) throw;\r\n           //if balance left after withdraw is still above min investment accept partial withdraw\r\n           if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\r\n           {\r\n               balance[msg.sender]-=amountToWithdrawInWei;\r\n               payroll-=amountToWithdrawInWei;\r\n               //send amount to investor (with security if transaction fails)\r\n               if (msg.sender.send(amountToWithdrawInWei)==false) throw;\r\n\t       withdraw(msg.sender, amountToWithdrawInWei);\r\n           }\r\n           else\r\n           //if amountToWithdraw=0 : user wants full withdraw\r\n           //if balance after withdraw is < min invest, withdraw all and delete investor\r\n           {\r\n               //send amount to investor (with security if transaction fails)\r\n               uint256 fullAmount=balance[msg.sender];\r\n               payroll-=fullAmount;\r\n               balance[msg.sender]=0;\r\n               //delete investor\r\n               delete investors[investorID];\r\n               if (msg.sender.send(fullAmount)==false) throw;\r\n   \t       withdraw(msg.sender, fullAmount);\r\n            }\r\n          updateMaxBet();\r\n     }\r\n\r\n//***// updates balances with Profit Losses when there is a withdraw/deposit of investors\r\n\r\n\tfunction manualUpdateBalances()\r\n\texpireGambles\r\n\tnoEthSent\r\n\tonlyDeveloper\r\n\t{\r\n\t    updateBalances();\r\n\t}\r\n    function updateBalances() private\r\n    {\r\n         //split Profits\r\n         uint256 profitToSplit;\r\n         uint256 lossToSplit;\r\n         if (profitSinceChange==0 && lossSinceChange==0)\r\n         { return; }\r\n         \r\n         else\r\n         {\r\n             // Case : Global profit (more win than losses)\r\n             // 2% fees for developer on global profit (if profit>loss)\r\n             if (profitSinceChange>lossSinceChange)\r\n             {\r\n                profitToSplit=profitSinceChange-lossSinceChange;\r\n                uint256 developerFees=profitToSplit*2/100;\r\n                profitToSplit-=developerFees;\r\n                if (developer.send(developerFees)==false) throw;\r\n             }\r\n             else\r\n             {\r\n                lossToSplit=lossSinceChange-profitSinceChange;\r\n             }\r\n         \r\n         //share the loss and profits between all invest \r\n         //(proportionnaly. to each investor balance)\r\n         uint totalShared;\r\n             for (uint8 k=0; k<setting_maxInvestors; k++)\r\n             {\r\n                 address inv=investors[k].investor;\r\n                 if (inv==0) continue;\r\n                 else\r\n                 {\r\n                       if (profitToSplit!=0) \r\n                       {\r\n                           uint profitShare=(profitToSplit*balance[inv])/payroll;\r\n                           balance[inv]+=profitShare;\r\n                           totalShared+=profitShare;\r\n                       }\r\n                       if (lossToSplit!=0) \r\n                       {\r\n                           uint lossShare=(lossToSplit*balance[inv])/payroll;\r\n                           balance[inv]-=lossShare;\r\n                           totalShared+=lossShare;\r\n                           \r\n                       }\r\n                 }\r\n             }\r\n          // update payroll\r\n          if (profitToSplit !=0) \r\n          {\r\n              payroll+=profitToSplit;\r\n              balance[developer]+=profitToSplit-totalShared;\r\n          }\r\n          if (lossToSplit !=0) \r\n          {\r\n              payroll-=lossToSplit;\r\n              balance[developer]-=lossToSplit-totalShared;\r\n          }\r\n          profitSinceChange=0; //reset Profit;\r\n          lossSinceChange=0; //reset Loss ;\r\n          \r\n          }\r\n     }\r\n     \r\n     \r\n     //INFORMATION FUNCTIONS\r\n     \r\n     function checkProfitLossSinceInvestorChange() constant returns(uint profit_since_update_balances, uint loss_since_update_balances)\r\n     {\r\n        profit_since_update_balances=profitSinceChange;\r\n        loss_since_update_balances=lossSinceChange;\r\n        return;\r\n     }\r\n\r\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\r\n    {\r\n          balanceInWei=balance[investor];\r\n          return;\r\n     }\r\n\r\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\r\n    {\r\n          investor=investors[index].investor;\r\n          endLockPeriod=investors[index].time+setting_lockPeriod;\r\n          return;\r\n    }\r\n\t\r\n\r\n\tfunction investmentEntryCost() constant returns(bool open_position, bool unlocked_position, uint buyout_amount, uint investLockPeriod)\r\n\t{\r\n\t\tif (openPosition!=255) open_position=true;\r\n\t\tif (cheapestUnlockedPosition!=255) \r\n\t\t{\r\n\t\t\tunlocked_position=true;\r\n\t\t\tbuyout_amount=minCurrentInvest;\r\n\t\t}\r\n\t\tinvestLockPeriod=setting_lockPeriod;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tfunction getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\r\n\t{\r\n\t    maxBet=currentMaxGamble;\r\n\t    blockDelayBeforeSpin=blockDelay;\r\n\t    return ;\r\n\t}\r\n\r\n\tfunction getFirstActiveGamble() constant returns(uint _firstActiveGamble)\r\n\t{\r\n            _firstActiveGamble=firstActiveGamble;\r\n\t    return ;\r\n\t}\r\n\t\r\n\tfunction getPayroll() constant returns(uint payroll_at_last_update_balances)\r\n\t{\r\n            payroll_at_last_update_balances=payroll;\r\n\t    return ;\r\n\t}\r\n\r\n\t\r\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\r\n    {\r\n          player_status=playerStatus[player];\r\n          bettype=gambles[gambleIndex[player]].betType;\r\n          input=gambles[gambleIndex[player]].input;\r\n          value=gambles[gambleIndex[player]].wager;\r\n          result=gambles[gambleIndex[player]].wheelResult;\r\n          wheelspinned=gambles[gambleIndex[player]].spinned;\r\n          win=gambles[gambleIndex[player]].win;\r\n          blockNb=gambles[gambleIndex[player]].blockNumber;\r\n\t  return;\r\n     }\r\n     \r\n         function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\r\n    {\r\n          player=gambles[index].player;\r\n          bettype=gambles[index].betType;\r\n          input=gambles[index].input;\r\n          value=gambles[index].wager;\r\n          result=gambles[index].wheelResult;\r\n          wheelspinned=gambles[index].spinned;\r\n          win=gambles[index].win;\r\n\t  blockNb=gambles[index].blockNumber;\r\n\t  return;\r\n     }\r\n\r\n} //end of contract", 
  "balance": "10<b>.</b>760013512961416865 Ether", 
  "name": "Rouleth", 
  "transactions": "1304", 
  "address": "0x05240da139d30034eaae15737610bfbe68b97910"
 }, 
 {
  "source": "contract Ambi {\r\n    function getNodeAddress(bytes32 _name) constant returns (address);\r\n    function addNode(bytes32 _name, address _addr) external returns (bool);\r\n    function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool);\r\n}\r\n\r\ncontract PotRewards {\r\n    function transfer(address _from, address _to, uint _amount);\r\n}\r\n\r\ncontract PosRewards {\r\n    function transfer(address _from, address _to);\r\n}\r\n\r\ncontract ElcoinInterface {\r\n    function rewardTo(address _to, uint _amount) returns (bool);\r\n}\r\n\r\ncontract EtherTreasuryInterface {\r\n    function withdraw(address _to, uint _value) returns(bool);\r\n}\r\n\r\ncontract MetaCoinInterface {\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approved(address indexed _owner, address indexed _spender, uint256 _value);\r\n\tevent Unapproved(address indexed _owner, address indexed _spender);\r\n\r\n\tfunction totalSupply() constant returns (uint256 supply){}\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance){}\r\n\tfunction transfer(address _to, uint256 _value) returns (bool success){}\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success){}\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success){}\r\n\tfunction unapprove(address _spender) returns (bool success){}\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining){}\r\n}\r\n\r\ncontract ElcoinDb {\r\n    function getBalance(address addr) constant returns(uint balance);\r\n    function deposit(address addr, uint amount, bytes32 hash, uint time) returns (bool res);\r\n    function withdraw(address addr, uint amount, bytes32 hash, uint time) returns (bool res);\r\n}\r\n\r\ncontract AmbiEnabled {\r\n    Ambi ambiC;\r\n    bytes32 public name;\r\n\r\n    modifier checkAccess(bytes32 _role) {\r\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\r\n            _\r\n        }\r\n    }\r\n    \r\n    function getAddress(bytes32 _name) constant returns (address) {\r\n        return ambiC.getNodeAddress(_name);\r\n    }\r\n\r\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\r\n        if(address(ambiC) != 0x0){\r\n            return false;\r\n        }\r\n        Ambi ambiContract = Ambi(_ambi);\r\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\r\n            bool isNode = ambiContract.addNode(_name, address(this));\r\n            if (!isNode){\r\n                return false;\r\n            }   \r\n        }\r\n        name = _name;\r\n        ambiC = ambiContract;\r\n        return true;\r\n    }\r\n\r\n    function remove() checkAccess(\"owner\") {\r\n        suicide(msg.sender);\r\n    }\r\n}\r\n\r\ncontract Elcoin is AmbiEnabled, MetaCoinInterface {\r\n\r\n    event Error(uint8 indexed code, address indexed origin, address indexed sender);\r\n\r\n    mapping (address => uint) public recoveredIndex;\r\n    address[] public recovered;\r\n\r\n    uint public totalSupply;\r\n    uint public absMinFee; // set up in 1/1000000 of Elcoin\r\n    uint public feePercent; // set up in 1/100 of percent, 10 is 0.1%\r\n    uint public absMaxFee; // set up in 1/1000000 of Elcoin\r\n    address public feeAddr;\r\n\r\n    function Elcoin() {\r\n        recovered.length++;\r\n        feeAddr = tx.origin;\r\n        _setFeeStructure(0, 0, 1);\r\n    }\r\n\r\n    function _db() internal constant returns (ElcoinDb) {\r\n        return ElcoinDb(getAddress(\"elcoinDb\"));\r\n    }\r\n\r\n    function _setFeeStructure(uint _absMinFee, uint _feePercent, uint _absMaxFee) internal returns (bool) {\r\n        if(_absMinFee < 0 || _feePercent < 0 || _feePercent > 10000 || _absMaxFee < 0 || _absMaxFee < _absMinFee) {\r\n            Error(1, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n        absMinFee = _absMinFee;\r\n        feePercent = _feePercent;\r\n        absMaxFee = _absMaxFee;\r\n        return true;\r\n    }\r\n\r\n    function _rawTransfer(ElcoinDb _db, address _from, address _to, uint _value) internal {\r\n        _db.withdraw(_from, _value, 0, 0);\r\n        uint fee = calculateFee(_value);\r\n        uint net = _value - fee;\r\n        _db.deposit(_to, net, 0, 0);\r\n\r\n        Transfer(_from, _to, _value);\r\n        if (fee > 0) {\r\n            _db.deposit(feeAddr, fee, 0, 0);\r\n        }\r\n    }\r\n\r\n    function _transfer(ElcoinDb _db, address _from, address _to, uint _value) internal returns (bool) {\r\n        if (_value < absMinFee) {\r\n            return false;\r\n        }\r\n        if (_from == _to) {\r\n            return false;\r\n        }\r\n        uint balance = _db.getBalance(_from);\r\n\r\n        if (balance < _value) {\r\n            return false;\r\n        }\r\n        _rawTransfer(_db, _from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transferWithReward(ElcoinDb _db, address _from, address _to, uint _value) internal returns (bool) {\r\n        if (!_transfer(_db, _from, _to, _value)) {\r\n            Error(2, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        address pos = getAddress(\"elcoinPoS\");\r\n        address pot = getAddress(\"elcoinPoT\");\r\n        if (pos != 0x0) {\r\n            PosRewards(pos).transfer(_from, _to);\r\n        }\r\n        if (pot != 0x0) {\r\n            PotRewards(pot).transfer(_from, _to, _value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _recoverAccount(ElcoinDb _db, address _old, address _new) internal returns (bool) {\r\n        uint pos =  recovered.length++;\r\n        recovered[pos] = _old;\r\n        recoveredIndex[_old] = pos;\r\n        uint balance = _db.getBalance(_old);\r\n        var rv = _db.withdraw(_old, balance, 0, 0);\r\n        if (!rv) {\r\n            Error(5, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n        _db.deposit(_new, balance, 0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    modifier notRecoveredAccount(address _account) {\r\n        if(recoveredIndex[_account] == 0x0) {\r\n            _\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _account) constant returns (uint) {\r\n        return _db().getBalance(_account);\r\n    }\r\n\r\n    function calculateFee(uint _amount) constant returns (uint) {\r\n        uint fee = (_amount * feePercent) / 10000;\r\n\r\n        if (fee < absMinFee) {\r\n            return absMinFee;\r\n        }\r\n\r\n        if (fee > absMaxFee) {\r\n            return absMaxFee;\r\n        }\r\n\r\n        return fee;\r\n    }\r\n\r\n    function issueCoin(address _to, uint _value, uint _totalSupply) checkAccess(\"currencyOwner\") returns (bool) {\r\n        if (totalSupply > 0) {\r\n            Error(6, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        bool dep = _db().deposit(_to, _value, 0, 0);\r\n        totalSupply = _totalSupply;\r\n        return dep;\r\n    }\r\n\r\n    function batchTransfer(address[] _to, uint[] _value) checkAccess(\"currencyOwner\") returns (bool) {\r\n        if (_to.length != _value.length) {\r\n            Error(7, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        uint totalToSend = 0;\r\n        for (uint8 i = 0; i < _value.length; i++) {\r\n            totalToSend += _value[i];\r\n        }\r\n\r\n        ElcoinDb db = _db();\r\n        if (db.getBalance(msg.sender) < totalToSend) {\r\n            Error(8, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        db.withdraw(msg.sender, totalToSend, 0, 0);\r\n        for (uint8 j = 0; j < _to.length; j++) {\r\n            db.deposit(_to[j], _value[j], 0, 0);\r\n            Transfer(msg.sender, _to[j], _value[j]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        uint startGas = msg.gas + transferCallGas;\r\n        if (!_transferWithReward(_db(), msg.sender, _to, _value)) {\r\n            return false;\r\n        }\r\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\r\n        return _refund(refund);\r\n    }\r\n\r\n    function transferPool(address _from, address _to, uint _value) checkAccess(\"pool\") returns (bool) {\r\n        return _transferWithReward(_db(), _from, _to, _value);\r\n    }\r\n\r\n    function rewardTo(address _to, uint _amount) checkAccess(\"reward\") returns (bool) {\r\n        bool result = _db().deposit(_to, _amount, 0, 0);\r\n        if (result) {\r\n            totalSupply += _amount;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function recoverAccount(address _old, address _new) checkAccess(\"recovery\") notRecoveredAccount(_old) returns (bool) {\r\n        return _recoverAccount(_db(), _old, _new);\r\n    }\r\n\r\n    function setFeeAddr(address _feeAddr) checkAccess(\"currencyOwner\") {\r\n        feeAddr = _feeAddr;\r\n    }\r\n\r\n    function setFee(uint _absMinFee, uint _feePercent, uint _absMaxFee) checkAccess(\"cron\") returns (bool) {\r\n        return _setFeeStructure(_absMinFee, _feePercent, _absMaxFee);\r\n    }\r\n\r\n    uint public txGasPriceLimit = 21000000000;\r\n    uint public transferCallGas = 21000;\r\n    uint public refundGas = 15000;\r\n    EtherTreasuryInterface treasury;\r\n\r\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(\"currencyOwner\") returns (bool) {\r\n        if (_txGasPriceLimit == 0) {\r\n            return false;\r\n        }\r\n        treasury = EtherTreasuryInterface(_treasury);\r\n        txGasPriceLimit = _txGasPriceLimit;\r\n        if (msg.value > 0 && !address(treasury).send(msg.value)) {\r\n            throw;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function updateRefundGas() checkAccess(\"currencyOwner\") returns (uint) {\r\n        uint startGas = msg.gas;\r\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice; // just to simulate calculations, dunno if optimizer will remove this.\r\n        if (!_refund(1)) {\r\n            return 0;\r\n        }\r\n        refundGas = startGas - msg.gas;\r\n        return refundGas;\r\n    }\r\n\r\n    function setOperationsCallGas(uint _transfer) checkAccess(\"currencyOwner\") returns (bool) {\r\n        transferCallGas = _transfer;\r\n        return true;\r\n    }\r\n\r\n    function _refund(uint _value) internal returns (bool) {\r\n        if (tx.gasprice > txGasPriceLimit) {\r\n            return false;\r\n        }\r\n        return treasury.withdraw(tx.origin, _value);\r\n    }\r\n}", 
  "balance": "0<b>.</b>000000000000001282 Ether", 
  "name": "Elcoin", 
  "transactions": "1297", 
  "address": "0xfe1a96cd0bfb3245d83808b9aba6538576145920"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "46<b>.</b>0638777168728509 Ether", 
  "name": "Wallet", 
  "transactions": "1099", 
  "address": "0x35dd0770ccb5a7741155ff324ea9ec8d8c1b3c99"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "13<b>.</b>4529384214231622 Ether", 
  "name": "Wallet", 
  "transactions": "998", 
  "address": "0x49f99866dca43ac1ff34685fb933e04b2631c127"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 5000; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 25; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BGY6bTXlCGZvb4G+m/7GGsPb1+QjJV0fcy2HLxf5m+6wWiRYm9eDw/C7tgusIKEBvFDOER9P9Bcg0aoZKlikx1juY9RPkRs0ioSFkYavyaBmmWCDsLQdBv+1kojrJvUnseMaPDRuj3UbYMpg5dsWsgjgSAgiWfg=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "990", 
  "address": "0x6dd38916b8c3780fd487980c54c90c175017664c"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "59<b>.</b>41493802095088004 Ether", 
  "name": "Wallet", 
  "transactions": "973", 
  "address": "0x6c901d954fd59747c991b0893f0286e63de4e779"
 }, 
 {
  "source": "pragma solidity ^0.4.2;\r\n\r\n\r\n/* define 'owned' */\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract StableBalance is owned {\r\n \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Tx(address _to, uint256 _value,string _txt);\r\n    \r\n    mapping (address => uint256) balances;\r\n    \r\n    function transfer(address _to, uint256 _value) returns (bool success) { return false; throw;}\r\n    \r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function addTx(address _to, uint256 _value,string _txt) onlyOwner {\r\n        balances[_to]+=_value;\r\n        Tx(_to,_value,_txt);\r\n    }\r\n    \r\n}\r\ncontract StableBalancer is owned {\r\n \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Tx(address _from,address _to, uint256 _value,string _txt);\r\n    \r\n    mapping (address => uint256) balancesHaben;\r\n    mapping (address => uint256) balancesSoll;\r\n    \r\n    function transfer(address _to, uint256 _value) returns (bool success) { return false; throw;}\r\n    \r\n    function balanceHaben(address _owner) constant returns (uint256 balance) {\r\n        return balancesHaben[_owner];\r\n    }\r\n    \r\n    function balanceSoll(address _owner) constant returns (uint256 balance) {\r\n        return balancesSoll[_owner];\r\n    }\r\n    \r\n    function addTx(address _from,address _to, uint256 _value,string _txt) onlyOwner {\r\n        balancesSoll[_from]+=_value;\r\n        balancesHaben[_to]+=_value;\r\n        Tx(_from,_to,_value,_txt);\r\n    }\r\n    \r\n}\r\n\r\ncontract StableStore {\r\n    \r\n    mapping (address => string) public store;\r\n    \r\n    function setValue(string _value) {\r\n        store[msg.sender]=_value;\r\n    }\r\n}\r\n\r\ncontract StableAddressStore {\r\n    mapping (address => mapping(address=>string)) public store;\r\n    \r\n    function setValue(address key,string _value) {\r\n        store[msg.sender][key]=_value;\r\n    }\r\n}\r\n\r\ncontract StableTxStore {\r\n    mapping (address => mapping(address=>tx)) public store;\r\n    \r\n    struct tx {\r\n        uint256 amount;\r\n        uint256 repeatMinutes;\r\n        uint256 repeatTimes;\r\n    }\r\n    \r\n    function setValue(address key,uint256 amount,uint256 repeatMinutes,uint256 repeatTimes) {\r\n        store[msg.sender][key]=tx(amount,repeatMinutes,repeatTimes);\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "StableBalancer", 
  "transactions": "953", 
  "address": "0xc3ef562cc403c8f9edf7c3826655fbf50f4ddde8"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "4<b>.</b>95 Ether", 
  "name": "Wallet", 
  "transactions": "943", 
  "address": "0x3ddb8784f60c723aa6b8ba76a3eea54776e1e821"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "0<b>.</b>635256310000000004 Ether", 
  "name": "Wallet", 
  "transactions": "876", 
  "address": "0xe81e6a0ce0137432e9a5453ab831697d10b6a931"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "188<b>.</b>757683517041404672 Ether", 
  "name": "Wallet", 
  "transactions": "862", 
  "address": "0xa5713ea0c7f9d45e42227d24e88cb47db5f0c8d0"
 }, 
 {
  "source": "// Last is me! Lottery paying the last player\r\n//\r\n// git: https://github.com/lastisme/lastisme.github.io/\r\n// url: http://lastis.me\r\n\r\ncontract owned {\r\n  address public owner;\r\n\r\n  function owned() {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) throw;\r\n    _\r\n  }\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract LastIsMe is owned {\r\n  event TicketBought(address _from);\r\n  event WinnerPayedTicketBought(address _winner, address _from);\r\n\r\n  //constant once constructed\r\n  uint public blocks;\r\n  uint public price;\r\n  ///////////////////////////\r\n\r\n  //semi-constant, tweakable with limits after creation\r\n  uint public houseFee;      // THOUSANDTHS\r\n  uint public houseFeeVal;   // houseFee/1000 * price\r\n  uint public refFeeVal;     // half of the house fee val\r\n\r\n  uint public lotteryFee;    // THOUSANDTHS\r\n  uint public lotteryFeeVal; // lotteryFee/1000 * price\r\n\r\n  address public leftLottery;\r\n  address public rightLottery;\r\n  //////////////////////////////////////////////////\r\n\r\n  uint constant MAX_HOUSE_FEE_THOUSANDTHS   = 20;\r\n  uint constant MAX_LOTTERY_FEE_THOUSANDTHS = 40;\r\n\r\n  address public lastPlayer;\r\n  uint    public lastBlock;\r\n  uint    public totalWinnings;\r\n  uint    public jackpot;\r\n  uint    public startedAt;\r\n\r\n  struct Winners {\r\n    address winner;\r\n    uint jackpot;\r\n    uint timestamp;\r\n  }\r\n  Winners[] public winners;\r\n\r\n\r\n\r\n  function LastIsMe(uint _priceParam, uint _blocksParam) {\r\n    if(_priceParam==0 || _blocksParam==0) throw;\r\n    price  = _priceParam;\r\n    blocks = _blocksParam;\r\n    setHouseFee(10);\r\n    setLotteryFee(40);\r\n    totalWinnings = 0;\r\n    jackpot = 0;\r\n  }\r\n\r\n  function buyTicket(address _ref) {\r\n    if( msg.value >= price ) { //ticket bought\r\n\r\n      if( msg.value > price ) {\r\n        msg.sender.send(msg.value-price);  //payed more than required => refund\r\n      }\r\n\r\n      if( remaining() == 0 && lastPlayer != 0x0 ) {  //last player was the winner!\r\n        WinnerPayedTicketBought(lastPlayer,msg.sender);\r\n        winners[winners.length++] = Winners(lastPlayer, jackpot, block.timestamp);\r\n        lastPlayer.send(jackpot);\r\n        totalWinnings=totalWinnings+jackpot;\r\n        startedAt  = block.timestamp;\r\n        lastPlayer = msg.sender;\r\n        lastBlock  = block.number;\r\n        jackpot    = this.balance;\r\n        //I am not paying fee and other lotteries fee if I am the lottery re-starter\r\n      } else {\r\n        TicketBought(msg.sender);\r\n        if(lastPlayer==0x0)   //very first ticket\r\n          startedAt = block.timestamp;\r\n\r\n        lastPlayer = msg.sender;\r\n        lastBlock  = block.number;\r\n\r\n        if(houseFeeVal>0) {  //house fee could be zero\r\n          if(_ref==0x0) {\r\n            owner.send(houseFeeVal);\r\n          } else {\r\n            owner.send(refFeeVal);\r\n            _ref.send(refFeeVal);\r\n          }\r\n        }\r\n\r\n        if(leftLottery!=0x0 && lotteryFeeVal>0)\r\n          leftLottery.send(lotteryFeeVal);\r\n        if(rightLottery!=0x0 && lotteryFeeVal>0)\r\n          rightLottery.send(lotteryFeeVal);\r\n\r\n        jackpot = this.balance;\r\n      }\r\n    }\r\n  }\r\n\r\n  function () {\r\n    buyTicket(0x0);\r\n  }\r\n\r\n  function finance() {\r\n  }\r\n\r\n  function allData() constant returns (uint _balance, address _lastPlayer, uint _lastBlock, uint _blockNumber, uint _totalWinners, uint _jackpot, uint _price, uint _blocks, uint _houseFee, uint _lotteryFee, address _leftLottery, address _rightLottery, uint _totalWinnings, uint _startedAt) {\r\n    return (this.balance, lastPlayer, lastBlock, block.number, winners.length, jackpot, price, blocks, houseFee, lotteryFee, leftLottery, rightLottery, totalWinnings, startedAt);\r\n  }\r\n\r\n  function baseData() constant returns (uint _balance, address _lastPlayer, uint _lastBlock, uint _blockNumber, uint _totalWinners, uint _jackpot, uint _price, uint _blocks, uint _totalWinnings, uint _startedAt) {\r\n    return (this.balance, lastPlayer, lastBlock, block.number, winners.length, jackpot, price, blocks, totalWinnings, startedAt);\r\n  }\r\n\r\n  function elapsed() constant returns (uint) {\r\n    return block.number - lastBlock;  //>=0\r\n  }\r\n\r\n  function remaining() constant returns (uint) {\r\n    var e=elapsed();\r\n    if(blocks>e)\r\n      return blocks - elapsed() ;\r\n    else\r\n      return 0;\r\n  }\r\n\r\n  function totalWinners() constant returns (uint) {\r\n    return winners.length;\r\n  }\r\n\r\n  function updateLeftLottery( address _newValue) onlyOwner {\r\n    leftLottery=_newValue;\r\n  }\r\n\r\n  function updateRightLottery( address _newValue) onlyOwner {\r\n    rightLottery=_newValue;\r\n  }\r\n\r\n  function setLotteryFee(uint _newValue) onlyOwner {\r\n    if( _newValue > MAX_LOTTERY_FEE_THOUSANDTHS ) throw;\r\n    lotteryFee    = _newValue;\r\n    var aThousand = price/1000;\r\n    lotteryFeeVal = aThousand*lotteryFee;\r\n  }\r\n\r\n  function setHouseFee(uint _newValue) onlyOwner {\r\n    if( _newValue > MAX_HOUSE_FEE_THOUSANDTHS ) throw;\r\n    houseFee      = _newValue;\r\n    var aThousand = price/1000;\r\n    houseFeeVal   = aThousand*houseFee;\r\n    refFeeVal     = houseFeeVal / 2;\r\n  }\r\n}", 
  "balance": "0<b>.</b>01 Ether", 
  "name": "LastIsMe", 
  "transactions": "860", 
  "address": "0x5d9b8fa00c16bcafae47deed872e919c8f6535bf"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "3<b>.</b>607579311257959328 Ether", 
  "name": "Wallet", 
  "transactions": "847", 
  "address": "0x98bf8f243be2bd112e96575a5e1d1c77dce1ceb9"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 2500; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 25; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BL4JaqkoeRJTvj5fAd3ljo0qabFhF7QhiuJgdFX3LsY/5hDYekFx8KYLBOt6cLAHBzw1nU5Km6GboALOxtVKigiY/Td/oCihav3g/H8Jc8JEEgJ8kAHvz9fvlUjFjxjyiOa5naHSkMV9UIA6bI52cNuxDlcWInY=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "845", 
  "address": "0x108284702b23504de29d3293f2530255c6b3ccea"
 }, 
 {
  "source": "contract tokenSpender { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\n\r\ncontract Nexium { \r\n\t\r\n\t\r\n\t/* Public variables of the token */\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\tuint256 public initialSupply;\r\n\taddress public burnAddress;\r\n\r\n\t/* This creates an array with all balances */\r\n\tmapping (address => uint) public balanceOf;\r\n\tmapping (address => mapping (address => uint)) public allowance;\r\n\r\n\t/* This generates a public event on the blockchain that will notify clients */\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed from, address indexed spender, uint value);\r\n\r\n\t\r\n\t\r\n\t/* Initializes contract with initial supply tokens to the creator of the contract */\r\n\tfunction Nexium() {\r\n\t\tinitialSupply = 100000000000;\r\n\t\tbalanceOf[msg.sender] = initialSupply;             // Give the creator all initial tokens                    \r\n\t\tname = 'Nexium';                                 // Set the name for display purposes     \r\n\t\tsymbol = 'NxC';                               \t // Set the symbol for display purposes    \r\n\t\tdecimals = 3;                           \t\t // Amount of decimals for display purposes\r\n\t\tburnAddress = 0x1b32000000000000000000000000000000000000;\r\n\t}\r\n\t\r\n\tfunction totalSupply() returns(uint){\r\n\t\treturn initialSupply - balanceOf[burnAddress];\r\n\t}\r\n\r\n\t/* Send coins */\r\n\tfunction transfer(address _to, uint256 _value) \r\n\treturns (bool success) {\r\n\t\tif (balanceOf[msg.sender] >= _value && _value > 0) {\r\n\t\t\tbalanceOf[msg.sender] -= _value;\r\n\t\t\tbalanceOf[_to] += _value;\r\n\t\t\tTransfer(msg.sender, _to, _value);\r\n\t\t\treturn true;\r\n\t\t} else return false; \r\n\t}\r\n\r\n\t/* Allow another contract to spend some tokens in your behalf */\r\n\r\n\t\r\n\t\r\n\tfunction approveAndCall(address _spender,\r\n\t\t\t\t\t\t\tuint256 _value,\r\n\t\t\t\t\t\t\tbytes _extraData)\r\n\treturns (bool success) {\r\n\t\tallowance[msg.sender][_spender] = _value;     \r\n\t\ttokenSpender spender = tokenSpender(_spender);\r\n\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\t/*Allow another adress to use your money but doesn't notify it*/\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\t\r\n\t\r\n\t/* A contract attempts to get the coins */\r\n\tfunction transferFrom(address _from,\r\n\t\t\t\t\t\t  address _to,\r\n\t\t\t\t\t\t  uint256 _value)\r\n\treturns (bool success) {\r\n\t\tif (balanceOf[_from] >= _value && allowance[_from][msg.sender] >= _value && _value > 0) {\r\n\t\t\tbalanceOf[_to] += _value;\r\n\t\t\tTransfer(_from, _to, _value);\r\n\t\t\tbalanceOf[_from] -= _value;\r\n\t\t\tallowance[_from][msg.sender] -= _value;\r\n\t\t\treturn true;\r\n\t\t} else return false; \r\n\t}\r\n\r\n\t\r\n\t\r\n\t/* This unnamed function is called whenever someone tries to send ether to it */\r\n\tfunction () {\r\n\t\tthrow;     // Prevents accidental sending of ether\r\n\t}        \r\n}", 
  "balance": "0 Ether", 
  "name": "Nexium", 
  "transactions": "825", 
  "address": "0x45e42d659d9f9466cd5df622506033145a9b89bc"
 }, 
 {
  "source": "pragma solidity ^0.4.2;\r\n\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Constant {\r\n    function totalSupply() constant returns (uint supply);\r\n    function balanceOf( address who ) constant returns (uint value);\r\n    function allowance(address owner, address spender) constant returns (uint _allowance);\r\n}\r\ncontract ERC20Stateful {\r\n    function transfer( address to, uint value) returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n}\r\ncontract ERC20Events {\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}\r\n\r\ncontract Assertive {\r\n    function assert(bool assertion) internal {\r\n        if (!assertion) throw;\r\n    }\r\n}\r\n\r\ncontract FallbackFailer {\r\n  function () {\r\n    throw;\r\n  }\r\n}\r\n\r\ncontract MutexUser {\r\n    bool private lock;\r\n    modifier exclusive {\r\n        if (lock) throw;\r\n        lock = true;\r\n        _;\r\n        lock = false;\r\n    }\r\n}\r\n\r\n// A simple direct exchange order manager.\r\n\r\ncontract EventfulMarket {\r\n    event ItemUpdate( uint id );\r\n    event Trade( uint sell_how_much, address indexed sell_which_token,\r\n                 uint buy_how_much, address indexed buy_which_token );\r\n}\r\n\r\ncontract SimpleMarket is EventfulMarket\r\n                       , Assertive\r\n                       , FallbackFailer\r\n                       , MutexUser\r\n{\r\n    struct OfferInfo {\r\n        uint sell_how_much;\r\n        ERC20 sell_which_token;\r\n        uint buy_how_much;\r\n        ERC20 buy_which_token;\r\n        address owner;\r\n        bool active;\r\n    }\r\n    mapping( uint => OfferInfo ) public offers;\r\n\r\n    uint public last_offer_id;\r\n\r\n    function next_id() internal returns (uint) {\r\n        last_offer_id++; return last_offer_id;\r\n    }\r\n\r\n    modifier can_offer {\r\n        _;\r\n    }\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        _;\r\n    }\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(getOwner(id) == msg.sender);\r\n        _;\r\n    }\r\n    function isActive(uint id) constant returns (bool active) {\r\n        return offers[id].active;\r\n    }\r\n    function getOwner(uint id) constant returns (address owner) {\r\n        return offers[id].owner;\r\n    }\r\n    function getOffer( uint id ) constant returns (uint, ERC20, uint, ERC20) {\r\n      var offer = offers[id];\r\n      return (offer.sell_how_much, offer.sell_which_token,\r\n              offer.buy_how_much, offer.buy_which_token);\r\n    }\r\n\r\n    // non underflowing subtraction\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    // non overflowing multiplication\r\n    function safeMul(uint a, uint b) internal returns (uint c) {\r\n        c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n    }\r\n\r\n    function trade( address seller, uint sell_how_much, ERC20 sell_which_token,\r\n                    address buyer,  uint buy_how_much,  ERC20 buy_which_token )\r\n        internal\r\n    {\r\n        var seller_paid_out = buy_which_token.transferFrom( buyer, seller, buy_how_much );\r\n        assert(seller_paid_out);\r\n        var buyer_paid_out = sell_which_token.transfer( buyer, sell_how_much );\r\n        assert(buyer_paid_out);\r\n        Trade( sell_how_much, sell_which_token, buy_how_much, buy_which_token );\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer( uint sell_how_much, ERC20 sell_which_token\r\n                  , uint buy_how_much,  ERC20 buy_which_token )\r\n        can_offer\r\n        exclusive\r\n        returns (uint id)\r\n    {\r\n        assert(sell_how_much > 0);\r\n        assert(sell_which_token != ERC20(0x0));\r\n        assert(buy_how_much > 0);\r\n        assert(buy_which_token != ERC20(0x0));\r\n        assert(sell_which_token != buy_which_token);\r\n\r\n        OfferInfo memory info;\r\n        info.sell_how_much = sell_how_much;\r\n        info.sell_which_token = sell_which_token;\r\n        info.buy_how_much = buy_how_much;\r\n        info.buy_which_token = buy_which_token;\r\n        info.owner = msg.sender;\r\n        info.active = true;\r\n        id = next_id();\r\n        offers[id] = info;\r\n\r\n        var seller_paid = sell_which_token.transferFrom( msg.sender, this, sell_how_much );\r\n        assert(seller_paid);\r\n\r\n        ItemUpdate(id);\r\n    }\r\n    // Accept given `quantity` of an offer. Transfers funds from caller to\r\n    // offer maker, and from market to caller.\r\n    function buy( uint id, uint quantity )\r\n        can_buy(id)\r\n        exclusive\r\n        returns ( bool success )\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n\r\n        // inferred quantity that the buyer wishes to spend\r\n        uint spend = safeMul(quantity, offer.buy_how_much) / offer.sell_how_much;\r\n\r\n        if ( spend > offer.buy_how_much || quantity > offer.sell_how_much ) {\r\n            // buyer wants more than is available\r\n            success = false;\r\n        } else if ( spend == offer.buy_how_much && quantity == offer.sell_how_much ) {\r\n            // buyer wants exactly what is available\r\n            delete offers[id];\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                   msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            success = true;\r\n        } else if ( spend > 0 && quantity > 0 ) {\r\n            // buyer wants a fraction of what is available\r\n            offers[id].sell_how_much = safeSub(offer.sell_how_much, quantity);\r\n            offers[id].buy_how_much = safeSub(offer.buy_how_much, spend);\r\n\r\n            trade( offer.owner, quantity, offer.sell_which_token,\r\n                    msg.sender, spend, offer.buy_which_token );\r\n\r\n            ItemUpdate(id);\r\n            success = true;\r\n        } else {\r\n            // buyer wants an unsatisfiable amount (less than 1 integer)\r\n            success = false;\r\n        }\r\n    }\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel( uint id )\r\n        can_cancel(id)\r\n        exclusive\r\n        returns ( bool success )\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n        delete offers[id];\r\n\r\n        var seller_refunded = offer.sell_which_token.transfer( offer.owner , offer.sell_how_much );\r\n        assert(seller_refunded);\r\n\r\n        ItemUpdate(id);\r\n        success = true;\r\n    }\r\n}\r\n\r\n// Simple Market with a market lifetime. When the lifetime has elapsed,\r\n// offers can only be cancelled (offer and buy will throw).\r\n\r\ncontract ExpiringMarket is SimpleMarket {\r\n    uint public close_time;\r\n    function ExpiringMarket(uint lifetime) {\r\n        close_time = getTime() + lifetime;\r\n    }\r\n    function getTime() constant returns (uint) {\r\n        return block.timestamp;\r\n    }\r\n    function isClosed() constant returns (bool closed) {\r\n        return (getTime() > close_time);\r\n    }\r\n\r\n    // after market lifetime has elapsed, no new offers are allowed\r\n    modifier can_offer {\r\n        assert(!isClosed());\r\n        _;\r\n    }\r\n    // after close, no new buys are allowed\r\n    modifier can_buy(uint id) {\r\n        assert(isActive(id));\r\n        assert(!isClosed());\r\n        _;\r\n    }\r\n    // after close, anyone can cancel an offer\r\n    modifier can_cancel(uint id) {\r\n        assert(isActive(id));\r\n        assert(isClosed() || (msg.sender == getOwner(id)));\r\n        _;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ExpiringMarket", 
  "transactions": "812", 
  "address": "0xbea78eae4d9bb70807eecdda6b81e44ead1a5974"
 }, 
 {
  "source": "pragma solidity ^0.4.2;\r\ncontract blockcdn {\r\n    mapping (address => uint256) balances;\r\n\tmapping (address => uint256) fundValue;\r\n\taddress public owner;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    uint256 public minFundedValue;\r\n\tuint256 public maxFundedValue;\r\n    bool public isFundedMax;\r\n    bool public isFundedMini;\r\n    uint256 public closeTime;\r\n    uint256 public startTime;\r\n    \r\n     /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    function blockcdn(\r\n\t    address _owner,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n\t\tuint256 _totalSupply,\r\n        uint256 _closeTime,\r\n        uint256 _startTime,\r\n\t\tuint256 _minValue,\r\n\t\tuint256 _maxValue\r\n        ) { \r\n        owner = _owner;                                      // Set owner of contract \r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        closeTime = _closeTime;                              // Set fund closing time\r\n\t\tstartTime = _startTime;                              // Set fund start time\r\n\t\ttotalSupply = _totalSupply;                          // Total supply\r\n\t\tminFundedValue = _minValue;                          // Set minimum funding goal\r\n\t\tmaxFundedValue = _maxValue;                          // Set max funding goal\r\n\t\tisFundedMax = false;                                 // Initialize fund minimum flag \r\n\t\tisFundedMini = false;                                // Initialize fund max flag\r\n\t\tbalances[owner] = _totalSupply;                      // Set owner balance equal totalsupply \r\n    }\r\n    \r\n\t/*default-function called when values are sent */\r\n\tfunction () payable {\r\n       buyBlockCDN();\r\n    }\r\n\t\r\n    /*send ethereum and get BCDN*/\r\n    function buyBlockCDN() payable returns (bool success){\r\n\t\tif(msg.sender == owner) throw;\r\n        if(now > closeTime) throw; \r\n        if(now < startTime) throw;\r\n        if(isFundedMax) throw;\r\n        uint256 token = 0;\r\n        if(closeTime - 2 weeks > now) {\r\n             token = msg.value;\r\n        }else {\r\n            uint day = (now - (closeTime - 2 weeks))/(2 days) + 1;\r\n            token = msg.value;\r\n            while( day > 0) {\r\n                token  =   token * 95 / 100 ;    \r\n                day -= 1;\r\n            }\r\n        }\r\n        \r\n        balances[msg.sender] += token;\r\n        if(balances[owner] < token) \r\n            return false;\r\n        balances[owner] -= token;\r\n        if(this.balance >= minFundedValue) {\r\n            isFundedMini = true;\r\n        }\r\n        if(this.balance >= maxFundedValue) {\r\n            isFundedMax = true;   \r\n        }\r\n\t\tfundValue[msg.sender] += msg.value;\r\n        Transfer(owner, msg.sender, token);    \r\n        return true;\r\n    }    \r\n    \r\n     /*query BCDN balance*/\r\n    function balanceOf( address _owner) constant returns (uint256 value)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\t\r\n\t/*query fund ethereum balance */\r\n\tfunction balanceOfFund(address _owner) constant returns (uint256 value)\r\n\t{\r\n\t\treturn fundValue[_owner];\r\n\t}\r\n\r\n    /*refund 'msg.sender' in the case the Token Sale didn't reach ite minimum \r\n    funding goal*/\r\n    function reFund() payable returns (bool success) {\r\n        if(now <= closeTime) throw;     \r\n\t\tif(isFundedMini) throw;             \r\n\t\tuint256 value = fundValue[msg.sender];\r\n\t\tfundValue[msg.sender] = 0;\r\n\t\tif(value <= 0) throw;\r\n        if(!msg.sender.send(value)) \r\n            throw;\r\n        balances[owner] +=  balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        Transfer(msg.sender, this, balances[msg.sender]); \r\n        return true;\r\n    }\r\n\r\n\t\r\n\t/*refund _fundaddr in the case the Token Sale didn't reach ite minimum \r\n    funding goal*/\r\n\tfunction reFundByOther(address _fundaddr) payable returns (bool success) {\r\n\t    if(now <= closeTime) throw;    \r\n\t\tif(isFundedMini) throw;           \r\n\t\tuint256 value = fundValue[_fundaddr];\r\n\t\tfundValue[_fundaddr] = 0;\r\n\t\tif(value <= 0) throw;\r\n        if(!_fundaddr.send(value)) throw;\r\n        balances[owner] += balances[_fundaddr];\r\n        balances[_fundaddr] = 0;\r\n        Transfer(msg.sender, this, balances[_fundaddr]); \r\n        return true;\r\n\t}\r\n\r\n    \r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) payable returns (bool success) {\r\n        if(_value <= 0 ) throw;                                      // Check send token value > 0;\r\n\t\tif (balances[msg.sender] < _value) throw;                    // Check if the sender has enough\r\n        if (balances[_to] + _value < balances[_to]) throw;           // Check for overflows\r\n\t\tif(now < closeTime ) {\t\t\t\t\t\t\t\t\t\t // unclosed allowed retrieval, Closed fund allow transfer   \r\n\t\t\tif(_to == address(this)) {\r\n\t\t\t\tfundValue[msg.sender] -= _value;\r\n\t\t\t\tbalances[msg.sender] -= _value;\r\n\t\t\t\tbalances[owner] += _value;\r\n\t\t\t\tif(!msg.sender.send(_value))\r\n\t\t\t\t\treturn false;\r\n\t\t\t\tTransfer(msg.sender, _to, _value); \t\t\t\t\t\t\t// Notify anyone listening that this transfer took place\r\n\t\t\t\treturn true;      \r\n\t\t\t}\r\n\t\t} \t\t\t\t\t\t\t\t\t\t\r\n\t\t\r\n\t\tbalances[msg.sender] -= _value;                          // Subtract from the sender\r\n\t\tbalances[_to] += _value;                                 // Add the same to the recipient                       \r\n\t\t \r\n\t\tTransfer(msg.sender, _to, _value); \t\t\t\t\t\t\t// Notify anyone listening that this transfer took place\r\n\t\treturn true;      \r\n    }\r\n    \r\n    /*send reward*/\r\n    function sendRewardBlockCDN(address rewarder, uint256 value) payable returns (bool success) {\r\n        if(msg.sender != owner) throw;\r\n\t\tif(now <= closeTime) throw;        \r\n\t\tif(!isFundedMini) throw;               \r\n        if( balances[owner] < value) throw;\r\n        balances[rewarder] += value;\r\n        uint256 halfValue  = value / 2;\r\n        balances[owner] -= halfValue;\r\n        totalSupply +=  halfValue;\r\n        Transfer(owner, rewarder, value);    \r\n        return true;\r\n       \r\n    }\r\n    \r\n    function modifyStartTime(uint256 _startTime) {\r\n\t\tif(msg.sender != owner) throw;\r\n        startTime = _startTime;\r\n    }\r\n    \r\n    function modifyCloseTime(uint256 _closeTime) {\r\n\t\tif(msg.sender != owner) throw;\r\n       closeTime = _closeTime;\r\n    }\r\n    \r\n    /*withDraw ethereum when closed fund*/\r\n    function withDrawEth(uint256 value) payable returns (bool success) {\r\n        if(now <= closeTime ) throw;\r\n        if(!isFundedMini) throw;\r\n        if(this.balance < value) throw;\r\n        if(msg.sender != owner) throw;\r\n        if(!msg.sender.send(value))\r\n            return false;\r\n        return true;\r\n    }\r\n}", 
  "balance": "144<b>.</b>194763574543184019 Ether", 
  "name": "blockcdn", 
  "transactions": "802", 
  "address": "0x1e797ce986c3cff4472f7d38d5c4aba55dfefe40"
 }, 
 {
  "source": "contract HFConditionalTransfer {\r\n    function transferIfHF(address to) {\r\n        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance > 1000000 ether)\r\n            to.send(msg.value);\r\n        else\r\n            msg.sender.send(msg.value);\r\n    }\r\n    function transferIfNoHF(address to) {\r\n        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance <= 1000000 ether)\r\n            to.send(msg.value);\r\n        else\r\n            msg.sender.send(msg.value);\r\n    }\r\n}", 
  "balance": "1<b>.</b>128 Ether", 
  "name": "HFConditionalTransfer", 
  "transactions": "790", 
  "address": "0xb671c3883307cf05bb3dff77a9754e87b4347195"
 }, 
 {
  "source": "pragma solidity ^ 0.4 .0;\r\n\r\n/*\r\n * Token - is a smart contract interface \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract TokenInterface {\r\n\r\n\r\n        // total amount of tokens\r\n        uint totalSupplyVar;\r\n\r\n\r\n        /**\r\n         *\r\n         * balanceOf() - constant function check concrete tokens balance  \r\n         *\r\n         *  @param owner - account owner\r\n         *  \r\n         *  @return the value of balance \r\n         */\r\n        function balanceOf(address owner) constant returns(uint256 balance);\r\n\r\n        function transfer(address to, uint256 value) returns(bool success);\r\n\r\n        function transferFrom(address from, address to, uint256 value) returns(bool success);\r\n\r\n        /**\r\n         *\r\n         * approve() - function approves to a person to spend some tokens from \r\n         *           owner balance. \r\n         *\r\n         *  @param spender - person whom this right been granted.\r\n         *  @param value   - value to spend.\r\n         * \r\n         *  @return true in case of succes, otherwise failure\r\n         * \r\n         */\r\n        function approve(address spender, uint256 value) returns(bool success);\r\n\r\n        /**\r\n         *\r\n         * allowance() - constant function to check how much is \r\n         *               permitted to spend to 3rd person from owner balance\r\n         *\r\n         *  @param owner   - owner of the balance\r\n         *  @param spender - permitted to spend from this balance person \r\n         *  \r\n         *  @return - remaining right to spend \r\n         * \r\n         */\r\n        function allowance(address owner, address spender) constant returns(uint256 remaining);\r\n\r\n        function totalSupply() constant returns(uint256 totalSupply) {\r\n                return totalSupplyVar;\r\n        }\r\n\r\n        // events notifications\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\npragma solidity ^ 0.4 .2;\r\n\r\n/*\r\n * StandardToken - is a smart contract  \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: \r\n *         https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is TokenInterface {\r\n\r\n\r\n        // token ownership\r\n        mapping(address => uint256) balances;\r\n\r\n        // spending permision management\r\n        mapping(address => mapping(address => uint256)) allowed;\r\n\r\n\r\n\r\n        function StandardToken() {}\r\n\r\n\r\n        /**\r\n         * transfer() - transfer tokens from msg.sender balance \r\n         *              to requested account\r\n         *\r\n         *  @param to    - target address to transfer tokens\r\n         *  @param value - ammount of tokens to transfer\r\n         *\r\n         *  @return - success / failure of the transaction\r\n         */\r\n        function transfer(address to, uint256 value) returns(bool success) {\r\n\r\n\r\n                if (balances[msg.sender] >= value && value > 0) {\r\n\r\n                        // do actual tokens transfer       \r\n                        balances[msg.sender] -= value;\r\n                        balances[to] += value;\r\n\r\n                        // rise the Transfer event\r\n                        Transfer(msg.sender, to, value);\r\n                        return true;\r\n                } else {\r\n\r\n                        return false;\r\n                }\r\n        }\r\n\r\n\r\n\r\n\r\n        /**\r\n         * transferFrom() - used to move allowed funds from other owner\r\n         *                  account \r\n         *\r\n         *  @param from  - move funds from account\r\n         *  @param to    - move funds to account\r\n         *  @param value - move the value \r\n         *\r\n         *  @return - return true on success false otherwise \r\n         */\r\n        function transferFrom(address from, address to, uint256 value) returns(bool success) {\r\n\r\n                if (balances[from] >= value &&\r\n                        allowed[from][msg.sender] >= value &&\r\n                        value > 0) {\r\n\r\n\r\n                        // do the actual transfer\r\n                        balances[from] -= value;\r\n                        balances[to] += value;\r\n\r\n\r\n                        // addjust the permision, after part of \r\n                        // permited to spend value was used\r\n                        allowed[from][msg.sender] -= value;\r\n\r\n                        // rise the Transfer event\r\n                        Transfer(from, to, value);\r\n                        return true;\r\n                } else {\r\n\r\n                        return false;\r\n                }\r\n        }\r\n\r\n\r\n\r\n\r\n        /**\r\n         *\r\n         * balanceOf() - constant function check concrete tokens balance  \r\n         *\r\n         *  @param owner - account owner\r\n         *  \r\n         *  @return the value of balance \r\n         */\r\n        function balanceOf(address owner) constant returns(uint256 balance) {\r\n                return balances[owner];\r\n        }\r\n\r\n\r\n\r\n        /**\r\n         *\r\n         * approve() - function approves to a person to spend some tokens from \r\n         *           owner balance. \r\n         *\r\n         *  @param spender - person whom this right been granted.\r\n         *  @param value   - value to spend.\r\n         * \r\n         *  @return true in case of succes, otherwise failure\r\n         * \r\n         */\r\n        function approve(address spender, uint256 value) returns(bool success) {\r\n\r\n\r\n\r\n                // now spender can use balance in \r\n                // ammount of value from owner balance\r\n                allowed[msg.sender][spender] = value;\r\n\r\n                // rise event about the transaction\r\n                Approval(msg.sender, spender, value);\r\n\r\n                return true;\r\n        }\r\n\r\n\r\n        /**\r\n         *\r\n         * allowance() - constant function to check how mouch is \r\n         *               permited to spend to 3rd person from owner balance\r\n         *\r\n         *  @param owner   - owner of the balance\r\n         *  @param spender - permited to spend from this balance person \r\n         *  \r\n         *  @return - remaining right to spend \r\n         * \r\n         */\r\n        function allowance(address owner, address spender) constant returns(uint256 remaining) {\r\n                return allowed[owner][spender];\r\n        }\r\n\r\n}\r\n\r\n\r\npragma solidity ^ 0.4 .0;\r\n\r\n/**\r\n *\r\n * @title Hacker Gold\r\n * \r\n * The official token powering the hack.ether.camp virtual accelerator.\r\n * This is the only way to acquire tokens from startups during the event.\r\n *\r\n * Whitepaper https://hack.ether.camp/whitepaper\r\n *\r\n */\r\ncontract HackerGold is StandardToken {\r\n\r\n        // Name of the token    \r\n        string public name = \"HackerGold\";\r\n\r\n        // Decimal places\r\n        uint8 public decimals = 3;\r\n        // Token abbreviation        \r\n        string public symbol = \"HKG\";\r\n\r\n        // 1 ether = 200 hkg\r\n        uint BASE_PRICE = 200;\r\n        // 1 ether = 150 hkg\r\n        uint MID_PRICE = 150;\r\n        // 1 ether = 100 hkg\r\n        uint FIN_PRICE = 100;\r\n        // Safety cap\r\n        uint SAFETY_LIMIT = 4000000 ether;\r\n        // Zeros after the point\r\n        uint DECIMAL_ZEROS = 1000;\r\n\r\n        // Total value in wei\r\n        uint totalValue;\r\n\r\n        // Address of multisig wallet holding ether from sale\r\n        address wallet;\r\n\r\n        // Structure of sale increase milestones\r\n        struct milestones_struct {\r\n                uint p1;\r\n                uint p2;\r\n                uint p3;\r\n                uint p4;\r\n                uint p5;\r\n                uint p6;\r\n        }\r\n        // Milestones instance\r\n        milestones_struct milestones;\r\n\r\n        /**\r\n         * Constructor of the contract.\r\n         * \r\n         * Passes address of the account holding the value.\r\n         * HackerGold contract itself does not hold any value\r\n         * \r\n         * @param multisig address of MultiSig wallet which will hold the value\r\n         */\r\n        function HackerGold(address multisig) {\r\n\r\n                wallet = multisig;\r\n\r\n                // set time periods for sale\r\n                milestones = milestones_struct(\r\n\r\n                        1476972000, // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n                        1478181600, // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n                        1479391200, // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                        //                                Hackathon Starts\r\n                        1480600800, // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n                        1481810400, // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n                        1482415200 // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n                );\r\n\r\n                // assign recovery balance\r\n                totalSupplyVar = 16110893000;\r\n                balances[0x342e62732b76875da9305083ea8ae63125a4e667] = 16110893000;\r\n                totalValue = 85362 ether;\r\n        }\r\n\r\n\r\n        /**\r\n         * Fallback function: called on ether sent.\r\n         * \r\n         * It calls to createHKG function with msg.sender \r\n         * as a value for holder argument\r\n         */\r\n        function() payable {\r\n                createHKG(msg.sender);\r\n        }\r\n\r\n        /**\r\n         * Creates HKG tokens.\r\n         * \r\n         * Runs sanity checks including safety cap\r\n         * Then calculates current price by getPrice() function, creates HKG tokens\r\n         * Finally sends a value of transaction to the wallet\r\n         * \r\n         * Note: due to lack of floating point types in Solidity,\r\n         * contract assumes that last 3 digits in tokens amount are stood after the point.\r\n         * It means that if stored HKG balance is 100000, then its real value is 100 HKG\r\n         * \r\n         * @param holder token holder\r\n         */\r\n        function createHKG(address holder) payable {\r\n\r\n                if (now < milestones.p1) throw;\r\n                if (now >= milestones.p6) throw;\r\n                if (msg.value == 0) throw;\r\n\r\n                // safety cap\r\n                if (getTotalValue() + msg.value > SAFETY_LIMIT) throw;\r\n\r\n                uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n                totalSupplyVar += tokens;\r\n                balances[holder] += tokens;\r\n                totalValue += msg.value;\r\n\r\n                if (!wallet.send(msg.value)) throw;\r\n        }\r\n\r\n        /**\r\n         * Denotes complete price structure during the sale.\r\n         *\r\n         * @return HKG amount per 1 ETH for the current moment in time\r\n         */\r\n        function getPrice() constant returns(uint result) {\r\n\r\n                if (now < milestones.p1) return 0;\r\n\r\n                if (now >= milestones.p1 && now < milestones.p2) {\r\n\r\n                        return BASE_PRICE;\r\n                }\r\n\r\n                if (now >= milestones.p2 && now < milestones.p3) {\r\n\r\n                        uint days_in = 1 + (now - milestones.p2) / 1 days;\r\n                        return BASE_PRICE - days_in * 25 / 7; // daily decrease 3.5\r\n                }\r\n\r\n                if (now >= milestones.p3 && now < milestones.p4) {\r\n\r\n                        return MID_PRICE;\r\n                }\r\n\r\n                if (now >= milestones.p4 && now < milestones.p5) {\r\n\r\n                        days_in = 1 + (now - milestones.p4) / 1 days;\r\n                        return MID_PRICE - days_in * 25 / 7; // daily decrease 3.5\r\n                }\r\n\r\n                if (now >= milestones.p5 && now < milestones.p6) {\r\n\r\n                        return FIN_PRICE;\r\n                }\r\n\r\n                if (now >= milestones.p6) {\r\n\r\n                        return 0;\r\n                }\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns total stored HKG amount.\r\n         * \r\n         * Contract assumes that last 3 digits of this value are behind the decimal place. i.e. 10001 is 10.001\r\n         * Thus, result of this function should be divided by 1000 to get HKG value\r\n         * \r\n         * @return result stored HKG amount\r\n         */\r\n        function getTotalSupply() constant returns(uint result) {\r\n                return totalSupplyVar;\r\n        }\r\n\r\n        /**\r\n         * It is used for test purposes.\r\n         * \r\n         * Returns the result of 'now' statement of Solidity language\r\n         * \r\n         * @return unix timestamp for current moment in time\r\n         */\r\n        function getNow() constant returns(uint result) {\r\n                return now;\r\n        }\r\n\r\n        /**\r\n         * Returns total value passed through the contract\r\n         * \r\n         * @return result total value in wei\r\n         */\r\n        function getTotalValue() constant returns(uint result) {\r\n                return totalValue;\r\n        }\r\n}", 
  "balance": "0 Ether", 
  "name": "HackerGold", 
  "transactions": "786", 
  "address": "0x14f37b574242d366558db61f3335289a5035c506"
 }, 
 {
  "source": "contract Vote {\r\n    event LogVote(address indexed addr);\r\n\r\n    function() {\r\n        LogVote(msg.sender);\r\n\r\n        if (msg.value > 0) {\r\n            msg.sender.send(msg.value);\r\n        }\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "Vote", 
  "transactions": "763", 
  "address": "0x3039d0a94d51c67a4f35e742b571874e53467804"
 }, 
 {
  "source": "// LooneyLottery that pays out the full pool once a day\r\n//\r\n// git: https://github.com/thelooneyfarm/contracts/tree/master/src/lottery\r\n// url: http://the.looney.farm/game/lottery\r\ncontract LooneyLottery {\r\n  // modifier for the owner protected functions\r\n  modifier owneronly {\r\n    // yeap, you need to own this contract to action it\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\r\n    // function execution inserted here\r\n    _\r\n  }\r\n\r\n  // constants for the Lehmer RNG\r\n  uint constant private LEHMER_MOD = 4294967291;\r\n  uint constant private LEHMER_MUL = 279470273;\r\n  uint constant private LEHMER_SDA = 1299709;\r\n  uint constant private LEHMER_SDB = 7919;\r\n\r\n  // various game-related constants, also available in the interface\r\n  uint constant public CONFIG_DURATION = 24 hours;\r\n  uint constant public CONFIG_MIN_PLAYERS  = 5;\r\n  uint constant public CONFIG_MAX_PLAYERS  = 222;\r\n  uint constant public CONFIG_MAX_TICKETS = 100;\r\n  uint constant public CONFIG_PRICE = 10 finney;\r\n  uint constant public CONFIG_FEES = 50 szabo;\r\n  uint constant public CONFIG_RETURN = CONFIG_PRICE - CONFIG_FEES;\r\n  uint constant public CONFIG_MIN_VALUE = CONFIG_PRICE;\r\n  uint constant public CONFIG_MAX_VALUE = CONFIG_PRICE * CONFIG_MAX_TICKETS;\r\n\r\n  // our owner, stored for owner-related functions\r\n  address private owner = msg.sender;\r\n\r\n  // basic initialisation for the RNG\r\n  uint private random = uint(sha3(block.coinbase, block.blockhash(block.number - 1), now));\r\n  uint private seeda = LEHMER_SDA;\r\n  uint private seedb = LEHMER_SDB;\r\n\r\n  // we allow 222 * 100 max tickets, allocate a bit more and store the mapping of entry => address\r\n  uint8[22500] private tickets;\r\n  mapping (uint => address) private players;\r\n\r\n  // public game-related values\r\n  uint public round = 1;\r\n  uint public numplayers = 0;\r\n  uint public numtickets = 0;\r\n  uint public start = now;\r\n  uint public end = start + CONFIG_DURATION;\r\n\r\n  // lifetime stats\r\n  uint public txs = 0;\r\n  uint public tktotal = 0;\r\n  uint public turnover = 0;\r\n\r\n  // nothing much to do in the constructor, we have the owner set & init done\r\n  function LooneyLottery() {\r\n  }\r\n\r\n  // owner withdrawal of fees\r\n  function ownerWithdraw() owneronly public {\r\n    // calculate the fees collected previously (excluding current round)\r\n    uint fees = this.balance - (numtickets * CONFIG_PRICE);\r\n\r\n    // return it if we have someting\r\n    if (fees > 0) {\r\n      owner.call.value(fees)();\r\n    }\r\n  }\r\n\r\n  // calculate the next random number with a two-phase Lehmer\r\n  function randomize() private {\r\n    // calculate the next seed for the first phase\r\n    seeda = (seeda * LEHMER_MUL) % LEHMER_MOD;\r\n\r\n    // adjust the random accordingly, getting extra info from the blockchain together with the seeds\r\n    random ^= uint(sha3(block.coinbase, block.blockhash(block.number - 1), seeda, seedb));\r\n\r\n    // adjust the second phase seed for the next iteration\r\n    seedb = (seedb * LEHMER_MUL) % LEHMER_MOD;\r\n  }\r\n\r\n  // pick a random winner when the time is right\r\n  function pickWinner() private {\r\n    // do we have >222 players or >= 5 tickets and an expired timer\r\n    if ((numplayers >= CONFIG_MAX_PLAYERS ) || ((numplayers >= CONFIG_MIN_PLAYERS ) && (now > end))) {\r\n      // get the winner based on the number of tickets (each player has multiple tickets)\r\n      uint winidx = tickets[random % numtickets];\r\n      uint output = numtickets * CONFIG_RETURN;\r\n\r\n      // send the winnings to the winner and let the world know\r\n      players[winidx].call.value(output)();\r\n      notifyWinner(players[winidx], output);\r\n\r\n      // reset the round, and start a new one\r\n      numplayers = 0;\r\n      numtickets = 0;\r\n      start = now;\r\n      end = start + CONFIG_DURATION;\r\n      round++;\r\n    }\r\n  }\r\n\r\n  // allocate tickets to the entry based on the value of the transaction\r\n  function allocateTickets(uint number) private {\r\n    // the last index of the ticket we will be adding to the pool\r\n    uint ticketmax = numtickets + number;\r\n\r\n    // loop through and allocate a ticket based on the number bought\r\n    for (uint idx = numtickets; idx < ticketmax; idx++) {\r\n      tickets[idx] = uint8(numplayers);\r\n    }\r\n\r\n    // our new value of total tickets (for this round) is the same as max, store it\r\n    numtickets = ticketmax;\r\n\r\n    // store the actual player info so we can reference it from the tickets\r\n    players[numplayers] = msg.sender;\r\n    numplayers++;\r\n\r\n    // let the world know that we have yet another player\r\n    notifyPlayer(number);\r\n  }\r\n\r\n  // we only have a default function, send an amount and it gets allocated, no ABI needed\r\n  function() public {\r\n    // oops, we need at least 10 finney to play :(\r\n    if (msg.value < CONFIG_MIN_VALUE) {\r\n      throw;\r\n    }\r\n\r\n    // adjust the random value based on the pseudo rndom inputs\r\n    randomize();\r\n\r\n    // pick a winner at the end of a round\r\n    pickWinner();\r\n\r\n    // here we store the number of tickets in this transaction\r\n    uint number = 0;\r\n\r\n    // get either a max number based on the over-the-top entry or calculate based on inputs\r\n    if (msg.value >= CONFIG_MAX_VALUE) {\r\n      number = CONFIG_MAX_TICKETS;\r\n    } else {\r\n      number = msg.value / CONFIG_PRICE;\r\n    }\r\n\r\n    // overflow is the value to be returned, >max or not a multiple of min\r\n    uint input = number * CONFIG_PRICE;\r\n    uint overflow = msg.value - input;\r\n\r\n    // store the actual turnover, transaction increment and total tickets\r\n    turnover += input;\r\n    tktotal += number;\r\n    txs += 1;\r\n\r\n    // allocate the actual tickets now\r\n    allocateTickets(number);\r\n\r\n    // send back the overflow where applicable\r\n    if (overflow > 0) {\r\n      msg.sender.call.value(overflow)();\r\n    }\r\n  }\r\n\r\n  // log events\r\n  event Player(address addr, uint32 at, uint32 round, uint32 tickets, uint32 numtickets, uint tktotal, uint turnover);\r\n  event Winner(address addr, uint32 at, uint32 round, uint32 numtickets, uint output);\r\n\r\n  // notify that a new player has entered the fray\r\n  function notifyPlayer(uint number) private {\r\n    Player(msg.sender, uint32(now), uint32(round), uint32(number), uint32(numtickets), tktotal, turnover);\r\n  }\r\n\r\n  // create the Winner event and send it\r\n  function notifyWinner(address addr, uint output) private {\r\n    Winner(addr, uint32(now), uint32(round), uint32(numtickets), output);\r\n  }\r\n}", 
  "balance": "0<b>.</b>01 Ether", 
  "name": "LooneyLottery", 
  "transactions": "753", 
  "address": "0x2ef76694fbfd691141d83f921a5ba710525de9b0"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "20,471<b>.</b>2717400305837778 Ether", 
  "name": "Wallet", 
  "transactions": "749", 
  "address": "0xa2d4035389aae620e36bd828144b2015564c2702"
 }, 
 {
  "source": "pragma solidity ^0.4.2;\r\n\r\ncontract Token {\r\n\tfunction balanceOf(address user) constant returns (uint256 balance);\r\n\tfunction transfer(address receiver, uint amount) returns(bool);\r\n}\r\n\r\ncontract BonusDealer {\r\n    address public owner;\r\n    Token public nexium;\r\n    uint public totalDistributed;\r\n    address[] public paidAddress;\r\n    mapping(address => uint) public paid;\r\n    \r\n    struct Bonus {\r\n        uint bonusInNxc;\r\n        uint step;\r\n    }\r\n    \r\n    Bonus[] bonuses;\r\n    \r\n    event Paid(address);\r\n    \r\n    uint nxcBought;\r\n    \r\n    function BonusDealer(){\r\n        nexium = Token(0x45e42D659D9f9466cD5DF622506033145a9b89Bc);\r\n        owner = msg.sender;\r\n        totalDistributed = 0;\r\n        bonuses.length++;\r\n        bonuses[0] = Bonus(0, 0);\r\n        bonuses.length++;\r\n        bonuses[1] = Bonus(80*1000, 4000*1000);\r\n        bonuses.length++;\r\n        bonuses[2] = Bonus(640*1000, 16000*1000);\r\n        bonuses.length++;\r\n        bonuses[3] = Bonus(3000*1000, 50000*1000);\r\n        bonuses.length++;\r\n        bonuses[4] = Bonus(8000*1000, 100000*1000);\r\n        bonuses.length++;\r\n        bonuses[5] = Bonus(40000*1000, 400000*1000);\r\n        bonuses.length++;\r\n        bonuses[6] = Bonus(78000*1000, 650000*1000);\r\n        bonuses.length++;\r\n        bonuses[7] = Bonus(140000*1000, 1000000*1000);\r\n        bonuses.length++;\r\n        bonuses[8] = Bonus(272000*1000, 1700000*1000);\r\n    }\r\n    \r\n    function bonusCalculation(uint _nxcBought) returns(uint){\r\n        nxcBought = _nxcBought;\r\n        uint totalToPay = 0;\r\n        uint toAdd = 1;\r\n        while (toAdd != 0){\r\n            toAdd = recursiveCalculation();\r\n            totalToPay += toAdd;\r\n        }\r\n        \r\n        return totalToPay;\r\n    }\r\n    \r\n    function recursiveCalculation() internal returns(uint){\r\n        var i = 8;\r\n        while (i != 0 && bonuses[i].step > nxcBought) i--;\r\n        nxcBought -= bonuses[i].step;\r\n        return bonuses[i].bonusInNxc;\r\n    }\r\n    \r\n    function payDiff(address backer, uint totalNxcBought){\r\n        if (msg.sender != owner) throw;\r\n        if (paid[backer] == 0) paidAddress[paidAddress.length++] = msg.sender;\r\n        uint totalToPay = bonusCalculation(totalNxcBought);\r\n        if(totalToPay <= paid[backer]) throw;\r\n        totalToPay -= paid[backer];\r\n        if (!nexium.transfer(backer, totalToPay)) throw;\r\n        paid[backer] += totalToPay;\r\n        totalDistributed += totalToPay;\r\n        Paid(backer);\r\n    }\r\n    \r\n    function withdrawNexiums(address a){\r\n        if (msg.sender != owner) throw;\r\n        nexium.transfer(a, nexium.balanceOf(this));\r\n    }\r\n    \r\n    function(){\r\n        throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "BonusDealer", 
  "transactions": "728", 
  "address": "0xe8200511f3c276fa7300719f9b45301bc471f4fb"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "0<b>.</b>502226625984290463 Ether", 
  "name": "Wallet", 
  "transactions": "695", 
  "address": "0x0d0982a2bf44619962dda80da6129f566ff58980"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "0 Ether", 
  "name": "Wallet", 
  "transactions": "680", 
  "address": "0x4252672e258530daf201f49a6b737514841af30f"
 }, 
 {
  "source": "contract Token { \r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\n// replay protection\r\ncontract ReplayProtection {\r\n    bool public isMainChain;\r\n\r\n    function ReplayProtection() {\r\n        bytes32 blockHash = 0xcf9055c648b3689a2b74e980fc6fa27817622fa9ac0749d60a6489a7fbcfe831;\r\n        // creates a unique signature with the latest 16 blocks\r\n        for (uint i = 1; i < 64; i++) {\r\n            if (blockHash == block.blockhash(block.number - i)) isMainChain = true;\r\n        }\r\n    }\r\n\r\n    // Splits the funds into 2 addresses\r\n    function etherSplit(address recipient, address altChainRecipient) returns(bool) {\r\n        if (isMainChain && recipient.send(msg.value)) {\r\n            return true;\r\n        } else if (!isMainChain && altChainRecipient > 0 && altChainRecipient.send(msg.value)) {\r\n            return true;\r\n        }\r\n        throw; // don't accept value transfer, otherwise it would be trapped.\r\n    }\r\n\r\n\r\n    function tokenSplit(address recipient, address altChainRecipient, address tokenAddress, uint amount) returns (bool) {\r\n        if (msg.value > 0 ) throw;\r\n\r\n        Token token = Token(tokenAddress);\r\n\r\n        if (isMainChain && token.transferFrom(msg.sender, recipient, amount)) {\r\n            return true;\r\n        } else if (!isMainChain && altChainRecipient > 0 && token.transferFrom(msg.sender, altChainRecipient, amount)) {\r\n            return true;\r\n        }\r\n        throw;\r\n    }\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ReplayProtection", 
  "transactions": "674", 
  "address": "0x1ca4a86bba124426507d1ef67ad271cc5a02820a"
 }, 
 {
  "source": "contract MultiAsset {\r\n    function isCreated(bytes32 _symbol) constant returns(bool);\r\n    function owner(bytes32 _symbol) constant returns(address);\r\n    function totalSupply(bytes32 _symbol) constant returns(uint);\r\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\r\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\r\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\r\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\r\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\r\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\r\n    function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\r\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\r\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\r\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\r\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\r\n}\r\n\r\ncontract Ambi {\r\n    function getNodeAddress(bytes32 _name) constant returns (address);\r\n    function addNode(bytes32 _name, address _addr) external returns (bool);\r\n    function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool);\r\n}\r\n\r\ncontract EtherTreasuryInterface {\r\n    function withdraw(address _to, uint _value) returns(bool);\r\n}\r\n\r\ncontract Safe {\r\n    // Should always be placed as first modifier!\r\n    modifier noValue {\r\n        if (msg.value > 0) {\r\n            // Internal Out Of Gas/Throw: revert this transaction too;\r\n            // Call Stack Depth Limit reached: revert this transaction too;\r\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\r\n            _safeSend(msg.sender, msg.value);\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier onlyHuman {\r\n        if (_isHuman()) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier noCallback {\r\n        if (!isCall) {\r\n            _\r\n        }\r\n    }\r\n\r\n    modifier immutable(address _address) {\r\n        if (_address == 0) {\r\n            _\r\n        }\r\n    }\r\n\r\n    address stackDepthLib;\r\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\r\n        stackDepthLib = _stackDepthLib;\r\n        return true;\r\n    }\r\n\r\n    modifier requireStackDepth(uint16 _depth) {\r\n        if (stackDepthLib == 0x0) {\r\n            throw;\r\n        }\r\n        if (_depth > 1023) {\r\n            throw;\r\n        }\r\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\r\n            throw;\r\n        }\r\n        _\r\n    }\r\n\r\n    // Must not be used inside the functions that have noValue() modifier!\r\n    function _safeFalse() internal noValue() returns(bool) {\r\n        return false;\r\n    }\r\n\r\n    function _safeSend(address _to, uint _value) internal {\r\n        if (!_unsafeSend(_to, _value)) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\r\n        return _to.call.value(_value)();\r\n    }\r\n\r\n    function _isContract() constant internal returns(bool) {\r\n        return msg.sender != tx.origin;\r\n    }\r\n\r\n    function _isHuman() constant internal returns(bool) {\r\n        return !_isContract();\r\n    }\r\n\r\n    bool private isCall = false;\r\n    function _setupNoCallback() internal {\r\n        isCall = true;\r\n    }\r\n\r\n    function _finishNoCallback() internal {\r\n        isCall = false;\r\n    }\r\n}\r\n\r\ncontract Asset is Safe {\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approve(address indexed from, address indexed spender, uint value);\r\n\r\n    MultiAsset public multiAsset;\r\n    bytes32 public symbol;\r\n\r\n    function init(address _multiAsset, bytes32 _symbol) noValue() immutable(address(multiAsset)) returns(bool) {\r\n        MultiAsset ma = MultiAsset(_multiAsset);\r\n        if (!ma.isCreated(_symbol)) {\r\n            return false;\r\n        }\r\n        multiAsset = ma;\r\n        symbol = _symbol;\r\n        return true;\r\n    }\r\n\r\n    modifier onlyMultiAsset() {\r\n        if (msg.sender == address(multiAsset)) {\r\n            _\r\n        }\r\n    }\r\n\r\n    function totalSupply() constant returns(uint) {\r\n        return multiAsset.totalSupply(symbol);\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns(uint) {\r\n        return multiAsset.balanceOf(_owner, symbol);\r\n    }\r\n\r\n    function allowance(address _from, address _spender) constant returns(uint) {\r\n        return multiAsset.allowance(_from, _spender, symbol);\r\n    }\r\n\r\n    function transfer(address _to, uint _value) returns(bool) {\r\n        return __transferWithReference(_to, _value, \"\");\r\n    }\r\n\r\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\r\n        return __transferWithReference(_to, _value, _reference);\r\n    }\r\n\r\n    function __transferWithReference(address _to, uint _value, string _reference) private noValue() returns(bool) {\r\n        return _isHuman() ?\r\n            multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) :\r\n            multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference);\r\n    }\r\n\r\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\r\n        return __transferToICAPWithReference(_icap, _value, \"\");\r\n    }\r\n\r\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\r\n        return __transferToICAPWithReference(_icap, _value, _reference);\r\n    }\r\n\r\n    function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private noValue() returns(bool) {\r\n        return _isHuman() ?\r\n            multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) :\r\n            multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\r\n        return __transferFromWithReference(_from, _to, _value, \"\");\r\n    }\r\n\r\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\r\n        return __transferFromWithReference(_from, _to, _value, _reference);\r\n    }\r\n\r\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\r\n        return multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference);\r\n    }\r\n\r\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\r\n        return __transferFromToICAPWithReference(_from, _icap, _value, \"\");\r\n    }\r\n\r\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\r\n        return __transferFromToICAPWithReference(_from, _icap, _value, _reference);\r\n    }\r\n\r\n    function __transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\r\n        return multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference);\r\n    }\r\n\r\n    function approve(address _spender, uint _value) noValue() onlyHuman() returns(bool) {\r\n        return multiAsset.proxyApprove(_spender, _value, symbol);\r\n    }\r\n\r\n    function setCosignerAddress(address _cosigner) noValue() onlyHuman() returns(bool) {\r\n        return multiAsset.proxySetCosignerAddress(_cosigner, symbol);\r\n    }\r\n\r\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\r\n        Approve(_from, _spender, _value);\r\n    }\r\n\r\n    function sendToOwner() noValue() returns(bool) {\r\n        address owner = multiAsset.owner(symbol);\r\n        uint balance = this.balance;\r\n        bool success = true;\r\n        if (balance > 0) {\r\n            success = _unsafeSend(owner, balance);\r\n        }\r\n        return multiAsset.transfer(owner, balanceOf(owner), symbol) && success;\r\n    }\r\n}\r\n\r\ncontract AmbiEnabled {\r\n    Ambi public ambiC;\r\n    bool public isImmortal;\r\n    bytes32 public name;\r\n\r\n    modifier checkAccess(bytes32 _role) {\r\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\r\n            _\r\n        }\r\n    }\r\n    \r\n    function getAddress(bytes32 _name) constant returns (address) {\r\n        return ambiC.getNodeAddress(_name);\r\n    }\r\n\r\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\r\n        if(address(ambiC) != 0x0){\r\n            return false;\r\n        }\r\n        Ambi ambiContract = Ambi(_ambi);\r\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\r\n            if (!ambiContract.addNode(_name, address(this))){\r\n                return false;\r\n            }\r\n        }\r\n        name = _name;\r\n        ambiC = ambiContract;\r\n        return true;\r\n    }\r\n\r\n    function immortality() checkAccess(\"owner\") returns(bool) {\r\n        isImmortal = true;\r\n        return true;\r\n    }\r\n\r\n    function remove() checkAccess(\"owner\") returns(bool) {\r\n        if (isImmortal) {\r\n            return false;\r\n        }\r\n        selfdestruct(msg.sender);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract CryptoCarbon is Asset, AmbiEnabled {\r\n    uint public txGasPriceLimit = 21000000000;\r\n    uint public refundGas = 40000;\r\n    uint public transferCallGas = 21000;\r\n    uint public transferWithReferenceCallGas = 21000;\r\n    uint public transferFromCallGas = 21000;\r\n    uint public transferFromWithReferenceCallGas = 21000;\r\n    uint public transferToICAPCallGas = 21000;\r\n    uint public transferToICAPWithReferenceCallGas = 21000;\r\n    uint public transferFromToICAPCallGas = 21000;\r\n    uint public transferFromToICAPWithReferenceCallGas = 21000;\r\n    uint public approveCallGas = 21000;\r\n    uint public forwardCallGas = 21000;\r\n    uint public setCosignerCallGas = 21000;\r\n    uint public absMinFee;\r\n    uint public feePercent; // set up in 1/100 of percent, 10 is 0.1%\r\n    uint public absMaxFee;\r\n    EtherTreasuryInterface public treasury;\r\n    address public feeAddress;\r\n    bool private __isAllowed;\r\n    mapping(bytes32 => address) public allowedForwards;\r\n\r\n    function setFeeStructure(uint _absMinFee, uint _feePercent, uint _absMaxFee) noValue() checkAccess(\"cron\") returns (bool) {\r\n        if(_feePercent > 10000 || _absMaxFee < _absMinFee) {\r\n            return false;\r\n        }\r\n        absMinFee = _absMinFee;\r\n        feePercent = _feePercent;\r\n        absMaxFee = _absMaxFee;\r\n        return true;\r\n    }\r\n\r\n    function setupFee(address _feeAddress) noValue() checkAccess(\"admin\") returns(bool) {\r\n        feeAddress = _feeAddress;\r\n        return true;\r\n    }\r\n\r\n    function updateRefundGas() noValue() checkAccess(\"setup\") returns(uint) {\r\n        uint startGas = msg.gas;\r\n        // just to simulate calculations\r\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\r\n        if (tx.gasprice > txGasPriceLimit) {\r\n            return 0;\r\n        }\r\n        // end\r\n        if (!_refund(5000000000000000)) {\r\n            return 0;\r\n        }\r\n        refundGas = startGas - msg.gas;\r\n        return refundGas;\r\n    }\r\n\r\n    function setOperationsCallGas(\r\n        uint _transfer,\r\n        uint _transferFrom,\r\n        uint _transferToICAP,\r\n        uint _transferFromToICAP,\r\n        uint _transferWithReference,\r\n        uint _transferFromWithReference,\r\n        uint _transferToICAPWithReference,\r\n        uint _transferFromToICAPWithReference,\r\n        uint _approve,\r\n        uint _forward,\r\n        uint _setCosigner\r\n    )\r\n        noValue()\r\n        checkAccess(\"setup\")\r\n        returns(bool)\r\n    {\r\n        transferCallGas = _transfer;\r\n        transferFromCallGas = _transferFrom;\r\n        transferToICAPCallGas = _transferToICAP;\r\n        transferFromToICAPCallGas = _transferFromToICAP;\r\n        transferWithReferenceCallGas = _transferWithReference;\r\n        transferFromWithReferenceCallGas = _transferFromWithReference;\r\n        transferToICAPWithReferenceCallGas = _transferToICAPWithReference;\r\n        transferFromToICAPWithReferenceCallGas = _transferFromToICAPWithReference;\r\n        approveCallGas = _approve;\r\n        forwardCallGas = _forward;\r\n        setCosignerCallGas = _setCosigner;\r\n        return true;\r\n    }\r\n\r\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(\"admin\") returns(bool) {\r\n        if (_txGasPriceLimit == 0) {\r\n            return _safeFalse();\r\n        }\r\n        treasury = EtherTreasuryInterface(_treasury);\r\n        txGasPriceLimit = _txGasPriceLimit;\r\n        if (msg.value > 0) {\r\n            _safeSend(_treasury, msg.value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setForward(bytes4 _msgSig, address _forward) noValue() checkAccess(\"admin\") returns(bool) {\r\n        allowedForwards[sha3(_msgSig)] = _forward;\r\n        return true;\r\n    }\r\n\r\n    function _stringGas(string _string) constant internal returns(uint) {\r\n        return bytes(_string).length * 75; // ~75 gas per byte, empirical shown 68-72.\r\n    }\r\n\r\n    function _transferFee(address _feeFrom, uint _value, string _reference) internal returns(bool) {\r\n        if (feeAddress == 0x0 || feeAddress == _feeFrom || _value == 0) {\r\n            return true;\r\n        }\r\n        return multiAsset.transferFromWithReference(_feeFrom, feeAddress, _value, symbol, _reference);\r\n    }\r\n\r\n    function _returnFee(address _to, uint _value) internal returns(bool, bool) {\r\n        if (feeAddress == 0x0 || feeAddress == _to || _value == 0) {\r\n            return (false, true);\r\n        }\r\n        if (!multiAsset.transferFromWithReference(feeAddress, _to, _value, symbol, \"Fee return\")) {\r\n            throw;\r\n        }\r\n        return (false, true);\r\n    }\r\n\r\n    function _applyRefund(uint _startGas) internal returns(bool) {\r\n        uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice;\r\n        return _refund(refund);\r\n    }\r\n\r\n    function _refund(uint _value) internal returns(bool) {\r\n        if (tx.gasprice > txGasPriceLimit) {\r\n            return false;\r\n        }\r\n        return treasury.withdraw(tx.origin, _value);\r\n    }\r\n\r\n    function _allow() internal {\r\n        __isAllowed = true;\r\n    }\r\n\r\n    function _disallow() internal {\r\n        __isAllowed = false;\r\n    }\r\n\r\n    function calculateFee(uint _value) constant returns(uint) {\r\n        uint fee = (_value * feePercent) / 10000;\r\n        if (fee < absMinFee) {\r\n            return absMinFee;\r\n        }\r\n        if (fee > absMaxFee) {\r\n            return absMaxFee;\r\n        }\r\n        return fee;\r\n    }\r\n\r\n    function calculateFeeDynamic(uint _value, uint _additionalGas) constant returns(uint) {\r\n        uint fee = calculateFee(_value);\r\n        if (_additionalGas <= 7500) {\r\n            return fee;\r\n        }\r\n        // Assuming that absMinFee covers at least 100000 gas refund, let's add another absMinFee\r\n        // for every other 100000 additional gas.\r\n        uint additionalFee = ((_additionalGas / 100000) + 1) * absMinFee;\r\n        return fee + additionalFee;\r\n    }\r\n\r\n    function takeFee(address _feeFrom, uint _value, string _reference) noValue() checkAccess(\"fee\") returns(bool) {\r\n        return _transferFee(_feeFrom, _value, _reference);\r\n    }\r\n\r\n    function _transfer(address _to, uint _value) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + transferCallGas;\r\n        uint fee = calculateFee(_value);\r\n        if (!_transferFee(msg.sender, fee, \"Transfer fee\")) {\r\n            return (false, false);\r\n        }\r\n        _allow();\r\n        bool success = super.transfer(_to, _value);\r\n        _disallow();\r\n        if (!success) {\r\n            return _returnFee(msg.sender, fee);\r\n        }\r\n        return (true, _applyRefund(startGas));\r\n    }\r\n\r\n    function _transferFrom(address _from, address _to, uint _value) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + transferFromCallGas;\r\n        _allow();\r\n        uint fee = calculateFee(_value);\r\n        if (!_transferFee(_from, fee, \"Transfer fee\")) {\r\n            return (false, false);\r\n        }\r\n        _allow();\r\n        bool success = super.transferFrom(_from, _to, _value);\r\n        _disallow();\r\n        if (!success) {\r\n            return _returnFee(_from, fee);\r\n        }\r\n        return (true, _applyRefund(startGas));\r\n    }\r\n\r\n    function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + transferToICAPCallGas;\r\n        uint fee = calculateFee(_value);\r\n        if (!_transferFee(msg.sender, fee, \"Transfer fee\")) {\r\n            return (false, false);\r\n        }\r\n        _allow();\r\n        bool success = super.transferToICAP(_icap, _value);\r\n        _disallow();\r\n        if (!success) {\r\n            return _returnFee(msg.sender, fee);\r\n        }\r\n        return (true, _applyRefund(startGas));\r\n    }\r\n\r\n    function _transferFromToICAP(address _from, bytes32 _icap, uint _value) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + transferFromToICAPCallGas;\r\n        uint fee = calculateFee(_value);\r\n        if (!_transferFee(_from, fee, \"Transfer fee\")) {\r\n            return (false, false);\r\n        }\r\n        _allow();\r\n        bool success = super.transferFromToICAP(_from, _icap, _value);\r\n        _disallow();\r\n        if (!success) {\r\n            return _returnFee(_from, fee);\r\n        }\r\n        return (true, _applyRefund(startGas));\r\n    }\r\n\r\n    function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + transferWithReferenceCallGas;\r\n        uint additionalGas = _stringGas(_reference);\r\n        uint fee = calculateFeeDynamic(_value, additionalGas);\r\n        if (!_transferFee(msg.sender, fee, \"Transfer fee\")) {\r\n            return (false, false);\r\n        }\r\n        _allow();\r\n        bool success = super.transferWithReference(_to, _value, _reference);\r\n        _disallow();\r\n        if (!success) {\r\n            return _returnFee(msg.sender, fee);\r\n        }\r\n        return (true, _applyRefund(startGas + additionalGas));\r\n    }\r\n\r\n    function _transferFromWithReference(address _from, address _to, uint _value, string _reference) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + transferFromWithReferenceCallGas;\r\n        uint additionalGas = _stringGas(_reference);\r\n        uint fee = calculateFeeDynamic(_value, additionalGas);\r\n        if (!_transferFee(_from, fee, \"Transfer fee\")) {\r\n            return (false, false);\r\n        }\r\n        _allow();\r\n        bool success = super.transferFromWithReference(_from, _to, _value, _reference);\r\n        _disallow();\r\n        if (!success) {\r\n            return _returnFee(_from, fee);\r\n        }\r\n        return (true, _applyRefund(startGas + additionalGas));\r\n    }\r\n\r\n    function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + transferToICAPWithReferenceCallGas;\r\n        uint additionalGas = _stringGas(_reference);\r\n        uint fee = calculateFeeDynamic(_value, additionalGas);\r\n        if (!_transferFee(msg.sender, fee, \"Transfer fee\")) {\r\n            return (false, false);\r\n        }\r\n        _allow();\r\n        bool success = super.transferToICAPWithReference(_icap, _value, _reference);\r\n        _disallow();\r\n        if (!success) {\r\n            return _returnFee(msg.sender, fee);\r\n        }\r\n        return (true, _applyRefund(startGas + additionalGas));\r\n    }\r\n\r\n    function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + transferFromToICAPWithReferenceCallGas;\r\n        uint additionalGas = _stringGas(_reference);\r\n        uint fee = calculateFeeDynamic(_value, additionalGas);\r\n        if (!_transferFee(_from, fee, \"Transfer fee\")) {\r\n            return (false, false);\r\n        }\r\n        _allow();\r\n        bool success = super.transferFromToICAPWithReference(_from, _icap, _value, _reference);\r\n        _disallow();\r\n        if (!success) {\r\n            return _returnFee(_from, fee);\r\n        }\r\n        return (true, _applyRefund(startGas + additionalGas));\r\n    }\r\n\r\n    function _approve(address _spender, uint _value) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + approveCallGas;\r\n        // Don't take fee when enabling fee taking.\r\n        // Don't refund either.\r\n        if (_spender == address(this)) {\r\n            return (super.approve(_spender, _value), false);\r\n        }\r\n        uint fee = calculateFee(0);\r\n        if (!_transferFee(msg.sender, fee, \"Approve fee\")) {\r\n            return (false, false);\r\n        }\r\n        _allow();\r\n        bool success = super.approve(_spender, _value);\r\n        _disallow();\r\n        if (!success) {\r\n            return _returnFee(msg.sender, fee);\r\n        }\r\n        return (true, _applyRefund(startGas));\r\n    }\r\n\r\n    function _setCosignerAddress(address _cosigner) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + setCosignerCallGas;\r\n        uint fee = calculateFee(0);\r\n        if (!_transferFee(msg.sender, fee, \"Cosigner fee\")) {\r\n            return (false, false);\r\n        }\r\n        if (!super.setCosignerAddress(_cosigner)) {\r\n            return _returnFee(msg.sender, fee);\r\n        }\r\n        return (true, _applyRefund(startGas));\r\n    }\r\n\r\n    function transfer(address _to, uint _value) returns(bool) {\r\n        bool success;\r\n        (success,) = _transfer(_to, _value);\r\n        return success;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\r\n        bool success;\r\n        (success,) = _transferFrom(_from, _to, _value);\r\n        return success;\r\n    }\r\n\r\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\r\n        bool success;\r\n        (success,) = _transferToICAP(_icap, _value);\r\n        return success;\r\n    }\r\n\r\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\r\n        bool success;\r\n        (success,) = _transferFromToICAP(_from, _icap, _value);\r\n        return success;\r\n    }\r\n\r\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\r\n        bool success;\r\n        (success,) = _transferWithReference(_to, _value, _reference);\r\n        return success;\r\n    }\r\n\r\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\r\n        bool success;\r\n        (success,) = _transferFromWithReference(_from, _to, _value, _reference);\r\n        return success;\r\n    }\r\n\r\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\r\n        bool success;\r\n        (success,) = _transferToICAPWithReference(_icap, _value, _reference);\r\n        return success;\r\n    }\r\n\r\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\r\n        bool success;\r\n        (success,) = _transferFromToICAPWithReference(_from, _icap, _value, _reference);\r\n        return success;\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns(bool) {\r\n        bool success;\r\n        (success,) = _approve(_spender, _value);\r\n        return success;\r\n    }\r\n\r\n    function setCosignerAddress(address _cosigner) returns(bool) {\r\n        bool success;\r\n        (success,) = _setCosignerAddress(_cosigner);\r\n        return success;\r\n    }\r\n\r\n    function checkTransfer(address _to, uint _value) constant returns(bool, bool) {\r\n        return _transfer(_to, _value);\r\n    }\r\n\r\n    function checkTransferFrom(address _from, address _to, uint _value) constant returns(bool, bool) {\r\n        return _transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) {\r\n        return _transferToICAP(_icap, _value);\r\n    }\r\n\r\n    function checkTransferFromToICAP(address _from, bytes32 _icap, uint _value) constant returns(bool, bool) {\r\n        return _transferFromToICAP(_from, _icap, _value);\r\n    }\r\n\r\n    function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) {\r\n        return _transferWithReference(_to, _value, _reference);\r\n    }\r\n\r\n    function checkTransferFromWithReference(address _from, address _to, uint _value, string _reference) constant returns(bool, bool) {\r\n        return _transferFromWithReference(_from, _to, _value, _reference);\r\n    }\r\n\r\n    function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\r\n        return _transferToICAPWithReference(_icap, _value, _reference);\r\n    }\r\n\r\n    function checkTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\r\n        return _transferFromToICAPWithReference(_from, _icap, _value, _reference);\r\n    }\r\n\r\n    function checkApprove(address _spender, uint _value) constant returns(bool, bool) {\r\n        return _approve(_spender, _value);\r\n    }\r\n\r\n    function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) {\r\n        return _setCosignerAddress(_cosigner);\r\n    }\r\n\r\n    function checkForward(bytes _data) constant returns(bool, bool) {\r\n        return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);\r\n    }\r\n\r\n    function _forward(address _to, bytes _data) internal returns(bool, bool) {\r\n        uint startGas = msg.gas + forwardCallGas;\r\n        uint additionalGas = (_data.length * 50);  // 50 gas per byte;\r\n        if (_to == 0x0) {\r\n            return (false, _safeFalse());\r\n        }\r\n        uint fee = calculateFeeDynamic(0, additionalGas);\r\n        if (!_transferFee(msg.sender, fee, \"Forward fee\")) {\r\n            return (false, false);\r\n        }\r\n        if (!_to.call.value(msg.value)(_data)) {\r\n            _returnFee(msg.sender, fee);\r\n            return (false, _safeFalse());\r\n        }\r\n        return (true, _applyRefund(startGas + additionalGas));\r\n    }\r\n\r\n    function () returns(bool) {\r\n        bool success;\r\n        (success,) = _forward(allowedForwards[sha3(msg.sig)], msg.data);\r\n        return success;\r\n    }\r\n\r\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\r\n        Transfer(_from, _to, _value);\r\n        if (__isAllowed) {\r\n            return;\r\n        }\r\n        if (feeAddress == 0x0 || _to == feeAddress || _from == feeAddress) {\r\n            return;\r\n        }\r\n        if (_transferFee(_from, calculateFee(_value), \"Transfer fee\")) {\r\n            return;\r\n        }\r\n        throw;\r\n    }\r\n\r\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\r\n        Approve(_from, _spender, _value);\r\n        if (__isAllowed) {\r\n            return;\r\n        }\r\n        if (feeAddress == 0x0 || _spender == address(this)) {\r\n            return;\r\n        }\r\n        if (_transferFee(_from, calculateFee(0), \"Approve fee\")) {\r\n            return;\r\n        }\r\n        throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "CryptoCarbon", 
  "transactions": "660", 
  "address": "0xe4c94d45f7aef7018a5d66f44af780ec6023378e"
 }, 
 {
  "source": "//                       , ; ,   .-'\"\"\"'-.   , ; ,\r\n//                       \\\\|/  .'          '.  \\|//\r\n//                        \\-;-/   ()   ()   \\-;-/\r\n//                        // ;               ; \\\\\r\n//                       //__; :.         .; ;__\\\\\r\n//                      `-----\\'.'-.....-'.'/-----'\r\n//                             '.'.-.-,_.'.'\r\n//                               '(  (..-'\r\n//                                 '-'\r\n//   WHYSOS3RIOUS   PRESENTS :   \r\n//   The ROULETH \r\n//\r\n//  Play the Roulette on ethereum blockchain !\r\n//  (or become an investor in the Casino and share the profits/losses.) \r\n//\r\n//\r\n//   website : www.WhySoS3rious.com/Rouleth\r\n//               with a flashy roulette :) !\r\n//\r\n//   check latest contract version on website\r\n//   V 1.0.2\r\n//\r\n// *** coded by WhySoS3rious, 2016.                                       ***//\r\n// *** please do not copy without authorization                          ***//\r\n// *** contact : reddit    /u/WhySoS3rious                               ***//\r\n//\r\n//\r\n//  Stake : Variable, check on website for the max bet.\r\n//  At launch the max stake is 0.05 ETH\r\n//\r\n//\r\n//  How to play ?\r\n//  1) Simplest (via transactions from your wallet, not an exchange) : \r\n//  Just send the value you want to bet to the contract and add enough gas \r\n//  (you can enter the max gas amount of ~4,5Million, any excess is refunded anyways)\r\n//  This will by default place a bet on number 7\r\n//  Wait 2 minutes (6 blocks) and send (with enough gas) 1 wei (or any amount, it will be refunded)\r\n//  This will spin the wheel and you will receive * 35 your bet if you win.\r\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\r\n//\r\n//  2) Advanced (via contract functions, e.g. Mist, cf. tutorial on my website for more details) :\r\n//  Import the contract in Mist wallet using the code of the ABI (link on my website)\r\n//  Use the functions (betOnNumber, betOnColor ...) to place any type of bet you want\r\n//  Provide the appropriate input (ex: check box Red or Black)\r\n//  add the amount you want to bet.\r\n//  wait 6 blocks, then use the function spinTheWheel, this will solve the bet.\r\n//  You can only place one bet at a time before you spin the wheel.\r\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\r\n//\r\n//\r\n//\r\n//  Use the website to track your bets and the results of the spins\r\n//\r\n//\r\n//   How to invest ?\r\n//   Import the contract in Mist Wallet using the code of the ABI (link on my website)\r\n//   Use the Invest function with an amount >10 Ether (can change, check on my website)\r\n//   You will become an investor and share the profits and losses of the roulette\r\n//   proportionally to your investment. There is a 2% fee on investment to help with the server/website\r\n//   cost and also 2% on profit that go to the developper.\r\n//   The rest of your investment goes directly to the payroll and 98% of profits are shared between \r\n//   investors relatively to their share of total. Losses are split similarly.\r\n//   You can withdraw your funds at any time after the initial lock period (set to 1 week)\r\n//   To withdraw use the function withdraw and specify the amoutn you want to withdraw in Wei.\r\n//   If your withdraw brings your investment under 10 eth (the min invest, subject to change)\r\n//   then you will execute a full withdraw and stop being an investor.\r\n//   Check your current investor balance in Mist by using the information functions on the left side\r\n//   If you want to update the balances to the last state (otherwise they are automatically\r\n//   updated after each invest or withdraw), you can use the function manualUpdateBalances in Mist.\r\n//   \r\n//   The casino should be profitable in the long run (with 99% confidence). \r\n//   The maximum bet allowed has been computed through statistical analysis to yield high confidence \r\n//   in the long run survival of the casino. The maximum bet is always smaller than the current payroll \r\n//   of the casino * 35 (max pay multiplier) * casinoStatisticalLimit (statistical sample size that allows \r\n//   to have enough confidence in survival, set at 20 at start, should increase to 200 when we have more \r\n//   investors to increase the safety).\r\n//   \r\n//   At start there is a limit of 50 investors (can be changed via settings up to 150)\r\n//   If there is no open position and you want to invest, you can try to buyout a current investor.\r\n//   To buyout, you have to invest more than any investor whose funds are unlocked (after 1 week grace lock period)\r\n//   If there are no remaining open position and all investors are under grace period, it is not possible to \r\n//   become a new investor in the casino.\r\n//\r\n//   At any time an investor can add funds to his investment with the withdraw function.\r\n//   Doing so will refresh the lock period and secure your position.\r\n//\r\n//\r\n//   A provably fair roulette :  note on Random Number Generation.\r\n//   The roulette result is based on the hash of the 6th block after the player commits his bet.\r\n//   This guarantees a provably fair roulette with equiprobable results and non predictable\r\n//   unless someone has more computing power than all the Ethereum Network.\r\n//   Yet Miners could try to exploit their position in 2 ways.\r\n//   First they could try to mine 7 blocks in a row (to commit their bet based on result for a sure win),\r\n//   but this is highly improbable and not predictible.\r\n//   Second they could commit a bet, then wait 6 blocks and hope that they will be the one forming the \r\n//   block on which their commited bet depends. If this is the case and the hash they find is not a\r\n//   winning one, they could decide to not share the block with the network but would lose 5 ether.\r\n//   To counter this potential miner edge (=base win proba + (miner proba to find block)*base win proba )\r\n//   we keep wager amounts far smaller than 5 Eth so that the miner prefers to get his block reward than cheat.\r\n//   Note that a miner could place several bets on the same block to increase his potential profit from dropping a block\r\n//   For this reason we limit the number of bets per block to 2 at start (configurable later if needed).\r\ncontract Rouleth\r\n{\r\n\r\n    //Variables, Structure\r\n    address developer;\r\n    uint8 blockDelay; //nb of blocks to wait before spin\r\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\r\n    uint256 maxGamble; //max gamble value manually set by config\r\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\r\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\r\n    uint casinoStatisticalLimit;\r\n    //Current gamble value possibly lower than config (<payroll/(20*35))\r\n    uint256 currentMaxGamble; \r\n    //Gambles\r\n    struct Gamble\r\n    {\r\n\taddress player;\r\n        bool spinned; //Was the rouleth spinned ?\r\n\tbool win;\r\n\tBetTypes betType; //number/color/dozen/oddeven\r\n\tuint8 input; //stores number, color, dozen or oddeven\r\n\tuint256 wager;\r\n\tuint256 blockNumber; //block of bet -1\r\n        uint8 wheelResult;\r\n    }\r\n    Gamble[] private gambles;\r\n    uint firstActiveGamble; //pointer to track the first non spinned and non expired gamble.\r\n    //Tracking progress of players\r\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\r\n    enum Status {waitingForBet, waitingForSpin} Status status; //gamble status\r\n    mapping (address=>Status) playerStatus; //progress of the player's gamble\r\n\r\n    //**********************************************\r\n    //        Management & Config FUNCTIONS        //\r\n    //**********************************************\r\n\tfunction  Rouleth() private //creation settings\r\n    { \r\n        developer = msg.sender;\r\n        blockDelay=6; //delay to wait between bet and spin\r\n\tblockExpiration=200; //delay after which gamble expires\r\n        maxGamble=50 finney; //0.05 ether as max bet to start (payroll of 35 eth)\r\n        maxBetsPerBlock=2; // limit of 2 bets per block, to prevent multiple bets per miners (to keep max reward<5ETH)\r\n        casinoStatisticalLimit=20;\r\n    }\r\n\t\r\n    modifier onlyDeveloper() {\r\n\t    if (msg.sender!=developer) throw;\r\n\t    _\r\n    }\r\n\t\r\n\tfunction changeDeveloper(address new_dev)\r\n        noEthSent\r\n\t    onlyDeveloper\r\n\t{\r\n\t\tdeveloper=new_dev;\r\n\t}\r\n\r\n\r\n    //Activate, Deactivate Betting\r\n    enum States{active, inactive} States private state;\r\n\tfunction disableBetting()\r\n    noEthSent\r\n\tonlyDeveloper\r\n\t{\r\n            state=States.inactive;\r\n\t}\r\n\tfunction enableBetting()\r\n\tonlyDeveloper\r\n        noEthSent\r\n\t{\r\n            state=States.active;\r\n\t}\r\n    \r\n\tmodifier onlyActive\r\n    {\r\n        if (state==States.inactive) throw;\r\n        _\r\n    }\r\n\r\n         //Change some settings within safety bounds\r\n\tfunction changeSettings(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMaxGamble, uint8 newMaxInvestor, uint256 newMinInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\r\n\tnoEthSent\r\n\tonlyDeveloper\r\n\t{\r\n\t        // changes the statistical multiplier that guarantees the long run casino survival\r\n\t        if (newCasinoStatLimit<20) throw;\r\n\t        casinoStatisticalLimit=newCasinoStatLimit;\r\n\t        //Max number of bets per block to prevent miner cheating\r\n\t        maxBetsPerBlock=newMaxBetsBlock;\r\n                //MAX BET : limited by payroll/(casinoStatisticalLimit*35) for statiscal confidence in longevity of casino\r\n\t\tif (newMaxGamble<=0 || newMaxGamble>=this.balance/(20*35)) throw; \r\n\t\telse { maxGamble=newMaxGamble; }\r\n                //MAX NB of INVESTORS (can only increase and max of 149)\r\n                if (newMaxInvestor<setting_maxInvestors || newMaxInvestor>149) throw;\r\n                else { setting_maxInvestors=newMaxInvestor;}\r\n                //MIN INVEST : \r\n                setting_minInvestment=newMinInvestment;\r\n                //Invest LOCK PERIOD\r\n                if (setting_lockPeriod>5184000) throw; //2 months max\r\n                setting_lockPeriod=newLockPeriod;\r\n\t\t        //Delay before roll :\r\n\t\tif (blockDelay<1) throw;\r\n\t\t        blockDelay=newBlockDelay;\r\n                updateMaxBet();\r\n\t\tif (newBlockExpiration<100) throw;\r\n\t\tblockExpiration=newBlockExpiration;\r\n\t}\r\n \r\n\r\n    //**********************************************\r\n    //                 BETTING FUNCTIONS                    //\r\n    //**********************************************\r\n\r\n//***//basic betting without Mist or contract call\r\n    //activates when the player only sends eth to the contract\r\n    //without specifying any type of bet.\r\n    function () \r\n   {\r\n       //if player is not playing : bet on 7\r\n       if (playerStatus[msg.sender]==Status.waitingForBet)  betOnNumber(7);\r\n       //if player is already playing, spin the wheel\r\n       else spinTheWheel();\r\n    } \r\n\r\n    function updateMaxBet() private\r\n    {\r\n    //check that maxGamble setting is still within safety bounds\r\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \r\n\t\t{ \r\n\t\t\tcurrentMaxGamble=maxGamble;\r\n                }\r\n\telse\r\n\t\t{ \r\n\t\t\tcurrentMaxGamble = payroll/(20*35);\r\n\t\t}\r\n     }\r\n\r\n//***//Guarantees that gamble is under (statistical) safety limits for casino survival.\r\n    function checkBetValue() private returns(uint256 playerBetValue)\r\n    {\r\n        updateMaxBet();\r\n\t\tif (msg.value > currentMaxGamble) //if above max, send difference back\r\n\t\t{\r\n\t\t    msg.sender.send(msg.value-currentMaxGamble);\r\n\t\t    playerBetValue=currentMaxGamble;\r\n\t\t}\r\n                else\r\n                { playerBetValue=msg.value; }\r\n       }\r\n\r\n\r\n    //check number of bets in block (to prevent miner cheating and keep max reward per block <5ETH)\r\n    modifier checkNbBetsCurrentBlock()\r\n    {\r\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\r\n        else nbBetsCurrentBlock=0;\r\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\r\n        _\r\n    }\r\n    //check that the player is not playing already (unless it has expired)\r\n    modifier checkWaitingForBet{\r\n        //if player is already in gamble\r\n        if (playerStatus[msg.sender]!=Status.waitingForBet)\r\n        {\r\n             //case not expired\r\n             if (gambles[gambleIndex[msg.sender]].blockNumber+blockExpiration>block.number) throw;\r\n             //case expired\r\n             else\r\n             {\r\n                  //add bet to PL and reset status\r\n                  solveBet(msg.sender, 255, false, 0) ;\r\n\r\n              }\r\n        }\r\n\t_\r\n\t}\r\n\r\n    //Possible bet types\r\n    enum BetTypes{ number, color, parity, dozen, column, lowhigh} BetTypes private initbetTypes;\r\n\r\n    function updateStatusPlayer() private\r\n    expireGambles\r\n    {\r\n\tplayerStatus[msg.sender]=Status.waitingForSpin;\r\n\tgambleIndex[msg.sender]=gambles.length-1;\r\n     }\r\n\r\n//***//bet on Number\t\r\n    function betOnNumber(uint8 numberChosen)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        //check that number chosen is valid and records bet\r\n        if (numberChosen>36) throw;\r\n\t\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\t    gambles.push(Gamble(msg.sender, false, false, BetTypes.number, numberChosen, betValue, block.number, 37));\r\n        updateStatusPlayer();\r\n    }\r\n\r\n//***// function betOnColor\r\n\t//bet type : color\r\n\t//input : 0 for red\r\n\t//input : 1 for black\r\n    function betOnColor(bool Red, bool Black)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Red) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Black) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\t    gambles.push(Gamble(msg.sender, false, false, BetTypes.color, input, betValue, block.number, 37));\r\n        updateStatusPlayer();\r\n    }\r\n\r\n//***// function betOnLow_High\r\n\t//bet type : lowhigh\r\n\t//input : 0 for low\r\n\t//input : 1 for low\r\n    function betOnLowHigh(bool Low, bool High)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Low) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (High) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.lowhigh, input, betValue, block.number, 37));\r\n        updateStatusPlayer();\r\n    }\r\n\r\n//***// function betOnOdd_Even\r\n\t//bet type : parity\r\n     //input : 0 for even\r\n    //input : 1 for odd\r\n    function betOnOddEven(bool Odd, bool Even)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Even) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Odd) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, BetTypes.parity, input, betValue, block.number, 37));\r\n        updateStatusPlayer();\r\n    }\r\n\r\n\r\n//***// function betOnDozen\r\n//     //bet type : dozen\r\n//     //input : 0 for first dozen\r\n//     //input : 1 for second dozen\r\n//     //input : 2 for third dozen\r\n    function betOnDozen(bool First, bool Second, bool Third)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n         betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\r\n    }\r\n\r\n\r\n// //***// function betOnColumn\r\n//     //bet type : column\r\n//     //input : 0 for first column\r\n//     //input : 1 for second column\r\n//     //input : 2 for third column\r\n    function betOnColumn(bool First, bool Second, bool Third)\r\n    checkWaitingForBet\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n         betOnColumnOrDozen(First, Second, Third, BetTypes.column);\r\n     }\r\n\r\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\r\n    { \r\n        uint8 count;\r\n        uint8 input;\r\n        if (First) \r\n        { \r\n             count+=1; \r\n             input=0;\r\n         }\r\n        if (Second) \r\n        {\r\n             count+=1; \r\n             input=1;\r\n         }\r\n        if (Third) \r\n        {\r\n             count+=1; \r\n             input=2;\r\n         }\r\n        if (count!=1) throw;\r\n\t//check that wager is under limit\r\n        uint256 betValue= checkBetValue();\r\n\t    gambles.push(Gamble(msg.sender, false, false, bet, input, betValue, block.number, 37));\r\n        updateStatusPlayer();\r\n    }\r\n\r\n    //**********************************************\r\n    // Spin The Wheel & Check Result FUNCTIONS//\r\n    //**********************************************\r\n\r\n\tevent Win(address player, uint8 result, uint value_won);\r\n\tevent Loss(address player, uint8 result, uint value_loss);\r\n\r\n    //check that player has to spin the wheel\r\n    modifier checkWaitingForSpin{\r\n        if (playerStatus[msg.sender]!=Status.waitingForSpin) throw;\r\n\t_\r\n\t}\r\n    //Prevents accidental sending of Eth when you shouldn't\r\n    modifier noEthSent()\r\n    {\r\n        if (msg.value>0) msg.sender.send(msg.value);\r\n        _\r\n    }\r\n\r\n//***//function to spin\r\n    function spinTheWheel()\r\n    checkWaitingForSpin\r\n    noEthSent\r\n    {\r\n        //check that the player waited for the delay before spin\r\n        //and also that the bet is not expired (200 blocks limit)\r\n\tuint playerblock = gambles[gambleIndex[msg.sender]].blockNumber;\r\n\tif (block.number<playerblock+blockDelay || block.number>playerblock+blockExpiration) throw;\r\n    else\r\n\t{\r\n\t    uint8 wheelResult;\r\n        //Spin the wheel, Reset player status and record result\r\n\t\twheelResult = uint8(uint256(block.blockhash(playerblock+blockDelay))%37);\r\n\t\tgambles[gambleIndex[msg.sender]].wheelResult=wheelResult;\r\n        //check result against bet and pay if win\r\n\t\tcheckBetResult(wheelResult, gambles[gambleIndex[msg.sender]].betType);\r\n\t\tupdateFirstActiveGamble(gambleIndex[msg.sender]);\r\n\t}\r\n    }\r\n\r\nfunction updateFirstActiveGamble(uint bet_id) private\r\n     {\r\n         if (bet_id==firstActiveGamble)\r\n         {   \r\n              uint index;\r\n              if (firstActiveGamble!=0) index=firstActiveGamble-1;\r\n              while (true)\r\n              {\r\n                 if (index<gambles.length && gambles[index].spinned)\r\n                 {\r\n                     index=index+1;\r\n                 }\r\n                 else {break; }\r\n               }\r\n              firstActiveGamble=index;\r\n              return;\r\n          }\r\n }\r\n\t\r\n//checks if there are expired gambles\r\nmodifier expireGambles{\r\n    if (  (gambles.length!=0 && gambles.length-1>=firstActiveGamble ) \r\n          && gambles[firstActiveGamble].blockNumber + blockExpiration <= block.number && !gambles[firstActiveGamble].spinned )  \r\n    { \r\n\tsolveBet(gambles[firstActiveGamble].player, 255, false, 0);\r\n        updateFirstActiveGamble(firstActiveGamble);\r\n    }\r\n        _\r\n}\r\n\t\r\n\r\n     //CHECK BETS FUNCTIONS private\r\n     function checkBetResult(uint8 result, BetTypes betType) private\r\n     {\r\n          //bet on Number\r\n          if (betType==BetTypes.number) checkBetNumber(result);\r\n          else if (betType==BetTypes.parity) checkBetParity(result);\r\n          else if (betType==BetTypes.color) checkBetColor(result);\r\n\t else if (betType==BetTypes.lowhigh) checkBetLowhigh(result);\r\n\t else if (betType==BetTypes.dozen) checkBetDozen(result);\r\n\telse if (betType==BetTypes.column) checkBetColumn(result);\r\n          updateMaxBet(); \r\n     }\r\n\r\n     // function solve Bet once result is determined : sends to winner, adds loss to profit\r\n     function solveBet(address player, uint8 result, bool win, uint8 multiplier) private\r\n     {\r\n        playerStatus[msg.sender]=Status.waitingForBet;\r\n        gambles[gambleIndex[player]].spinned=true;\r\n\tuint bet_v = gambles[gambleIndex[player]].wager;\r\n            if (win)\r\n            {\r\n\t\t  gambles[gambleIndex[player]].win=true;\r\n\t\t  uint win_v = multiplier*bet_v;\r\n                  player.send(win_v);\r\n                  lossSinceChange+=win_v-bet_v;\r\n\t\t  Win(player, result, win_v);\r\n             }\r\n            else\r\n            {\r\n\t\tLoss(player, result, bet_v);\r\n                profitSinceChange+=bet_v;\r\n            }\r\n\r\n      }\r\n\r\n\r\n     // checkbeton number(input)\r\n    // bet type : number\r\n    // input : chosen number\r\n     function checkBetNumber(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t    if (result==gambles[gambleIndex[msg.sender]].input)\r\n\t    {\r\n                  win=true;  \r\n             }\r\n             solveBet(msg.sender, result,win,35);\r\n     }\r\n\r\n\r\n     // checkbet on oddeven\r\n    // bet type : parity\r\n    // input : 0 for even, 1 for odd\r\n     function checkBetParity(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t    if (result%2==gambles[gambleIndex[msg.sender]].input && result!=0)\r\n\t    {\r\n                  win=true;                \r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n        \r\n     }\r\n\t\r\n     // checkbet on lowhigh\r\n     // bet type : lowhigh\r\n     // input : 0 low, 1 high\r\n     function checkBetLowhigh(uint8 result) private\r\n     {\r\n            bool win;\r\n            //win\r\n\t\t if (result!=0 && ( (result<19 && gambles[gambleIndex[msg.sender]].input==0)\r\n\t\t\t || (result>18 && gambles[gambleIndex[msg.sender]].input==1)\r\n\t\t\t ) )\r\n\t    {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n     }\r\n\r\n     // checkbet on color\r\n     // bet type : color\r\n     // input : 0 red, 1 black\r\n      uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\r\n      function checkBetColor(uint8 result) private\r\n      {\r\n             bool red;\r\n             //check if red\r\n             for (uint8 k; k<18; k++)\r\n             { \r\n                    if (red_list[k]==result) \r\n                    { \r\n                          red=true; \r\n                          break;\r\n                    }\r\n             }\r\n             bool win;\r\n             //win\r\n             if ( result!=0\r\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && red)  \r\n                || ( gambles[gambleIndex[msg.sender]].input==1 && !red)  ) )\r\n             {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,2);\r\n       }\r\n\r\n     // checkbet on dozen\r\n     // bet type : dozen\r\n     // input : 0 first, 1 second, 2 third\r\n     function checkBetDozen(uint8 result) private\r\n     { \r\n            bool win;\r\n            //win on first dozen\r\n     \t\t if ( result!=0 &&\r\n                      ( (result<13 && gambles[gambleIndex[msg.sender]].input==0)\r\n     \t\t\t||\r\n                     (result>12 && result<25 && gambles[gambleIndex[msg.sender]].input==1)\r\n                    ||\r\n                     (result>24 && gambles[gambleIndex[msg.sender]].input==2) ) )\r\n     \t    {\r\n                   win=true;                \r\n             }\r\n             solveBet(msg.sender,result,win,3);\r\n     }\r\n\r\n     // checkbet on column\r\n     // bet type : column\r\n     // input : 0 first, 1 second, 2 third\r\n      function checkBetColumn(uint8 result) private\r\n      {\r\n             bool win;\r\n             //win\r\n             if ( result!=0\r\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && result%3==1)  \r\n                || ( gambles[gambleIndex[msg.sender]].input==1 && result%3==2)\r\n                || ( gambles[gambleIndex[msg.sender]].input==2 && result%3==0)  ) )\r\n             {\r\n                  win=true;\r\n             }\r\n             solveBet(msg.sender,result,win,3);\r\n      }\r\n\r\n\r\n//INVESTORS FUNCTIONS\r\n\r\n\r\n//total casino payroll\r\n    uint256 payroll;\r\n//Profit Loss since last investor change\r\n    uint256 profitSinceChange;\r\n    uint256 lossSinceChange;\r\n//investor struct array (hard capped to 150)\r\n    uint8 setting_maxInvestors = 50;\r\n    struct Investor\r\n    {\r\n\t    address investor;\r\n\t    uint256 time;\r\n    }\t\r\n\tInvestor[150] private investors ;\r\n    //Balances of the investors\r\n    mapping (address=>uint256) balance; \r\n    //Investor lockPeriod\r\n    //lock time to avoid invest and withdraw for refresh only\r\n    //also time during which you cannot be outbet by a new investor if it is full\r\n    uint256 setting_lockPeriod=604800 ; //1 week in sec\r\n    uint256 setting_minInvestment=10 ether; //min amount to send when using invest()\r\n    //if full and unlocked position, indicates the cheapest amount to outbid\r\n    //otherwise cheapestUnlockedPosition=255\r\n    uint8 cheapestUnlockedPosition; \r\n    uint256 minCurrentInvest; \r\n    //record open position index\r\n    // =255 if full\r\n    uint8 openPosition;\r\n\t\r\n    event newInvest(address player, uint invest_v);\r\n\r\n\r\n     function invest()\r\n     {\r\n          // check that min 10 ETH is sent (variable setting)\r\n          if (msg.value<setting_minInvestment) throw;\r\n          // check if already investor\r\n          bool alreadyInvestor;\r\n          // reset the position counters to values out of bounds\r\n          openPosition=255;\r\n          cheapestUnlockedPosition=255;\r\n          minCurrentInvest=10000000000000000000000000;//\r\n          // update balances before altering the investor shares\r\n          updateBalances();\r\n          // loop over investor's array to find if already investor, \r\n          // or openPosition and cheapest UnlockedPosition\r\n          for (uint8 k = 0; k<setting_maxInvestors; k++)\r\n          { \r\n               //captures an index of an open position\r\n               if (investors[k].investor==0) openPosition=k; \r\n               //captures if already an investor \r\n               else if (investors[k].investor==msg.sender)\r\n               {\r\n                    investors[k].time=now; //refresh time invest\r\n                    alreadyInvestor=true;\r\n                }\r\n               //captures the index of the investor with the min investment (after lock period)\r\n               else if (investors[k].time+setting_lockPeriod<now && balance[investors[k].investor]<minCurrentInvest && investors[k].investor!=developer)\r\n               {\r\n                    cheapestUnlockedPosition=k;\r\n                    minCurrentInvest=balance[investors[k].investor];\r\n                }\r\n           }\r\n           //case New investor\r\n           if (alreadyInvestor==false)\r\n           {\r\n                    //case : investor array not full, record new investor\r\n                    if (openPosition!=255) investors[openPosition]=Investor(msg.sender, now);\r\n                    //case : investor array full\r\n                    else\r\n                    {\r\n                         //subcase : investor has not outbid or all positions under lock period\r\n                         if (msg.value<=minCurrentInvest || cheapestUnlockedPosition==255) throw;\r\n                         //subcase : investor outbid, record investor change and refund previous\r\n                         else\r\n                         {\r\n                              address previous = investors[cheapestUnlockedPosition].investor;\r\n                              if (previous.send(balance[previous])==false) throw;\r\n                              balance[previous]=0;\r\n                              investors[cheapestUnlockedPosition]=Investor(msg.sender, now);\r\n                          }\r\n                     }\r\n            }\r\n          //add investment to balance of investor and to payroll\r\n\r\n          uint256 maintenanceFees=2*msg.value/100; //2% maintenance fees\r\n          uint256 netInvest=msg.value - maintenanceFees;\r\n          newInvest(msg.sender, netInvest);\r\n          balance[msg.sender]+=netInvest; //add invest to balance\r\n          payroll+=netInvest;\r\n          //send maintenance fees to developer \r\n          if (developer.send(maintenanceFees)==false) throw;\r\n          updateMaxBet();\r\n      }\r\n\r\n//***// Withdraw function (only after lockPeriod)\r\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\r\n    // if your withdraw brings your balance under the min investment required,\r\n    // your balance is fully withdrawn\r\n\tevent withdraw(address player, uint withdraw_v);\r\n\t\r\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\r\n    noEthSent\r\n    {\r\n        //before withdraw, update balances of the investors with the Profit and Loss sinceChange\r\n        updateBalances();\r\n\t//check that amount requested is authorized  \r\n\tif (amountToWithdrawInWei>balance[msg.sender]) throw;\r\n        //retrieve investor ID\r\n        uint8 investorID=255;\r\n        for (uint8 k = 0; k<setting_maxInvestors; k++)\r\n        {\r\n               if (investors[k].investor==msg.sender)\r\n               {\r\n                    investorID=k;\r\n                    break;\r\n               }\r\n        }\r\n           if (investorID==255) throw; //stop if not an investor\r\n           //check if investment lock period is over\r\n           if (investors[investorID].time+setting_lockPeriod>now) throw;\r\n           //if balance left after withdraw is still above min investment accept partial withdraw\r\n           if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\r\n           {\r\n               balance[msg.sender]-=amountToWithdrawInWei;\r\n               payroll-=amountToWithdrawInWei;\r\n               //send amount to investor (with security if transaction fails)\r\n               if (msg.sender.send(amountToWithdrawInWei)==false) throw;\r\n\t       withdraw(msg.sender, amountToWithdrawInWei);\r\n           }\r\n           else\r\n           //if amountToWithdraw=0 : user wants full withdraw\r\n           //if balance after withdraw is < min invest, withdraw all and delete investor\r\n           {\r\n               //send amount to investor (with security if transaction fails)\r\n               uint256 fullAmount=balance[msg.sender];\r\n               payroll-=fullAmount;\r\n               balance[msg.sender]=0;\r\n               if (msg.sender.send(fullAmount)==false) throw;\r\n               //delete investor\r\n               delete investors[investorID];\r\n   \t       withdraw(msg.sender, fullAmount);\r\n            }\r\n          updateMaxBet();\r\n     }\r\n\r\n//***// updates balances with Profit Losses when there is a withdraw/deposit of investors\r\n\r\n\tfunction manualUpdateBalances()\r\n\texpireGambles\r\n\tnoEthSent\r\n\t{\r\n\t    updateBalances();\r\n\t}\r\n    function updateBalances() private\r\n    {\r\n         //split Profits\r\n         uint256 profitToSplit;\r\n         uint256 lossToSplit;\r\n         if (profitSinceChange==0 && lossSinceChange==0)\r\n         { return; }\r\n         \r\n         else\r\n         {\r\n             // Case : Global profit (more win than losses)\r\n             // 2% fees for developer on global profit (if profit>loss)\r\n             if (profitSinceChange>lossSinceChange)\r\n             {\r\n                profitToSplit=profitSinceChange-lossSinceChange;\r\n                uint256 developerFees=profitToSplit*2/100;\r\n                profitToSplit-=developerFees;\r\n                if (developer.send(developerFees)==false) throw;\r\n             }\r\n             else\r\n             {\r\n                lossToSplit=lossSinceChange-profitSinceChange;\r\n             }\r\n         \r\n         //share the loss and profits between all invest \r\n         //(proportionnaly. to each investor balance)\r\n         uint totalShared;\r\n             for (uint8 k=0; k<setting_maxInvestors; k++)\r\n             {\r\n                 address inv=investors[k].investor;\r\n                 if (inv==0) continue;\r\n                 else\r\n                 {\r\n                       if (profitToSplit!=0) \r\n                       {\r\n                           uint profitShare=(profitToSplit*balance[inv])/payroll;\r\n                           balance[inv]+=profitShare;\r\n                           totalShared+=profitShare;\r\n                       }\r\n                       if (lossToSplit!=0) \r\n                       {\r\n                           uint lossShare=(lossToSplit*balance[inv])/payroll;\r\n                           balance[inv]-=lossShare;\r\n                           totalShared+=lossShare;\r\n                           \r\n                       }\r\n                 }\r\n             }\r\n          // update payroll\r\n          if (profitToSplit !=0) \r\n          {\r\n              payroll+=profitToSplit;\r\n              balance[developer]+=profitToSplit-totalShared;\r\n          }\r\n          if (lossToSplit !=0) \r\n          {\r\n              payroll-=lossToSplit;\r\n              balance[developer]-=lossToSplit-totalShared;\r\n          }\r\n          profitSinceChange=0; //reset Profit;\r\n          lossSinceChange=0; //reset Loss ;\r\n          \r\n          }\r\n     }\r\n     \r\n     \r\n     //INFORMATION FUNCTIONS\r\n     \r\n     function checkProfitLossSinceInvestorChange() constant returns(uint profit, uint loss)\r\n     {\r\n        profit=profitSinceChange;\r\n        loss=lossSinceChange;\r\n        return;\r\n     }\r\n\r\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\r\n    {\r\n          balanceInWei=balance[investor];\r\n          return;\r\n     }\r\n\r\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\r\n    {\r\n          investor=investors[index].investor;\r\n          endLockPeriod=investors[index].time+setting_lockPeriod;\r\n          return;\r\n    }\r\n\t\r\n\r\n\tfunction investmentEntryCost() constant returns(bool open_position, bool unlocked_position, uint buyout_amount, uint investLockPeriod)\r\n\t{\r\n\t\tif (openPosition!=255) open_position=true;\r\n\t\tif (cheapestUnlockedPosition!=255) \r\n\t\t{\r\n\t\t\tunlocked_position=true;\r\n\t\t\tbuyout_amount=minCurrentInvest;\r\n\t\t}\r\n\t\tinvestLockPeriod=setting_lockPeriod;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tfunction getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\r\n\t{\r\n\t    maxBet=currentMaxGamble;\r\n\t    blockDelayBeforeSpin=blockDelay;\r\n\t    return ;\r\n\t}\r\n\r\n\tfunction getFirstActiveDuel() constant returns(uint _firstActiveGamble)\r\n\t{\r\n            _firstActiveGamble=firstActiveGamble;\r\n\t    return ;\r\n\t}\r\n\r\n\t\r\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\r\n    {\r\n          player_status=playerStatus[player];\r\n          bettype=gambles[gambleIndex[player]].betType;\r\n          input=gambles[gambleIndex[player]].input;\r\n          value=gambles[gambleIndex[player]].wager;\r\n          result=gambles[gambleIndex[player]].wheelResult;\r\n          wheelspinned=gambles[gambleIndex[player]].spinned;\r\n          win=gambles[gambleIndex[player]].win;\r\n\tblockNb=gambles[gambleIndex[player]].blockNumber;\r\n\t  return;\r\n     }\r\n\r\n} //end of contract", 
  "balance": "0<b>.</b>01948 Ether", 
  "name": "Rouleth", 
  "transactions": "646", 
  "address": "0x6dfaa563d04a77aff4c4ad2b17cf4c64d2983dc8"
 }, 
 {
  "source": "// A Ponzi scheme where old investors are payed with the funds received from new investors.\r\n// Unlike what is out there in the market, the contract creator received no funds - if you\r\n// don't do work, you cannot expect to be paid. People who put in the funds receive all the\r\n// returns. Owners can particiapte themselves, there is no leaching off the top and slowing\r\n// down payouts for the participants.\r\ncontract ZeroPonzi {\r\n  // minimum & maxium entry values\r\n  uint public constant MIN_VALUE = 100 finney;\r\n  uint public constant MAX_VALUE = 10 ether;\r\n\r\n  // the return multiplier & divisors, yielding 1.25 (125%) returns\r\n  uint public constant RET_MUL = 125;\r\n  uint public constant RET_DIV = 100;\r\n\r\n  // entry structure, storing the address & yield\r\n  struct Payout {\r\n    address addr;\r\n    uint yield;\r\n  }\r\n\r\n  // our actual queued payouts, index of current & total distributed\r\n  Payout[] public payouts;\r\n  uint public payoutIndex = 0;\r\n  uint public payoutTotal = 0;\r\n\r\n  // construtor, no additional requirements\r\n  function ZeroPonzi() {\r\n  }\r\n\r\n  // single entry point, add entry & pay what we can\r\n  function() {\r\n    // we only accept values in range\r\n    if ((msg.value < MIN_VALUE) || (msg.value > MAX_VALUE)) {\r\n      throw;\r\n    }\r\n\r\n    // queue the current entry as a future payout recipient\r\n    uint entryIndex = payouts.length;\r\n    payouts.length += 1;\r\n    payouts[entryIndex].addr = msg.sender;\r\n    payouts[entryIndex].yield = (msg.value * RET_MUL) / RET_DIV;\r\n\r\n    // send payouts while we can afford to do so\r\n    while (payouts[payoutIndex].yield < this.balance) {\r\n      payoutTotal += payouts[payoutIndex].yield;\r\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\r\n      payoutIndex += 1;\r\n    }\r\n  }\r\n}", 
  "balance": "0<b>.</b>473406234918164007 Ether", 
  "name": "ZeroPonzi", 
  "transactions": "617", 
  "address": "0x43bbc7fafb860d974037b8f7dd06b6f6fe799b3e"
 }, 
 {
  "source": "// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        address oraclizeAddr = OAR.getAddress();\r\n        if (oraclizeAddr == 0){\r\n            oraclize_setNetwork(networkID_auto);\r\n            oraclizeAddr = OAR.getAddress();\r\n        }\r\n        oraclize = OraclizeI(oraclizeAddr);\r\n        _\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        return mint;\r\n    }\r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\r\n    uint public edge = 200; //edge percentage (10000 = 100%)\r\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint public minBet = 1 finney;\r\n    uint public maxInvestors = 5; //maximum number of investors\r\n    uint public ownerEdge = 50; //edge percentage (10000 = 100%)\r\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    \r\n    uint constant safeGas = 25000;\r\n    uint constant oraclizeGasLimit = 150000;\r\n\r\n    struct Investor {\r\n        address user;\r\n        uint capital;\r\n    }\r\n    mapping(uint => Investor) investors; //starts at 1\r\n    uint public numInvestors = 0;\r\n    mapping(address => uint) investorIDs;\r\n    uint public invested = 0;\r\n    \r\n    address owner;\r\n    bool public isStopped;\r\n\r\n    struct Bet {\r\n        address user;\r\n        uint bet; // amount\r\n        uint roll; // result\r\n\tuint fee; \r\n    }\r\n    mapping (bytes32 => Bet) bets;\r\n    bytes32[] betsKeys;\r\n    uint public amountWagered = 0;\r\n    int public profit = 0;\r\n    int public takenProfit = 0;\r\n    int public ownerProfit = 0;\r\n\r\n    function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) {\r\n        \r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        \r\n        pwin = pwinInitial;\r\n        edge = edgeInitial;\r\n        maxWin = maxWinInitial;\r\n        minBet = minBetInitial;\r\n        maxInvestors = maxInvestorsInitial;\r\n        ownerEdge = ownerEdgeInitial;\r\n        divestFee = divestFeeInitial;\r\n        \r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    function() {\r\n        bet();\r\n    }\r\n\r\n    function bet() {\r\n        if (isStopped) throw;\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\r\n        if (msg.value < oraclizeFee) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\", 'BDXJhrVpBJ53o2CxlJRlQtZJKZqLYt5IQe+73YDS4HtNjS5HodbIB3tvfow7UquyAk085VkLnL9EpKgwqWQz7ZLdGvsQlRd2sKxIolNg9DbnfPspGqLhLbbYSVnN8CwvsjpAXcSSo3c+4cNwC90yF4oNibkvD3ytapoZ7goTSyoUYTfwSjnw3ti+HJVH7N3+c0iwOCqZjDdsGQUcX3m3S/IHWbOOQQ5osO4Lbj3Gg0x1UdNtfUzYCFY79nzYgWIQEFCuRBI0n6NBvBQW727+OsDRY0J/9/gjt8ucibHWic0=', oraclizeGasLimit); // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}'\r\n            bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee);\r\n            betsKeys.push(myid);\r\n        } else {\r\n            throw; // invalid bet size\r\n        }\r\n    }\r\n\r\n    function numBets() constant returns(uint) {\r\n        return betsKeys.length;\r\n    }\r\n    \r\n    function minBetAmount() constant returns(uint) {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\r\n        return oraclizeFee+minBet;\r\n    }\r\n    \r\n    function safeSend(address addr, uint value) internal {\r\n        if (!(addr.call.gas(safeGas).value(value)())){\r\n            ownerProfit += int(value);\r\n        }\r\n    }\r\n  \r\n    function __callback(bytes32 myid, string result, bytes proof) {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        \r\n        Bet thisBet = bets[myid];\r\n        if (thisBet.bet>0) {\r\n            if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) {\r\n                uint roll = parseInt(result);\r\n                if (roll<1 || roll>10000){\r\n                    safeSend(thisBet.user, thisBet.bet);\r\n                    return;    \r\n                }\r\n\r\n                bets[myid].roll = roll;\r\n                \r\n                int profitDiff;\r\n                if (roll-1 < pwin) { //win\r\n                    uint winAmount = (thisBet.bet * (10000 - edge)) / pwin;\r\n                    safeSend(thisBet.user, winAmount);\r\n                    profitDiff = int(thisBet.bet - winAmount);\r\n                } else { //lose\r\n                    safeSend(thisBet.user, 1);\r\n                    profitDiff = int(thisBet.bet) - 1;\r\n                }\r\n                \r\n                ownerProfit += (profitDiff*int(ownerEdge))/10000;\r\n                profit += profitDiff-(profitDiff*int(ownerEdge))/10000;\r\n                \r\n                amountWagered += thisBet.bet;\r\n            } else {\r\n                //bet is too big (bankroll may have changed since the bet was made)\r\n                safeSend(thisBet.user, thisBet.bet);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBet(uint id) constant returns(address, uint, uint, uint) {\r\n        if(id<betsKeys.length)\r\n        {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee);\r\n        }\r\n    }\r\n\r\n    function invest() {\r\n        if (isStopped) throw;\r\n        \r\n        if (investorIDs[msg.sender]>0) {\r\n            rebalance();\r\n            investors[investorIDs[msg.sender]].capital += msg.value;\r\n            invested += msg.value;\r\n        } else {\r\n            rebalance();\r\n            uint investorID = 0;\r\n            if (numInvestors<maxInvestors) {\r\n                investorID = ++numInvestors;\r\n            } else {\r\n                for (uint i=1; i<=numInvestors; i++) {\r\n                    if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) {\r\n                        investorID = i;\r\n                    }\r\n                }\r\n            }\r\n            if (investorID>0) {\r\n                if (investors[investorID].capital>0) {\r\n                    divest(investors[investorID].user, investors[investorID].capital);\r\n                    investorIDs[investors[investorID].user] = 0;\r\n                }\r\n                if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) {\r\n                    investors[investorID].user = msg.sender;\r\n                    investors[investorID].capital = msg.value;\r\n                    invested += msg.value;\r\n                    investorIDs[msg.sender] = investorID;\r\n                } else {\r\n                    throw;\r\n                }\r\n            } else {\r\n                throw;\r\n            }\r\n        }\r\n    }\r\n\r\n    function rebalance() private {\r\n        if (takenProfit != profit) {\r\n            uint newInvested = 0;\r\n            uint initialBankroll = getBankroll();\r\n            for (uint i=1; i<=numInvestors; i++) {\r\n                investors[i].capital = getBalance(investors[i].user);\r\n                newInvested += investors[i].capital;\r\n            }\r\n            invested = newInvested;\r\n            if (newInvested != initialBankroll && numInvestors>0) {\r\n                ownerProfit += int(initialBankroll - newInvested); //give the rounding error to the first investor\r\n                invested += (initialBankroll - newInvested);\r\n            }\r\n            takenProfit = profit;\r\n        }\r\n    }\r\n\r\n    function divest(address user, uint amount) private {\r\n        if (investorIDs[user]>0) {\r\n            rebalance();\r\n            if (amount>getBalance(user)) {\r\n                amount = getBalance(user);\r\n            }\r\n            investors[investorIDs[user]].capital -= amount;\r\n            invested -= amount;\r\n            \r\n            uint newAmount = (amount*divestFee)/10000; // take a fee from the deinvest amount\r\n            ownerProfit += int(newAmount);\r\n            safeSend(user, (amount-newAmount));\r\n        }\r\n    }\r\n\r\n    function divest(uint amount) {\r\n        if (msg.value>0) throw;\r\n        divest(msg.sender, amount);\r\n    }\r\n\r\n    function divest() {\r\n        if (msg.value>0) throw;\r\n        divest(msg.sender, getBalance(msg.sender));\r\n    }\r\n\r\n    function getBalance(address user) constant returns(uint) {\r\n        if (investorIDs[user]>0 && invested>0) {\r\n            return investors[investorIDs[user]].capital * getBankroll() / invested;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getBankroll() constant returns(uint) {\r\n        uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit);\r\n        if (this.balance < bankroll){\r\n            log0(\"bankroll_mismatch\");\r\n            bankroll = this.balance;\r\n        }\r\n        return bankroll;\r\n    }\r\n\r\n    function getMinInvestment() constant returns(uint) {\r\n        if (numInvestors<maxInvestors) {\r\n            return 0;\r\n        } else {\r\n            uint investorID;\r\n            for (uint i=1; i<=numInvestors; i++) {\r\n                if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) {\r\n                    investorID = i;\r\n                }\r\n            }\r\n            return getBalance(investors[investorID].user);\r\n        }\r\n    }\r\n\r\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) {\r\n        return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length);\r\n    }\r\n\r\n    function stopContract() {\r\n        if (owner != msg.sender) throw;\r\n        isStopped = true;\r\n    }\r\n  \r\n    function resumeContract() {\r\n        if (owner != msg.sender) throw;\r\n        isStopped = false;\r\n    }\r\n    \r\n    function forceDivestAll() {\r\n        forceDivestAll(false);\r\n    }\r\n    \r\n    function forceDivestAll(bool ownerTakeChangeAndProfit) {\r\n        if (owner != msg.sender) throw;\r\n        for (uint investorID=1; investorID<=numInvestors; investorID++) {\r\n            divest(investors[investorID].user, getBalance(investors[investorID].user));\r\n        }\r\n        if (ownerTakeChangeAndProfit) owner.send(this.balance);\r\n    }\r\n    \r\n    function ownerTakeProfit() {\r\n        ownerTakeProfit(false);\r\n    }\r\n    \r\n    function ownerTakeProfit(bool takeChange) {\r\n        if (owner != msg.sender) throw;\r\n        if (takeChange){\r\n            uint investorsCapital = 0;\r\n            for (uint i=1; i<=numInvestors; i++) {\r\n                investorsCapital += investors[i].capital;\r\n            }\r\n            if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\r\n                owner.send(this.balance);\r\n                ownerProfit = 0;\r\n            }\r\n        } else {\r\n            owner.send(uint(ownerProfit));\r\n            ownerProfit = 0;\r\n        }\r\n    }\r\n   \r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "605", 
  "address": "0x50739060a2c32dc076e507ae1a893aab28ecfe68"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "186<b>.</b>583486617403855405 Ether", 
  "name": "Wallet", 
  "transactions": "587", 
  "address": "0xaadf4c2b71fc34d6a2b6257587ceee6df149f296"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 7500; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 25; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BLeDHjdcYMnndkLq59sF0YDm7mMsjcXEfM5flEd/5CjV7qWB+JiHS8oOHv4YZrx0snsbqpAVM70MMo8iE21drLvJ7WaBZIL3gOBqPEPGHuSfbiT5Zwk0Pl4WNKdiLwe4RkB9Vk4/RTvzmRxwc1HMp+fZTDS/03k=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "584", 
  "address": "0xd4160356a4e81f008b86f9867e71d1e1404c5292"
 }, 
 {
  "source": "contract EthDig\r\n{\r\n    uint constant LifeTime = 30;\r\n    \r\n    address Owner = msg.sender;\r\n    address OutputAddress = msg.sender;\r\n    \r\n    uint64 Coef1=723;\r\n    uint64 Coef2=41665;\r\n    uint64 Coef3=600000;\r\n    \r\n    uint public ContributedAmount;\r\n    uint ContributedLimit = 10 ether;\r\n    \r\n    uint public CashForHardwareReturn;\r\n    uint public FreezedCash;\r\n    \r\n    uint16 UsersLength = 0;\r\n    mapping (uint16 => User) Users;\r\n    struct User{\r\n        address Address;\r\n        uint16 ContributionsLength;\r\n        mapping (uint16 => Contribution) Contributions;\r\n    }\r\n    struct Contribution{\r\n        uint CashInHarware;\r\n        uint CashFreezed;\r\n        \r\n        uint16 ProfitPercent;\r\n        uint NeedPayByDay;\r\n        \r\n        bool ReuseCashInHarware;\r\n        \r\n        uint DateCreated;\r\n        uint DateLastCheck;\r\n        uint AlreadyPaid;\r\n        \r\n        bool ReturnedHardwareCash;\r\n        bool Finished;\r\n    }\r\n    \r\n    function  ContributeInternal(uint16 userId,uint cashInHarware,uint cashFreezed,bool reuseCashInHarware) private{\r\n        Contribution contribution = Users[userId].Contributions[Users[userId].ContributionsLength];\r\n\r\n        contribution.CashInHarware = cashInHarware;\r\n        contribution.CashFreezed = cashFreezed;\r\n        \r\n        uint8 noFreezCoef = uint8 ((cashInHarware * 100) / (cashFreezed+cashInHarware));\r\n        contribution.ProfitPercent = uint16 (((Coef1 * noFreezCoef * noFreezCoef) + (Coef2 * noFreezCoef) + Coef3)/10000);//10000\r\n        \r\n        contribution.NeedPayByDay = (((cashInHarware + cashFreezed) /10000) * contribution.ProfitPercent)/LifeTime;\r\n        contribution.ReuseCashInHarware = reuseCashInHarware;\r\n        contribution.DateCreated = now;\r\n        contribution.DateLastCheck = now;\r\n        \r\n        Users[userId].ContributionsLength++;\r\n    }\r\n    function ContributeWithSender (bool reuseCashInHarware,uint8 freezeCoeff,address sender) {\r\n        if (msg.value == 0 || freezeCoeff>100 ||ContributedAmount + msg.value > ContributedLimit)\r\n        {\r\n            sender.send(msg.value);\r\n            return;\r\n        }\r\n        \r\n        uint16 userId = GetUserIdByAddress(sender);\r\n        if (userId == 65535)\r\n        {\r\n            userId = UsersLength;\r\n            Users[userId].Address = sender;\r\n            UsersLength ++;\r\n        }\r\n        \r\n        uint cashFreezed = ((msg.value/100)*freezeCoeff);\r\n        ContributeInternal(\r\n            userId,\r\n            msg.value - cashFreezed,\r\n            cashFreezed,\r\n            reuseCashInHarware\r\n            );\r\n        FreezedCash += cashFreezed;\r\n        ContributedAmount += msg.value;\r\n        \r\n        OutputAddress.send(msg.value - cashFreezed);\r\n    }\r\n    function Contribute (bool reuseCashInHarware,uint8 freezeCoeff) {\r\n        ContributeWithSender(reuseCashInHarware,freezeCoeff,msg.sender);\r\n    }\r\n    function ChangeReuseCashInHarware(bool newValue,uint16 userId,uint16 contributionId){\r\n        if (msg.sender != Users[userId].Address) return;\r\n        Users[userId].Contributions[contributionId].ReuseCashInHarware = newValue;\r\n    }\r\n    \r\n    function Triger(){\r\n        if (Owner != msg.sender) return;\r\n        \r\n        uint MinedTillLastPayment = this.balance - CashForHardwareReturn - FreezedCash;\r\n        bool NotEnoughCash = false;\r\n        \r\n        for(uint16 i=0;i<UsersLength;i++)\r\n        {\r\n            for(uint16 j=0;j<Users[i].ContributionsLength;j++)\r\n            {\r\n                Contribution contribution = Users[i].Contributions[j];\r\n                if (contribution.Finished || now - contribution.DateLastCheck < 1 days) continue;\r\n                \r\n                if (contribution.AlreadyPaid != contribution.NeedPayByDay * LifeTime)\r\n                {\r\n                    uint8 daysToPay = uint8((now - contribution.DateCreated)/1 days);\r\n                    if (daysToPay>LifeTime) daysToPay = uint8(LifeTime);\r\n                    uint needToPay = (daysToPay * contribution.NeedPayByDay) - contribution.AlreadyPaid;\r\n                    \r\n                    if (MinedTillLastPayment < needToPay)\r\n                    {\r\n                        NotEnoughCash = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        if (needToPay > 100 finney || daysToPay == LifeTime)\r\n                        {\r\n                            MinedTillLastPayment -= needToPay;\r\n                            Users[i].Address.send(needToPay);\r\n                            contribution.AlreadyPaid += needToPay;\r\n                        }\r\n                    }\r\n                    contribution.DateLastCheck = now;\r\n                }\r\n\r\n                if (now > contribution.DateCreated + (LifeTime * 1 days) && !contribution.ReturnedHardwareCash)\r\n                {\r\n                    if (contribution.ReuseCashInHarware)\r\n                    {\r\n                        ContributeInternal(\r\n                            i,\r\n                            contribution.CashInHarware,\r\n                            contribution.CashFreezed,\r\n                            true\r\n                        );\r\n                        contribution.ReturnedHardwareCash = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        if (CashForHardwareReturn >= contribution.CashInHarware)\r\n                        {\r\n                            CashForHardwareReturn -= contribution.CashInHarware;\r\n                            FreezedCash -= contribution.CashFreezed;\r\n                            ContributedAmount -= contribution.CashFreezed + contribution.CashInHarware;\r\n                            Users[i].Address.send(contribution.CashInHarware + contribution.CashFreezed);\r\n                            contribution.ReturnedHardwareCash = true;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                if (contribution.ReturnedHardwareCash && contribution.AlreadyPaid == contribution.NeedPayByDay * LifeTime)\r\n                {\r\n                    contribution.Finished = true;\r\n                }\r\n            }  \r\n        }\r\n        \r\n        if (!NotEnoughCash)\r\n        {\r\n            OutputAddress.send(MinedTillLastPayment);\r\n        }\r\n    }\r\n    \r\n    function ConfigureFunction(address outputAddress,uint contributedLimit,uint16 coef1,uint16 coef2,uint16 coef3)\r\n    {\r\n        if (Owner != msg.sender) return;\r\n        OutputAddress = outputAddress;\r\n        ContributedLimit = contributedLimit;\r\n        Coef1 = coef1;\r\n        Coef2 = coef2;\r\n        Coef3 = coef3;\r\n    }\r\n    \r\n    function SendCashForHardwareReturn(){\r\n        CashForHardwareReturn += msg.value;\r\n    }\r\n    function WithdrawCashForHardwareReturn(uint amount){\r\n        if (Owner != msg.sender || CashForHardwareReturn < amount) return;\r\n        Owner.send(amount);\r\n    }\r\n    \r\n    function GetUserIdByAddress (address userAddress) returns (uint16){\r\n        for(uint16 i=0; i<UsersLength;i++)\r\n        {\r\n            if (Users[i].Address == userAddress)\r\n                return i;\r\n        }\r\n        return 65535;\r\n    }\r\n    \r\n    function GetContributionInfo (uint16 userId,uint16 contributionId) \r\n    returns (uint a1,uint a2, uint16 a3,uint a4, bool a5,uint a6,uint a7,uint a8,bool a9,bool a10,address a11) \r\n    {\r\n        Contribution contribution = Users[userId].Contributions[contributionId];\r\n        a1 = contribution.CashInHarware;\r\n        a2 = contribution.CashFreezed;\r\n        a3 = contribution.ProfitPercent;\r\n        a4 = contribution.NeedPayByDay;\r\n        a5 = contribution.ReuseCashInHarware;\r\n        a6 = contribution.DateCreated;\r\n        a7 = contribution.DateLastCheck;\r\n        a8 = contribution.AlreadyPaid;\r\n        a9 = contribution.ReturnedHardwareCash;\r\n        a10 = contribution.Finished;\r\n        a11 = Users[userId].Address;\r\n    }\r\n    \r\n}", 
  "balance": "0<b>.</b>61459999999999984 Ether", 
  "name": "EthDig", 
  "transactions": "571", 
  "address": "0xa9e2320d9e6c17eb45a921cb2698b42256f5e142"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "68<b>.</b>65308857520134284 Ether", 
  "name": "Wallet", 
  "transactions": "570", 
  "address": "0x7dacea65de63bee283754687e5bbb36c9d8f9b08"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "27,912<b>.</b>275114973238268901 Ether", 
  "name": "Wallet", 
  "transactions": "566", 
  "address": "0x8a37a0b8d48486b2117e958062d28096bec2539a"
 }, 
 {
  "source": "contract ProtectTheCastle {\r\n    // King's Jester\r\n    address public jester;\r\n    // Record the last Reparation time\r\n    uint public lastReparation;\r\n    // Piggy Bank Amount\r\n    uint public piggyBank;\r\n\r\n    // Collected Fee Amount\r\n    uint public collectedFee;\r\n\r\n    // Track the citizens who helped to repair the castle\r\n    address[] public citizensAddresses;\r\n    uint[] public citizensAmounts;\r\n    uint32 public totalCitizens;\r\n    uint32 public lastCitizenPaid;\r\n    // Brided Citizen who made the system works\r\n    address public bribedCitizen;\r\n    // Record how many times the castle had fell\r\n    uint32 public round;\r\n    // Amount already paid back in this round\r\n    uint public amountAlreadyPaidBack;\r\n    // Amount invested in this round\r\n    uint public amountInvested;\r\n\r\n    uint constant SIX_HOURS = 60 * 60 * 6;\r\n\r\n    function ProtectTheCastle() {\r\n        // Define the first castle\r\n        bribedCitizen = msg.sender;\r\n        jester = msg.sender;\r\n        lastReparation = block.timestamp;\r\n        amountAlreadyPaidBack = 0;\r\n        amountInvested = 0;\r\n        totalCitizens = 0;\r\n    }\r\n\r\n    function repairTheCastle() returns(bool) {\r\n        uint amount = msg.value;\r\n        // Check if the minimum amount if reached\r\n        if (amount < 10 finney) {\r\n            msg.sender.send(msg.value);\r\n            return false;\r\n        }\r\n        // If the amount received is more than 100 ETH return the difference\r\n        if (amount > 100 ether) {\r\n            msg.sender.send(msg.value - 100 ether);\r\n            amount = 100 ether;\r\n        }\r\n\r\n        // Check if the Castle has fell\r\n        if (lastReparation + SIX_HOURS < block.timestamp) {\r\n            // Send the Piggy Bank to the last 3 citizens\r\n            // If there is no one who contributed this last 6 hours, no action needed\r\n            if (totalCitizens == 1) {\r\n                // If there is only one Citizen who contributed, he gets the full Pigg Bank\r\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank);\r\n            } else if (totalCitizens == 2) {\r\n                // If only 2 citizens contributed\r\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 65 / 100);\r\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);\r\n            } else if (totalCitizens >= 3) {\r\n                // If there is 3 or more citizens who contributed\r\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 55 / 100);\r\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);\r\n                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);\r\n            }\r\n\r\n            // Define the new Piggy Bank\r\n            piggyBank = 0;\r\n\r\n            // Define the new Castle\r\n            jester = msg.sender;\r\n            lastReparation = block.timestamp;\r\n            citizensAddresses.push(msg.sender);\r\n            citizensAmounts.push(amount * 2);\r\n            totalCitizens += 1;\r\n            amountInvested += amount;\r\n\r\n            // All goes to the Piggy Bank\r\n            piggyBank += amount;\r\n\r\n            // The Jetster take 3%\r\n            jester.send(amount * 3 / 100);\r\n\r\n            // The brided Citizen takes 3%\r\n            collectedFee += amount * 3 / 100;\r\n\r\n            round += 1;\r\n        } else {\r\n            // The Castle is still up\r\n            lastReparation = block.timestamp;\r\n            citizensAddresses.push(msg.sender);\r\n            citizensAmounts.push(amount * 2);\r\n            totalCitizens += 1;\r\n            amountInvested += amount;\r\n\r\n            // 5% goes to the Piggy Bank\r\n            piggyBank += (amount * 5 / 100);\r\n\r\n            // The Jetster takes 3%\r\n            jester.send(amount * 3 / 100);\r\n\r\n            // The brided Citizen takes 3%\r\n            collectedFee += amount * 3 / 100;\r\n\r\n            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - collectedFee) && lastCitizenPaid <= totalCitizens) {\r\n                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);\r\n                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];\r\n                lastCitizenPaid += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    // fallback function\r\n    function() {\r\n        repairTheCastle();\r\n    }\r\n\r\n    // When the castle would be no more...\r\n    function surrender() {\r\n        if (msg.sender == bribedCitizen) {\r\n            bribedCitizen.send(address(this).balance);\r\n            selfdestruct(bribedCitizen);\r\n        }\r\n    }\r\n\r\n    // When the brided Citizen decides to give his seat to someone else\r\n    function newBribedCitizen(address newBribedCitizen) {\r\n        if (msg.sender == bribedCitizen) {\r\n            bribedCitizen = newBribedCitizen;\r\n        }\r\n    }\r\n\r\n    // When the brided Citizen decides to collect his fees\r\n    function collectFee() {\r\n        if (msg.sender == bribedCitizen) {\r\n            bribedCitizen.send(collectedFee);\r\n        }\r\n    }\r\n\r\n    // When the jester can't handle it anymore, he can give his position to someone else\r\n    function newJester(address newJester) {\r\n        if (msg.sender == jester) {\r\n            jester = newJester;\r\n        }\r\n    }       \r\n}", 
  "balance": "6<b>.</b>135631938835206229 Ether", 
  "name": "ProtectTheCastle", 
  "transactions": "552", 
  "address": "0x7d56485e026d5d3881f778e99969d2b1f90c50af"
 }, 
 {
  "source": "contract owned {\r\n        address public owner;\r\n\r\n        function owned() {\r\n                owner = msg.sender;\r\n        }\r\n\r\n        modifier onlyOwner {\r\n                if (msg.sender != owner) throw;\r\n                _\r\n        }\r\n\r\n        function transferOwnership(address newOwner) onlyOwner {\r\n                owner = newOwner;\r\n        }\r\n}\r\n\r\n/* The token is used as a voting shares */\r\ncontract token {\r\n        function mintToken(address target, uint256 mintedAmount);\r\n}\r\n\r\ncontract Congress is owned {\r\n\r\n        /* Contract Variables and events */\r\n        uint public minimumQuorum;\r\n        uint public debatingPeriodInMinutes;\r\n        int public majorityMargin;\r\n        Proposal[] public proposals;\r\n        uint public numProposals;\r\n        mapping(address => uint) public memberId;\r\n        Member[] public members;\r\n\r\n        address public unicornAddress;\r\n        uint public priceOfAUnicornInFinney;\r\n\r\n        event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\r\n        event Voted(uint proposalID, bool position, address voter, string justification);\r\n        event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\r\n        event MembershipChanged(address member);\r\n        event ChangeOfRules(uint minimumQuorum, uint debatingPeriodInMinutes, int majorityMargin);\r\n\r\n        struct Proposal {\r\n                address recipient;\r\n                uint amount;\r\n                string description;\r\n                uint votingDeadline;\r\n                bool executed;\r\n                bool proposalPassed;\r\n                uint numberOfVotes;\r\n                int currentResult;\r\n                bytes32 proposalHash;\r\n                Vote[] votes;\r\n                mapping(address => bool) voted;\r\n        }\r\n\r\n        struct Member {\r\n                address member;\r\n                uint voteWeight;\r\n                bool canAddProposals;\r\n                string name;\r\n                uint memberSince;\r\n        }\r\n\r\n        struct Vote {\r\n                bool inSupport;\r\n                address voter;\r\n                string justification;\r\n        }\r\n\r\n\r\n        /* First time setup */\r\n        function Congress(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority, address congressLeader) {\r\n                minimumQuorum = minimumQuorumForProposals;\r\n                debatingPeriodInMinutes = minutesForDebate;\r\n                majorityMargin = marginOfVotesForMajority;\r\n                members.length++;\r\n                members[0] = Member({\r\n                        member: 0,\r\n                        voteWeight: 0,\r\n                        canAddProposals: false,\r\n                        memberSince: now,\r\n                        name: ''\r\n                });\r\n                if (congressLeader != 0) owner = congressLeader;\r\n\r\n        }\r\n\r\n        /*make member*/\r\n        function changeMembership(address targetMember, uint voteWeight, bool canAddProposals, string memberName) onlyOwner {\r\n                uint id;\r\n                if (memberId[targetMember] == 0) {\r\n                        memberId[targetMember] = members.length;\r\n                        id = members.length++;\r\n                        members[id] = Member({\r\n                                member: targetMember,\r\n                                voteWeight: voteWeight,\r\n                                canAddProposals: canAddProposals,\r\n                                memberSince: now,\r\n                                name: memberName\r\n                        });\r\n                } else {\r\n                        id = memberId[targetMember];\r\n                        Member m = members[id];\r\n                        m.voteWeight = voteWeight;\r\n                        m.canAddProposals = canAddProposals;\r\n                        m.name = memberName;\r\n                }\r\n\r\n                MembershipChanged(targetMember);\r\n\r\n        }\r\n\r\n        /*change rules*/\r\n        function changeVotingRules(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority) onlyOwner {\r\n                minimumQuorum = minimumQuorumForProposals;\r\n                debatingPeriodInMinutes = minutesForDebate;\r\n                majorityMargin = marginOfVotesForMajority;\r\n\r\n                ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);\r\n        }\r\n\r\n        // ribbonPriceInEther\r\n        function changeUnicorn(uint newUnicornPriceInFinney, address newUnicornAddress) onlyOwner {\r\n                unicornAddress = newUnicornAddress;\r\n                priceOfAUnicornInFinney = newUnicornPriceInFinney;\r\n        }\r\n\r\n        /* Function to create a new proposal */\r\n        function newProposalInWei(address beneficiary, uint weiAmount, string JobDescription, bytes transactionBytecode) returns(uint proposalID) {\r\n                if (memberId[msg.sender] == 0 || !members[memberId[msg.sender]].canAddProposals) throw;\r\n\r\n                proposalID = proposals.length++;\r\n                Proposal p = proposals[proposalID];\r\n                p.recipient = beneficiary;\r\n                p.amount = weiAmount;\r\n                p.description = JobDescription;\r\n                p.proposalHash = sha3(beneficiary, weiAmount, transactionBytecode);\r\n                p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;\r\n                p.executed = false;\r\n                p.proposalPassed = false;\r\n                p.numberOfVotes = 0;\r\n                ProposalAdded(proposalID, beneficiary, weiAmount, JobDescription);\r\n                numProposals = proposalID + 1;\r\n        }\r\n\r\n        /* Function to create a new proposal */\r\n        function newProposalInEther(address beneficiary, uint etherAmount, string JobDescription, bytes transactionBytecode) returns(uint proposalID) {\r\n                if (memberId[msg.sender] == 0 || !members[memberId[msg.sender]].canAddProposals) throw;\r\n\r\n                proposalID = proposals.length++;\r\n                Proposal p = proposals[proposalID];\r\n                p.recipient = beneficiary;\r\n                p.amount = etherAmount * 1 ether;\r\n                p.description = JobDescription;\r\n                p.proposalHash = sha3(beneficiary, etherAmount * 1 ether, transactionBytecode);\r\n                p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;\r\n                p.executed = false;\r\n                p.proposalPassed = false;\r\n                p.numberOfVotes = 0;\r\n                ProposalAdded(proposalID, beneficiary, etherAmount, JobDescription);\r\n                numProposals = proposalID + 1;\r\n        }\r\n\r\n        /* function to check if a proposal code matches */\r\n        function checkProposalCode(uint proposalNumber, address beneficiary, uint amount, bytes transactionBytecode) constant returns(bool codeChecksOut) {\r\n                Proposal p = proposals[proposalNumber];\r\n                return p.proposalHash == sha3(beneficiary, amount, transactionBytecode);\r\n        }\r\n\r\n        function vote(uint proposalNumber, bool supportsProposal, string justificationText) returns(uint voteID) {\r\n                if (memberId[msg.sender] == 0) throw;\r\n\r\n                uint voteWeight = members[memberId[msg.sender]].voteWeight;\r\n\r\n                Proposal p = proposals[proposalNumber]; // Get the proposal\r\n                if (p.voted[msg.sender] == true) throw; // If has already voted, cancel\r\n                p.voted[msg.sender] = true; // Set this voter as having voted\r\n                p.numberOfVotes += voteWeight; // Increase the number of votes\r\n                if (supportsProposal) { // If they support the proposal\r\n                        p.currentResult += int(voteWeight); // Increase score\r\n                } else { // If they don't\r\n                        p.currentResult -= int(voteWeight); // Decrease the score\r\n                }\r\n                // Create a log of this event\r\n                Voted(proposalNumber, supportsProposal, msg.sender, justificationText);\r\n        }\r\n\r\n        function executeProposal(uint proposalNumber, bytes transactionBytecode) returns(int result) {\r\n                Proposal p = proposals[proposalNumber];\r\n                /* Check if the proposal can be executed */\r\n                if (now < p.votingDeadline // has the voting deadline arrived?  \r\n                        || p.executed // has it been already executed? \r\n                        || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) // Does the transaction code match the proposal? \r\n                        || p.numberOfVotes < minimumQuorum) // has minimum quorum?\r\n                        throw;\r\n\r\n                /* execute result */\r\n                if (p.currentResult > majorityMargin) {\r\n                        /* If difference between support and opposition is larger than margin */\r\n                        p.recipient.call.value(p.amount)(transactionBytecode);\r\n                        p.executed = true;\r\n                        p.proposalPassed = true;\r\n                } else {\r\n                        p.executed = true;\r\n                        p.proposalPassed = false;\r\n                }\r\n                // Fire Events\r\n                ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\r\n        }\r\n\r\n        function() {\r\n                if (msg.value > priceOfAUnicornInFinney) {\r\n                        token unicorn = token(unicornAddress);\r\n                        unicorn.mintToken(msg.sender, msg.value / (priceOfAUnicornInFinney * 1 finney));\r\n                }\r\n\r\n        }\r\n}\r\n\r\n\r\ncontract MyToken is owned {\r\n        /* Public variables of the token */\r\n        string public name;\r\n        string public symbol;\r\n        uint8 public decimals;\r\n        uint256 public totalSupply;\r\n\r\n        /* This creates an array with all balances */\r\n        mapping(address => uint256) public balanceOf;\r\n        mapping(address => bool) public frozenAccount;\r\n        mapping(address => mapping(address => uint)) public allowance;\r\n        mapping(address => mapping(address => uint)) public spentAllowance;\r\n\r\n\r\n        /* This generates a public event on the blockchain that will notify clients */\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event FrozenFunds(address target, bool frozen);\r\n\r\n        /* Initializes contract with initial supply tokens to the creator of the contract */\r\n        function MyToken(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter) {\r\n                if (centralMinter != 0) owner = centralMinter; // Sets the minter\r\n                balanceOf[msg.sender] = initialSupply; // Give the creator all initial tokens                    \r\n                name = tokenName; // Set the name for display purposes     \r\n                symbol = tokenSymbol; // Set the symbol for display purposes    \r\n                decimals = decimalUnits; // Amount of decimals for display purposes        \r\n                totalSupply = initialSupply;\r\n        }\r\n\r\n        /* Send coins */\r\n        function transfer(address _to, uint256 _value) {\r\n                if (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough   \r\n                if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n                if (frozenAccount[msg.sender]) throw; // Check if frozen\r\n                balanceOf[msg.sender] -= _value; // Subtract from the sender\r\n                balanceOf[_to] += _value; // Add the same to the recipient            \r\n                Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\r\n        }\r\n\r\n        function mintToken(address target, uint256 mintedAmount) onlyOwner {\r\n                balanceOf[target] += mintedAmount;\r\n                totalSupply += mintedAmount;\r\n                Transfer(owner, target, mintedAmount);\r\n        }\r\n\r\n        function freezeAccount(address target, bool freeze) onlyOwner {\r\n                frozenAccount[target] = freeze;\r\n                FrozenFunds(target, freeze);\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\r\n                if (balanceOf[_from] < _value) throw; // Check if the sender has enough   \r\n                if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n                if (frozenAccount[_from]) throw; // Check if frozen\r\n                if (spentAllowance[_from][msg.sender] + _value > allowance[_from][msg.sender]) throw; // Check allowance\r\n                balanceOf[_from] -= _value; // Subtract from the sender\r\n                balanceOf[_to] += _value; // Add the same to the recipient            \r\n                spentAllowance[_from][msg.sender] += _value;\r\n                Transfer(msg.sender, _to, _value);\r\n        }\r\n\r\n        function approve(address _spender, uint256 _value) returns(bool success) {\r\n                allowance[msg.sender][_spender] = _value;\r\n        }\r\n\r\n        function() {\r\n                //owner.send(msg.value);\r\n                throw;\r\n        }\r\n}", 
  "balance": "3,987<b>.</b>512354663571743689 Ether", 
  "name": "Congress", 
  "transactions": "539", 
  "address": "0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n/*\r\n * Token - is a smart contract interface \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract TokenInterface {\r\n\r\n        \r\n    // total amount of tokens\r\n    uint totalSupply;\r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    \r\n    function transfer(address to, uint256 value) returns (bool success);\r\n\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how much is \r\n     *               permitted to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permitted to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n\r\n    // events notifications\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/*\r\n * StandardToken - is a smart contract  \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: \r\n *         https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is TokenInterface {\r\n\r\n\r\n    // token ownership\r\n    mapping (address => uint256) balances;\r\n\r\n    // spending permision management\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    \r\n    \r\n    function StandardToken(){\r\n    }\r\n    \r\n    \r\n    /**\r\n     * transfer() - transfer tokens from msg.sender balance \r\n     *              to requested account\r\n     *\r\n     *  @param to    - target address to transfer tokens\r\n     *  @param value - ammount of tokens to transfer\r\n     *\r\n     *  @return - success / failure of the transaction\r\n     */    \r\n    function transfer(address to, uint256 value) returns (bool success) {\r\n        \r\n        \r\n        if (balances[msg.sender] >= value && value > 0) {\r\n\r\n            // do actual tokens transfer       \r\n            balances[msg.sender] -= value;\r\n            balances[to]         += value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            \r\n            return false; \r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    /**\r\n     * transferFrom() - \r\n     *\r\n     *  @param from  - \r\n     *  @param to    - \r\n     *  @param value - \r\n     *\r\n     *  @return \r\n     */\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success) {\r\n    \r\n        if ( balances[from] >= value && \r\n             allowed[from][msg.sender] >= value && \r\n             value > 0) {\r\n                                          \r\n    \r\n            // do the actual transfer\r\n            balances[from] -= value;    \r\n            balances[to] =+ value;            \r\n            \r\n\r\n            // addjust the permision, after part of \r\n            // permited to spend value was used\r\n            allowed[from][msg.sender] -= value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { \r\n            \r\n            return false; \r\n        }\r\n    }\r\n\r\n    \r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success) {\r\n        \r\n        // now spender can use balance in \r\n        // ammount of value from owner balance\r\n        allowed[msg.sender][spender] = value;\r\n        \r\n        // rise event about the transaction\r\n        Approval(msg.sender, spender, value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how mouch is \r\n     *               permited to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permited to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining) {\r\n      return allowed[owner][spender];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @title Hacker Gold\r\n * \r\n * The official token powering the hack.ether.camp virtual accelerator.\r\n * This is the only way to acquire tokens from startups during the event.\r\n *\r\n * Whitepaper https://hack.ether.camp/whitepaper\r\n *\r\n */\r\ncontract HackerGold is StandardToken {\r\n\r\n    // Name of the token    \r\n    string public name = \"HackerGold\";\r\n\r\n    // Decimal places\r\n    uint8  public decimals = 3;\r\n    // Token abbreviation        \r\n    string public symbol = \"HKG\";\r\n    \r\n    // 1 ether = 200 hkg\r\n    uint BASE_PRICE = 200;\r\n    // 1 ether = 150 hkg\r\n    uint MID_PRICE = 150;\r\n    // 1 ether = 100 hkg\r\n    uint FIN_PRICE = 100;\r\n    // Safety cap\r\n    uint SAFETY_LIMIT = 4000000 ether;\r\n    // Zeros after the point\r\n    uint DECIMAL_ZEROS = 1000;\r\n    \r\n    // Total value in wei\r\n    uint totalValue;\r\n    \r\n    // Address of multisig wallet holding ether from sale\r\n    address wallet;\r\n\r\n    // Structure of sale increase milestones\r\n    struct milestones_struct {\r\n      uint p1;\r\n      uint p2; \r\n      uint p3;\r\n      uint p4;\r\n      uint p5;\r\n      uint p6;\r\n    }\r\n    // Milestones instance\r\n    milestones_struct milestones;\r\n    \r\n    /**\r\n     * Constructor of the contract.\r\n     * \r\n     * Passes address of the account holding the value.\r\n     * HackerGold contract itself does not hold any value\r\n     * \r\n     * @param multisig address of MultiSig wallet which will hold the value\r\n     */\r\n    function HackerGold(address multisig) {\r\n        \r\n        wallet = multisig;\r\n\r\n        // set time periods for sale\r\n        milestones = milestones_struct(\r\n        \r\n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        );\r\n                \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Fallback function: called on ether sent.\r\n     * \r\n     * It calls to createHKG function with msg.sender \r\n     * as a value for holder argument\r\n     */\r\n    function () payable {\r\n        createHKG(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Creates HKG tokens.\r\n     * \r\n     * Runs sanity checks including safety cap\r\n     * Then calculates current price by getPrice() function, creates HKG tokens\r\n     * Finally sends a value of transaction to the wallet\r\n     * \r\n     * Note: due to lack of floating point types in Solidity,\r\n     * contract assumes that last 3 digits in tokens amount are stood after the point.\r\n     * It means that if stored HKG balance is 100000, then its real value is 100 HKG\r\n     * \r\n     * @param holder token holder\r\n     */\r\n    function createHKG(address holder) payable {\r\n        \r\n        if (now < milestones.p1) throw;\r\n        if (now >= milestones.p6) throw;\r\n        if (msg.value == 0) throw;\r\n    \r\n        // safety cap\r\n        if (getTotalValue() + msg.value > SAFETY_LIMIT) throw; \r\n    \r\n        uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n        totalSupply += tokens;\r\n        balances[holder] += tokens;\r\n        totalValue += msg.value;\r\n        \r\n        if (!wallet.send(msg.value)) throw;\r\n    }\r\n    \r\n    /**\r\n     * Denotes complete price structure during the sale.\r\n     *\r\n     * @return HKG amount per 1 ETH for the current moment in time\r\n     */\r\n    function getPrice() constant returns (uint result) {\r\n        \r\n        if (now < milestones.p1) return 0;\r\n        \r\n        if (now >= milestones.p1 && now < milestones.p2) {\r\n        \r\n            return BASE_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p2 && now < milestones.p3) {\r\n            \r\n            uint days_in = 1 + (now - milestones.p2) / 1 days; \r\n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p3 && now < milestones.p4) {\r\n        \r\n            return MID_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p4 && now < milestones.p5) {\r\n            \r\n            days_in = 1 + (now - milestones.p4) / 1 days; \r\n            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p5 && now < milestones.p6) {\r\n        \r\n            return FIN_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p6){\r\n\r\n            return 0;\r\n        }\r\n\r\n     }\r\n    \r\n    /**\r\n     * Returns total stored HKG amount.\r\n     * \r\n     * Contract assumes that last 3 digits of this value are behind the decimal place. i.e. 10001 is 10.001\r\n     * Thus, result of this function should be divided by 1000 to get HKG value\r\n     * \r\n     * @return result stored HKG amount\r\n     */\r\n    function getTotalSupply() constant returns (uint result) {\r\n        return totalSupply;\r\n    } \r\n\r\n    /**\r\n     * It is used for test purposes.\r\n     * \r\n     * Returns the result of 'now' statement of Solidity language\r\n     * \r\n     * @return unix timestamp for current moment in time\r\n     */\r\n    function getNow() constant returns (uint result) {\r\n        return now;\r\n    }\r\n\r\n    /**\r\n     * Returns total value passed through the contract\r\n     * \r\n     * @return result total value in wei\r\n     */\r\n    function getTotalValue() constant returns (uint result) {\r\n        return totalValue;  \r\n    }\r\n}\r\n\r\n/**\r\n * \r\n * EventInfo - imutable class that denotes\r\n * the time of the virtual accelerator hack\r\n * event\r\n * \r\n */\r\ncontract EventInfo{\r\n    \r\n    \r\n    uint constant HACKATHON_5_WEEKS = 60 * 60 * 24 * 7 * 5;\r\n    uint constant T_1_WEEK = 60 * 60 * 24 * 7;\r\n\r\n    uint eventStart = 1479391200; // Thu, 17 Nov 2016 14:00:00 GMT\r\n    uint eventEnd = eventStart + HACKATHON_5_WEEKS;\r\n    \r\n    \r\n    /**\r\n     * getEventStart - return the start of the event time\r\n     */ \r\n    function getEventStart() constant returns (uint result){        \r\n       return eventStart;\r\n    } \r\n    \r\n    /**\r\n     * getEventEnd - return the end of the event time\r\n     */ \r\n    function getEventEnd() constant returns (uint result){        \r\n       return eventEnd;\r\n    } \r\n    \r\n    \r\n    /**\r\n     * getVotingStart - the voting starts 1 week after the \r\n     *                  event starts\r\n     */ \r\n    function getVotingStart() constant returns (uint result){\r\n        return eventStart+ T_1_WEEK;\r\n    }\r\n\r\n    /**\r\n     * getTradingStart - the DST tokens trading starts 1 week \r\n     *                   after the event starts\r\n     */ \r\n    function getTradingStart() constant returns (uint result){\r\n        return eventStart+ T_1_WEEK;\r\n    }\r\n\r\n    /**\r\n     * getNow - helper class to check what time the contract see\r\n     */\r\n    function getNow() constant returns (uint result){        \r\n       return now;\r\n    } \r\n    \r\n}\r\n\r\n/*\r\n * DSTContract - DST stands for decentralized startup team.\r\n *               the contract ensures funding for a decentralized\r\n *               team in 2 phases: \r\n *\r\n *                +. Funding by HKG during the hackathon event. \r\n *                +. Funding by Ether after the event is over. \r\n *\r\n *               After the funds been collected there is a governence\r\n *               mechanism managed by proposition to withdraw funds\r\n *               for development usage. \r\n *\r\n *               The DST ensures that backers of the projects keeps\r\n *               some influence on the project by ability to reject\r\n *               propositions they find as non effective. \r\n *\r\n *               In very radical occasions the backers may loose \r\n *               the trust in the team completelly, in that case \r\n *               there is an option to propose impeachment process\r\n *               completelly removing the execute and assigning new\r\n *               person to manage the funds. \r\n *\r\n */\r\ncontract DSTContract is StandardToken{\r\n\r\n    // Zeros after the point\r\n    uint DECIMAL_ZEROS = 1000;\r\n    // Proposal lifetime\r\n    uint PROPOSAL_LIFETIME = 10 days;\r\n    // Proposal funds threshold, in percents\r\n    uint PROPOSAL_FUNDS_TH = 20;\r\n\r\n    address   executive; \r\n        \r\n    EventInfo eventInfo;\r\n    \r\n    // Indicated where the DST is traded\r\n    address virtualExchangeAddress;\r\n    \r\n    HackerGold hackerGold;\r\n        \r\n    mapping (address => uint256) votingRights;\r\n\r\n\r\n    // 1 - HKG => DST qty; tokens for 1 HKG\r\n    uint hkgPrice;\r\n    \r\n    // 1 - Ether => DST qty; tokens for 1 Ether\r\n    uint etherPrice;\r\n    \r\n    string public name = \"...\";                   \r\n    uint8  public decimals = 3;                 \r\n    string public symbol = \"...\";\r\n    \r\n    bool ableToIssueTokens = true; \r\n    \r\n    uint preferedQtySold;\r\n\r\n    uint collectedHKG; \r\n    uint collectedEther;    \r\n    \r\n    // Proposal of the funds spending\r\n    mapping (bytes32 => Proposal) proposals;\r\n\r\n    enum ProposalCurrency { HKG, ETHER }\r\n    ProposalCurrency enumDeclaration;\r\n                  \r\n       \r\n    struct Proposal{\r\n        \r\n        bytes32 id;\r\n        uint value;\r\n\r\n        string urlDetails;\r\n\r\n        uint votindEndTS;\r\n                \r\n        uint votesObjecting;\r\n        \r\n        address submitter;\r\n        bool redeemed;\r\n\r\n        ProposalCurrency proposalCurrency;\r\n        \r\n        mapping (address => bool) voted;\r\n    }\r\n    uint counterProposals;\r\n    uint timeOfLastProposal;\r\n    \r\n    Proposal[] listProposals;\r\n    \r\n\r\n    /**\r\n     * Impeachment process proposals\r\n     */    \r\n    struct ImpeachmentProposal{\r\n        \r\n        string urlDetails;\r\n        \r\n        address newExecutive;\r\n\r\n        uint votindEndTS;        \r\n        uint votesSupporting;\r\n        \r\n        mapping (address => bool) voted;        \r\n    }\r\n    ImpeachmentProposal lastImpeachmentProposal;\r\n\r\n        \r\n    /**\r\n     * \r\n     *  DSTContract: ctor for DST token and governence contract\r\n     *\r\n     *  @param eventInfoAddr EventInfo: address of object denotes events \r\n     *                                  milestones      \r\n     *  @param hackerGoldAddr HackerGold: address of HackerGold token\r\n     *\r\n     *  @param dstName string: dstName: real name of the team\r\n     *\r\n     *  @param dstSymbol string: 3 letter symbold of the team\r\n     *\r\n     */ \r\n    function DSTContract(EventInfo eventInfoAddr, HackerGold hackerGoldAddr, string dstName, string dstSymbol){\r\n    \r\n      executive   = msg.sender;  \r\n      name        = dstName;\r\n      symbol      = dstSymbol;\r\n\r\n      hackerGold = HackerGold(hackerGoldAddr);\r\n      eventInfo  = EventInfo(eventInfoAddr);\r\n    }\r\n    \r\n\r\n    function() payable\r\n               onlyAfterEnd {\r\n        \r\n        // there is tokens left from hackathon \r\n        if (etherPrice == 0) throw;\r\n        \r\n        uint tokens = msg.value * etherPrice * DECIMAL_ZEROS / (1 ether);\r\n        \r\n        // check if demand of tokens is \r\n        // overflow the supply \r\n        uint retEther = 0;\r\n        if (balances[this] < tokens) {\r\n            \r\n            tokens = balances[this];\r\n            retEther = msg.value - tokens / etherPrice * (1 finney);\r\n        \r\n            // return left ether \r\n            if (!msg.sender.send(retEther)) throw;\r\n        }\r\n        \r\n        \r\n        // do transfer\r\n        balances[msg.sender] += tokens;\r\n        balances[this] -= tokens;\r\n        \r\n        // count collected ether \r\n        collectedEther += msg.value - retEther; \r\n        \r\n        // rise event\r\n        BuyForEtherTransaction(msg.sender, collectedEther, totalSupply, etherPrice, tokens);\r\n        \r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     * setHKGPrice - set price: 1HKG => DST tokens qty\r\n     *\r\n     *  @param qtyForOneHKG uint: DST tokens for 1 HKG\r\n     * \r\n     */    \r\n     function setHKGPrice(uint qtyForOneHKG) onlyExecutive  {\r\n         \r\n         hkgPrice = qtyForOneHKG;\r\n         PriceHKGChange(qtyForOneHKG, preferedQtySold, totalSupply);\r\n     }\r\n     \r\n     \r\n    \r\n    /**\r\n     * \r\n     * issuePreferedTokens - prefered tokens issued on the hackathon event\r\n     *                       grant special rights\r\n     *\r\n     *  @param qtyForOneHKG uint: price DST tokens for one 1 HKG\r\n     *  @param qtyToEmit uint: new supply of tokens \r\n     * \r\n     */\r\n    function issuePreferedTokens(uint qtyForOneHKG, \r\n                                 uint qtyToEmit) onlyExecutive \r\n                                                 onlyIfAbleToIssueTokens\r\n                                                 onlyBeforeEnd\r\n                                                 onlyAfterTradingStart {\r\n                \r\n        // no issuence is allowed before enlisted on the\r\n        // exchange \r\n        if (virtualExchangeAddress == 0x0) throw;\r\n            \r\n        totalSupply    += qtyToEmit;\r\n        balances[this] += qtyToEmit;\r\n        hkgPrice = qtyForOneHKG;\r\n        \r\n        \r\n        // now spender can use balance in \r\n        // amount of value from owner balance\r\n        allowed[this][virtualExchangeAddress] += qtyToEmit;\r\n        \r\n        // rise event about the transaction\r\n        Approval(this, virtualExchangeAddress, qtyToEmit);\r\n        \r\n        // rise event \r\n        DstTokensIssued(hkgPrice, preferedQtySold, totalSupply, qtyToEmit);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    /**\r\n     * \r\n     * buyForHackerGold - on the hack event this function is available \r\n     *                    the buyer for hacker gold will gain votes to \r\n     *                    influence future proposals on the DST\r\n     *    \r\n     *  @param hkgValue - qty of this DST tokens for 1 HKG     \r\n     * \r\n     */\r\n    function buyForHackerGold(uint hkgValue) onlyBeforeEnd \r\n                                             returns (bool success) {\r\n    \r\n      // validate that the caller is official accelerator HKG Exchange\r\n      if (msg.sender != virtualExchangeAddress) throw;\r\n      \r\n      \r\n      // transfer token \r\n      address sender = tx.origin;\r\n      uint tokensQty = hkgValue * hkgPrice;\r\n\r\n      // gain voting rights\r\n      votingRights[sender] +=tokensQty;\r\n      preferedQtySold += tokensQty;\r\n      collectedHKG += hkgValue;\r\n\r\n      // do actual transfer\r\n      transferFrom(this, \r\n                   virtualExchangeAddress, tokensQty);\r\n      transfer(sender, tokensQty);        \r\n            \r\n      // rise event       \r\n      BuyForHKGTransaction(sender, preferedQtySold, totalSupply, hkgPrice, tokensQty);\r\n        \r\n      return true;\r\n    }\r\n        \r\n    \r\n    /**\r\n     * \r\n     * issueTokens - function will issue tokens after the \r\n     *               event, able to sell for 1 ether \r\n     * \r\n     *  @param qtyForOneEther uint: DST tokens for 1 ETH\r\n     *  @param qtyToEmit uint: new tokens supply\r\n     *\r\n     */\r\n    function issueTokens(uint qtyForOneEther, \r\n                         uint qtyToEmit) onlyAfterEnd \r\n                                         onlyExecutive\r\n                                         onlyIfAbleToIssueTokens {\r\n         \r\n         balances[this] += qtyToEmit;\r\n         etherPrice = qtyForOneEther;\r\n         totalSupply    += qtyToEmit;\r\n         \r\n         // rise event  \r\n         DstTokensIssued(qtyForOneEther, totalSupply, totalSupply, qtyToEmit);\r\n    }\r\n     \r\n    \r\n    /**\r\n     * setEtherPrice - change the token price\r\n     *\r\n     *  @param qtyForOneEther uint: new price - DST tokens for 1 ETH\r\n     */     \r\n    function setEtherPrice(uint qtyForOneEther) onlyAfterEnd\r\n                                                onlyExecutive {\r\n         etherPrice = qtyForOneEther; \r\n\r\n         // rise event for this\r\n         NewEtherPrice(qtyForOneEther);\r\n    }    \r\n    \r\n\r\n    /**\r\n     *  disableTokenIssuance - function will disable any \r\n     *                         option for future token \r\n     *                         issuence\r\n     */\r\n    function disableTokenIssuance() onlyExecutive {\r\n        ableToIssueTokens = false;\r\n        \r\n        DisableTokenIssuance();\r\n    }\r\n\r\n    \r\n    /**\r\n     *  burnRemainToken -  eliminated all available for sale\r\n     *                     tokens. \r\n     */\r\n    function burnRemainToken() onlyExecutive {\r\n    \r\n        totalSupply -= balances[this];\r\n        balances[this] = 0;\r\n        \r\n        // rise event for this\r\n        BurnedAllRemainedTokens();\r\n    }\r\n    \r\n    /**\r\n     *  submitEtherProposal: submit proposal to use part of the \r\n     *                       collected ether funds\r\n     *\r\n     *   @param requestValue uint: value in wei \r\n     *   @param url string: details of the proposal \r\n     */ \r\n    function submitEtherProposal(uint requestValue, string url) onlyAfterEnd \r\n                                                                onlyExecutive returns (bytes32 resultId, bool resultSucces) {       \r\n    \r\n        // ensure there is no more issuence available \r\n        if (ableToIssueTokens) throw;\r\n            \r\n        // ensure there is no more tokens available \r\n        if (balanceOf(this) > 0) throw;\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n            \r\n        uint percent = collectedEther / 100;\r\n            \r\n        if (requestValue > PROPOSAL_FUNDS_TH * percent) throw;\r\n\r\n        // if remained value is less than requested gain all.\r\n        if (requestValue > this.balance) \r\n            requestValue = this.balance;    \r\n            \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n            \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n            \r\n        timeOfLastProposal = now;                        \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);\r\n    }\r\n    \r\n    \r\n     \r\n    /**\r\n     * \r\n     * submitHKGProposal - submit proposal to request for \r\n     *                     partial HKG funds collected \r\n     * \r\n     *  @param requestValue uint: value in HKG to request. \r\n     *  @param url string: url with details on the proposition \r\n     */\r\n    function submitHKGProposal(uint requestValue, string url) onlyAfterEnd\r\n                                                              onlyExecutive returns (bytes32 resultId, bool resultSucces){\r\n        \r\n\r\n        // If there is no 2 months over since the last event.\r\n        // There is no posible to get any HKG. After 2 months\r\n        // all the HKG is available. \r\n        if (now < (eventInfo.getEventEnd() + 8 weeks)) {\r\n            throw;\r\n        }\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n\r\n        uint percent = preferedQtySold / 100;\r\n        \r\n        // validate the amount is legit\r\n        // first 5 proposals should be less than 20% \r\n        if (counterProposals <= 5 && \r\n            requestValue     >  PROPOSAL_FUNDS_TH * percent) throw;\r\n                \r\n        // if remained value is less than requested \r\n        // gain all.\r\n        if (requestValue > getHKGOwned()) \r\n            requestValue = getHKGOwned();\r\n        \r\n        \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n        \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n        \r\n        ++counterProposals;\r\n        timeOfLastProposal = now;                \r\n                \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);        \r\n    }  \r\n    \r\n    \r\n    \r\n    /**\r\n     * objectProposal - object previously submitted proposal, \r\n     *                  the objection right is obtained by \r\n     *                  purchasing prefered tokens on time of \r\n     *                  the hackathon.\r\n     * \r\n     *  @param id bytes32 : the id of the proposla to redeem\r\n     */\r\n     function objectProposal(bytes32 id){\r\n         \r\n        Proposal memory proposal = proposals[id];\r\n         \r\n        // check proposal exist \r\n        if (proposals[id].id == 0) throw;\r\n\r\n        // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n         \r\n        // ensure objection time\r\n        if (now >= proposals[id].votindEndTS) throw;\r\n         \r\n        // ensure not voted  \r\n        if (proposals[id].voted[msg.sender]) throw;\r\n         \r\n         // submit votes\r\n         uint votes = votingRights[msg.sender];\r\n         proposals[id].votesObjecting += votes;\r\n         \r\n         // mark voted \r\n         proposals[id].voted[msg.sender] = true; \r\n         \r\n         uint idx = getIndexByProposalId(id);\r\n         listProposals[idx] = proposals[id];   \r\n\r\n         ObjectedVote(id, msg.sender, votes);         \r\n     }\r\n     \r\n     \r\n     function getIndexByProposalId(bytes32 id) returns (uint result){\r\n         \r\n         for (uint i = 0; i < listProposals.length; ++i){\r\n             if (id == listProposals[i].id) return i;\r\n         }\r\n     }\r\n    \r\n    \r\n   \r\n    /**\r\n     * redeemProposalFunds - redeem funds requested by prior \r\n     *                       submitted proposal     \r\n     * \r\n     * @param id bytes32: the id of the proposal to redeem\r\n     */\r\n    function redeemProposalFunds(bytes32 id) onlyExecutive {\r\n\r\n        if (proposals[id].id == 0) throw;\r\n        if (proposals[id].submitter != msg.sender) throw;\r\n\r\n        // ensure objection time\r\n        if (now < proposals[id].votindEndTS) throw;\r\n                           \r\n    \r\n            // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n\r\n        // check votes objection => 55% of total votes\r\n        uint objectionThreshold = preferedQtySold / 100 * 55;\r\n        if (proposals[id].votesObjecting  > objectionThreshold) throw;\r\n    \r\n    \r\n        if (proposals[id].proposalCurrency == ProposalCurrency.HKG){\r\n            \r\n            // send hacker gold \r\n            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \r\n                        \r\n        } else {\r\n                        \r\n           // send ether              \r\n           bool success = proposals[id].submitter.send(proposals[id].value); \r\n\r\n           // rise event\r\n           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \r\n        }\r\n        \r\n        // execute the proposal \r\n        proposals[id].redeemed = true; \r\n    }\r\n    \r\n    \r\n    /**\r\n     *  getAllTheFunds - to ensure there is no deadlock can \r\n     *                   can happen, and no case that voting \r\n     *                   structure will freeze the funds forever\r\n     *                   the startup will be able to get all the\r\n     *                   funds without a proposal required after\r\n     *                   6 months.\r\n     * \r\n     * \r\n     */             \r\n    function getAllTheFunds() onlyExecutive {\r\n        \r\n        // If there is a deadlock in voting participates\r\n        // the funds can be redeemed completelly in 6 months\r\n        if (now < (eventInfo.getEventEnd() + 24 weeks)) {\r\n            throw;\r\n        }  \r\n        \r\n        // all the Ether\r\n        bool success = msg.sender.send(this.balance);        \r\n        \r\n        // all the HKG\r\n        hackerGold.transfer(msg.sender, getHKGOwned());              \r\n    }\r\n    \r\n    \r\n    /**\r\n     * submitImpeachmentProposal - submit request to switch \r\n     *                             executive.\r\n     * \r\n     *  @param urlDetails  - details of the impeachment proposal \r\n     *  @param newExecutive - address of the new executive \r\n     * \r\n     */             \r\n     function submitImpeachmentProposal(string urlDetails, address newExecutive){\r\n         \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n         \r\n        // the submission of the first impeachment \r\n        // proposal is possible only after 3 months\r\n        // since the hackathon is over\r\n        if (now < (eventInfo.getEventEnd() + 12 weeks)) throw;\r\n        \r\n                \r\n        // check there is 1 months over since last one\r\n        if (lastImpeachmentProposal.votindEndTS != 0 && \r\n            lastImpeachmentProposal.votindEndTS +  2 weeks > now) throw;\r\n\r\n\r\n        // submit impeachment proposal\r\n        // add the votes of the submitter \r\n        // to the proposal right away\r\n        lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender]);\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n         \r\n        // rise event\r\n        ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive);\r\n     }\r\n    \r\n    \r\n    /**\r\n     * supportImpeachment - vote for impeachment proposal \r\n     *                      that is currently in progress\r\n     *\r\n     */\r\n    function supportImpeachment(){\r\n\r\n        // ensure that support is for exist proposal \r\n        if (lastImpeachmentProposal.newExecutive == 0x0) throw;\r\n    \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n        \r\n        // check if not voted already \r\n        if (lastImpeachmentProposal.voted[msg.sender]) throw;\r\n        \r\n        // check if not finished the 2 weeks of voting \r\n        if (lastImpeachmentProposal.votindEndTS + 2 weeks <= now) throw;\r\n                \r\n        // support the impeachment\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n        lastImpeachmentProposal.votesSupporting += votingRights[msg.sender];\r\n\r\n        // rise impeachment suppporting event\r\n        ImpeachmentSupport(msg.sender, votingRights[msg.sender]);\r\n        \r\n        // if the vote is over 70% execute the switch \r\n        uint percent = preferedQtySold / 100; \r\n        \r\n        if (lastImpeachmentProposal.votesSupporting >= 70 * percent){\r\n            executive = lastImpeachmentProposal.newExecutive;\r\n            \r\n            // impeachment event\r\n            ImpeachmentAccepted(executive);\r\n        }\r\n        \r\n    } \r\n    \r\n      \r\n    \r\n    // **************************** //\r\n    // *     Constant Getters     * //\r\n    // **************************** //\r\n    \r\n    function votingRightsOf(address _owner) constant returns (uint256 result) {\r\n        result = votingRights[_owner];\r\n    }\r\n    \r\n    function getPreferedQtySold() constant returns (uint result){\r\n        return preferedQtySold;\r\n    }\r\n    \r\n    function setVirtualExchange(address virtualExchangeAddr){\r\n        virtualExchangeAddress = virtualExchangeAddr;\r\n    }\r\n\r\n    function getHKGOwned() constant returns (uint result){\r\n        return hackerGold.balanceOf(this);\r\n    }\r\n    \r\n    function getEtherValue() constant returns (uint result){\r\n        return this.balance;\r\n    }\r\n    \r\n    function getExecutive() constant returns (address result){\r\n        return executive;\r\n    }\r\n    \r\n    function getHKGPrice() constant returns (uint result){\r\n        return hkgPrice;\r\n    }\r\n\r\n    function getEtherPrice() constant returns (uint result){\r\n        return etherPrice;\r\n    }\r\n    \r\n    function getDSTName() constant returns(string result){\r\n        return name;\r\n    }    \r\n    \r\n    function getDSTNameBytes() constant returns(bytes32 result){\r\n        return convert(name);\r\n    }    \r\n\r\n    function getDSTSymbol() constant returns(string result){\r\n        return symbol;\r\n    }    \r\n    \r\n    function getDSTSymbolBytes() constant returns(bytes32 result){\r\n        return convert(symbol);\r\n    }    \r\n\r\n    function getAddress() constant returns (address result) {\r\n        return this;\r\n    }\r\n    \r\n    function getTotalSupply() constant returns (uint result) {\r\n        return totalSupply;\r\n    } \r\n        \r\n    function getCollectedEther() constant returns (uint results) {        \r\n        return collectedEther;\r\n    }\r\n    \r\n    function getCounterProposals() constant returns (uint result){\r\n        return counterProposals;\r\n    }\r\n        \r\n    function getProposalIdByIndex(uint i) constant returns (bytes32 result){\r\n        return listProposals[i].id;\r\n    }    \r\n\r\n    function getProposalObjectionByIndex(uint i) constant returns (uint result){\r\n        return listProposals[i].votesObjecting;\r\n    }\r\n\r\n    function getProposalValueByIndex(uint i) constant returns (uint result){\r\n        return listProposals[i].value;\r\n    }                  \r\n    \r\n    function getCurrentImpeachmentUrlDetails() constant returns (string result){\r\n        return lastImpeachmentProposal.urlDetails;\r\n    }\r\n    \r\n    \r\n    function getCurrentImpeachmentVotesSupporting() constant returns (uint result){\r\n        return lastImpeachmentProposal.votesSupporting;\r\n    }\r\n    \r\n    function convert(string key) returns (bytes32 ret) {\r\n            if (bytes(key).length > 32) {\r\n                throw;\r\n            }      \r\n\r\n            assembly {\r\n                ret := mload(add(key, 32))\r\n            }\r\n    }    \r\n    \r\n    \r\n    \r\n    // ********************* //\r\n    // *     Modifiers     * //\r\n    // ********************* //    \r\n \r\n    modifier onlyBeforeEnd() { if (now  >=  eventInfo.getEventEnd()) throw; _; }\r\n    modifier onlyAfterEnd()  { if (now  <   eventInfo.getEventEnd()) throw; _; }\r\n    \r\n    modifier onlyAfterTradingStart()  { if (now  < eventInfo.getTradingStart()) throw; _; }\r\n    \r\n    modifier onlyExecutive()     { if (msg.sender != executive) throw; _; }\r\n                                       \r\n    modifier onlyIfAbleToIssueTokens()  { if (!ableToIssueTokens) throw; _; } \r\n    \r\n\r\n    // ****************** //\r\n    // *     Events     * //\r\n    // ****************** //        \r\n\r\n    \r\n    event PriceHKGChange(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply);\r\n    event BuyForHKGTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneHKG, uint tokensAmount);\r\n    event BuyForEtherTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneEther, uint tokensAmount);\r\n\r\n    event DstTokensIssued(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply, uint qtyToEmit);\r\n    \r\n    event ProposalRequestSubmitted(bytes32 id, uint value, uint timeEnds, string url, address sender);\r\n    \r\n    event EtherRedeemAccepted(address sender, uint value);\r\n    \r\n    event ObjectedVote(bytes32 id, address voter, uint votes);\r\n    \r\n    event ImpeachmentProposed(address submitter, string urlDetails, uint votindEndTS, address newExecutive);\r\n    event ImpeachmentSupport(address supportter, uint votes);\r\n    \r\n    event ImpeachmentAccepted(address newExecutive);\r\n\r\n    event NewEtherPrice(uint newQtyForOneEther);\r\n    event DisableTokenIssuance();\r\n    \r\n    event BurnedAllRemainedTokens();\r\n    \r\n}\r\n\r\n\r\n \r\n\r\n/**\r\n *  VirtualExchange -  The exchange is a trading system used\r\n *                     on hack.ether.camp hackathon event to \r\n *                     support trading a DST tokens for HKG. \r\n *                    \r\n */\r\ncontract VirtualExchange{\r\n\r\n    address owner;  \r\n    EventInfo eventInfo;\r\n \r\n    mapping (bytes32 => address) dstListed;\r\n    \r\n    HackerGold hackerGold;\r\n    \r\n    function VirtualExchange(address hackerGoldAddr, address eventInfoAddr){\r\n    \r\n        owner = msg.sender;\r\n        hackerGold = HackerGold(hackerGoldAddr);\r\n        eventInfo  = EventInfo(eventInfoAddr);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * enlist - enlisting one decentralized startup team to \r\n     *          the hack event virtual exchange, making the \r\n     *          DST initated tokens available for acquisition.\r\n     * \r\n     *  @param dstAddress - address of the DSTContract \r\n     * \r\n     */ \r\n    function enlist(address dstAddress) onlyBeforeEnd {\r\n\r\n        DSTContract dstContract = DSTContract(dstAddress);\r\n\r\n        bytes32 symbolBytes = dstContract.getDSTSymbolBytes();\r\n\r\n        /* Don't enlist 2 with the same name */\r\n        if (isExistByBytes(symbolBytes)) throw;\r\n\r\n        // Only owner of the DST can deploy the DST \r\n        if (dstContract.getExecutive() != msg.sender) throw;\r\n\r\n        // All good enlist the company\r\n        dstListed[symbolBytes] = dstAddress;\r\n        \r\n        // Indicate to DST which Virtual Exchange is enlisted\r\n        dstContract.setVirtualExchange(address(this));\r\n        \r\n        // rise Enlisted event\r\n        Enlisted(dstAddress);\r\n    }\r\n    \r\n   \r\n\r\n    /**\r\n     *\r\n     * buy - on the hackathon timeframe that is the function \r\n     *       that will be the way to buy specific tokens for \r\n     *       startup.\r\n     * \r\n     * @param companyNameBytes - the company that is enlisted on the exchange \r\n     *                           and the tokens are available\r\n     * \r\n     * @param hkg - the ammount of hkg to spend for aquastion \r\n     *\r\n     */\r\n    function buy(bytes32 companyNameBytes, uint hkg) onlyBeforeEnd\r\n                                               returns (bool success) {\r\n\r\n    \r\n        // check DST exist \r\n        if (!isExistByBytes(companyNameBytes)) throw;\r\n\r\n        // validate availability  \r\n        DSTContract dstContract = DSTContract(dstListed[companyNameBytes]);\r\n        uint tokensQty = hkg * dstContract.getHKGPrice();\r\n\r\n        address veAddress = address(this);        \r\n        \r\n        // ensure that there is HKG balance\r\n        uint valueHKGOwned = hackerGold.balanceOf(msg.sender);        \r\n        if (valueHKGOwned < hkg) throw;        \r\n        \r\n        // ensure that there is HKG token allowed to be spend\r\n        uint valueAvailbeOnExchange = hackerGold.allowance(msg.sender, veAddress);\r\n        if (valueAvailbeOnExchange < hkg) throw;\r\n\r\n        // ensure there is DST tokens for sale\r\n        uint dstTokens = dstContract.allowance(dstContract, veAddress);\r\n        if (dstTokens < hkg * dstContract.getHKGPrice()) throw;    \r\n                        \r\n        // Transfer HKG to Virtual Exchange account  \r\n        hackerGold.transferFrom(msg.sender, veAddress, hkg);\r\n\r\n        // Transfer to dstCotract ownership\r\n        hackerGold.transfer(dstContract.getAddress(), hkg);         \r\n        \r\n        // Call DST to transfer tokens \r\n        dstContract.buyForHackerGold(hkg);            \r\n    }\r\n        \r\n\r\n    // **************************** //\r\n    // *     Constant Getters     * //\r\n    // **************************** //        \r\n    \r\n\r\n    function isExistByBytes(bytes32 companyNameBytes) constant returns (bool result) {\r\n            \r\n        if (dstListed[companyNameBytes] == 0x0) \r\n            return false;\r\n        else \r\n            return true;                  \r\n    }\r\n    \r\n    function getEventStart() constant eventInfoSet returns (uint result){\r\n        return eventInfo.getEventStart();\r\n    }\r\n\r\n    function getEventEnd() constant eventInfoSet returns (uint result){\r\n        return eventInfo.getEventEnd();\r\n    }\r\n    \r\n    function getNow() constant returns (uint result){\r\n        return now;\r\n    }\r\n    \r\n\r\n\r\n    // ********************* //\r\n    // *     Modifiers     * //\r\n    // ********************* //        \r\n    \r\n\r\n    modifier onlyOwner()    { if (msg.sender != owner)        throw; _; }\r\n    modifier eventInfoSet() { if (eventInfo  == address(0))   throw; _; }\r\n    \r\n    modifier onlyBeforeEnd() { if (now  >= eventInfo.getEventEnd()) throw; _; }\r\n    modifier onlyAfterEnd()  { if (now  <  eventInfo.getEventEnd()) throw; _; }\r\n    \r\n\r\n    // ****************** //\r\n    // *     Events     * //\r\n    // ****************** //        \r\n    \r\n    event Enlisted(address indexed dstContract);\r\n    \r\n    \r\n}", 
  "balance": "0 Ether", 
  "name": "VirtualExchange", 
  "transactions": "524", 
  "address": "0x78a5d3074256359d9f9b7ad3cda25436b83e2f6d"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "2<b>.</b>25779608320512409 Ether", 
  "name": "Wallet", 
  "transactions": "521", 
  "address": "0x96741f3ed4df6f16e6fdbbeb6c11bc79cb42aeff"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "0 Ether", 
  "name": "Wallet", 
  "transactions": "520", 
  "address": "0x301eae0d889e3b5a0db9d24c5ff82415bdf30b11"
 }, 
 {
  "source": "pragma solidity ^ 0.4 .0;\r\n\r\n/*\r\n * Token - is a smart contract interface \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract TokenInterface {\r\n\r\n\r\n        // total amount of tokens\r\n        uint totalSupply;\r\n\r\n\r\n        /**\r\n         *\r\n         * balanceOf() - constant function check concrete tokens balance  \r\n         *\r\n         *  @param owner - account owner\r\n         *  \r\n         *  @return the value of balance \r\n         */\r\n        function balanceOf(address owner) constant returns(uint256 balance);\r\n\r\n        function transfer(address to, uint256 value) returns(bool success);\r\n\r\n        function transferFrom(address from, address to, uint256 value) returns(bool success);\r\n\r\n        /**\r\n         *\r\n         * approve() - function approves to a person to spend some tokens from \r\n         *           owner balance. \r\n         *\r\n         *  @param spender - person whom this right been granted.\r\n         *  @param value   - value to spend.\r\n         * \r\n         *  @return true in case of succes, otherwise failure\r\n         * \r\n         */\r\n        function approve(address spender, uint256 value) returns(bool success);\r\n\r\n        /**\r\n         *\r\n         * allowance() - constant function to check how much is \r\n         *               permitted to spend to 3rd person from owner balance\r\n         *\r\n         *  @param owner   - owner of the balance\r\n         *  @param spender - permitted to spend from this balance person \r\n         *  \r\n         *  @return - remaining right to spend \r\n         * \r\n         */\r\n        function allowance(address owner, address spender) constant returns(uint256 remaining);\r\n\r\n        // events notifications\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\npragma solidity ^ 0.4 .2;\r\n\r\n/*\r\n * StandardToken - is a smart contract  \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: \r\n *         https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is TokenInterface {\r\n\r\n\r\n        // token ownership\r\n        mapping(address => uint256) balances;\r\n\r\n        // spending permision management\r\n        mapping(address => mapping(address => uint256)) allowed;\r\n\r\n\r\n\r\n        function StandardToken() {}\r\n\r\n\r\n        /**\r\n         * transfer() - transfer tokens from msg.sender balance \r\n         *              to requested account\r\n         *\r\n         *  @param to    - target address to transfer tokens\r\n         *  @param value - ammount of tokens to transfer\r\n         *\r\n         *  @return - success / failure of the transaction\r\n         */\r\n        function transfer(address to, uint256 value) returns(bool success) {\r\n\r\n\r\n                if (balances[msg.sender] >= value && value > 0) {\r\n\r\n                        // do actual tokens transfer       \r\n                        balances[msg.sender] -= value;\r\n                        balances[to] += value;\r\n\r\n                        // rise the Transfer event\r\n                        Transfer(msg.sender, to, value);\r\n                        return true;\r\n                } else {\r\n\r\n                        return false;\r\n                }\r\n        }\r\n\r\n\r\n\r\n\r\n        /**\r\n         * transferFrom() - used to move allowed funds from other owner\r\n         *                  account \r\n         *\r\n         *  @param from  - move funds from account\r\n         *  @param to    - move funds to account\r\n         *  @param value - move the value \r\n         *\r\n         *  @return - return true on success false otherwise \r\n         */\r\n        function transferFrom(address from, address to, uint256 value) returns(bool success) {\r\n\r\n                if (balances[from] >= value &&\r\n                        allowed[from][msg.sender] >= value &&\r\n                        value > 0) {\r\n\r\n\r\n                        // do the actual transfer\r\n                        balances[from] -= value;\r\n                        balances[to] += value;\r\n\r\n\r\n                        // addjust the permision, after part of \r\n                        // permited to spend value was used\r\n                        allowed[from][msg.sender] -= value;\r\n\r\n                        // rise the Transfer event\r\n                        Transfer(from, to, value);\r\n                        return true;\r\n                } else {\r\n\r\n                        return false;\r\n                }\r\n        }\r\n\r\n\r\n\r\n\r\n        /**\r\n         *\r\n         * balanceOf() - constant function check concrete tokens balance  \r\n         *\r\n         *  @param owner - account owner\r\n         *  \r\n         *  @return the value of balance \r\n         */\r\n        function balanceOf(address owner) constant returns(uint256 balance) {\r\n                return balances[owner];\r\n        }\r\n\r\n\r\n\r\n        /**\r\n         *\r\n         * approve() - function approves to a person to spend some tokens from \r\n         *           owner balance. \r\n         *\r\n         *  @param spender - person whom this right been granted.\r\n         *  @param value   - value to spend.\r\n         * \r\n         *  @return true in case of succes, otherwise failure\r\n         * \r\n         */\r\n        function approve(address spender, uint256 value) returns(bool success) {\r\n\r\n\r\n\r\n                // now spender can use balance in \r\n                // ammount of value from owner balance\r\n                allowed[msg.sender][spender] = value;\r\n\r\n                // rise event about the transaction\r\n                Approval(msg.sender, spender, value);\r\n\r\n                return true;\r\n        }\r\n\r\n        /**\r\n         *\r\n         * allowance() - constant function to check how mouch is \r\n         *               permited to spend to 3rd person from owner balance\r\n         *\r\n         *  @param owner   - owner of the balance\r\n         *  @param spender - permited to spend from this balance person \r\n         *  \r\n         *  @return - remaining right to spend \r\n         * \r\n         */\r\n        function allowance(address owner, address spender) constant returns(uint256 remaining) {\r\n                return allowed[owner][spender];\r\n        }\r\n\r\n}\r\n\r\n\r\npragma solidity ^ 0.4 .0;\r\n\r\n/**\r\n *\r\n * @title Hacker Gold\r\n * \r\n * The official token powering the hack.ether.camp virtual accelerator.\r\n * This is the only way to acquire tokens from startups during the event.\r\n *\r\n * Whitepaper https://hack.ether.camp/whitepaper\r\n *\r\n */\r\ncontract HackerGold is StandardToken {\r\n\r\n        // Name of the token    \r\n        string public name = \"HackerGold\";\r\n\r\n        // Decimal places\r\n        uint8 public decimals = 3;\r\n        // Token abbreviation        \r\n        string public symbol = \"HKG\";\r\n\r\n        // 1 ether = 200 hkg\r\n        uint BASE_PRICE = 200;\r\n        // 1 ether = 150 hkg\r\n        uint MID_PRICE = 150;\r\n        // 1 ether = 100 hkg\r\n        uint FIN_PRICE = 100;\r\n        // Safety cap\r\n        uint SAFETY_LIMIT = 4000000 ether;\r\n        // Zeros after the point\r\n        uint DECIMAL_ZEROS = 1000;\r\n\r\n        // Total value in wei\r\n        uint totalValue;\r\n\r\n        // Address of multisig wallet holding ether from sale\r\n        address wallet;\r\n\r\n        // Structure of sale increase milestones\r\n        struct milestones_struct {\r\n                uint p1;\r\n                uint p2;\r\n                uint p3;\r\n                uint p4;\r\n                uint p5;\r\n                uint p6;\r\n        }\r\n        // Milestones instance\r\n        milestones_struct milestones;\r\n\r\n        /**\r\n         * Constructor of the contract.\r\n         * \r\n         * Passes address of the account holding the value.\r\n         * HackerGold contract itself does not hold any value\r\n         * \r\n         * @param multisig address of MultiSig wallet which will hold the value\r\n         */\r\n        function HackerGold(address multisig) {\r\n\r\n                wallet = multisig;\r\n\r\n                // set time periods for sale\r\n                milestones = milestones_struct(\r\n\r\n                        1476972000, // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n                        1478181600, // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n                        1479391200, // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                        //                                Hackathon Starts\r\n                        1480600800, // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n                        1481810400, // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n                        1482415200 // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n                );\r\n\r\n                // assign recovery balance\r\n                totalSupply = 16110893000;\r\n                balances[0x342e62732b76875da9305083ea8ae63125a4e667] = 16110893000;\r\n                totalValue = 85362 ether;\r\n        }\r\n\r\n\r\n        /**\r\n         * Fallback function: called on ether sent.\r\n         * \r\n         * It calls to createHKG function with msg.sender \r\n         * as a value for holder argument\r\n         */\r\n        function() payable {\r\n                createHKG(msg.sender);\r\n        }\r\n\r\n        /**\r\n         * Creates HKG tokens.\r\n         * \r\n         * Runs sanity checks including safety cap\r\n         * Then calculates current price by getPrice() function, creates HKG tokens\r\n         * Finally sends a value of transaction to the wallet\r\n         * \r\n         * Note: due to lack of floating point types in Solidity,\r\n         * contract assumes that last 3 digits in tokens amount are stood after the point.\r\n         * It means that if stored HKG balance is 100000, then its real value is 100 HKG\r\n         * \r\n         * @param holder token holder\r\n         */\r\n        function createHKG(address holder) payable {\r\n\r\n                if (now < milestones.p1) throw;\r\n                if (now >= milestones.p6) throw;\r\n                if (msg.value == 0) throw;\r\n\r\n                // safety cap\r\n                if (getTotalValue() + msg.value > SAFETY_LIMIT) throw;\r\n\r\n                uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n                totalSupply += tokens;\r\n                balances[holder] += tokens;\r\n                totalValue += msg.value;\r\n\r\n                if (!wallet.send(msg.value)) throw;\r\n        }\r\n\r\n        /**\r\n         * Denotes complete price structure during the sale.\r\n         *\r\n         * @return HKG amount per 1 ETH for the current moment in time\r\n         */\r\n        function getPrice() constant returns(uint result) {\r\n\r\n                if (now < milestones.p1) return 0;\r\n\r\n                if (now >= milestones.p1 && now < milestones.p2) {\r\n\r\n                        return BASE_PRICE;\r\n                }\r\n\r\n                if (now >= milestones.p2 && now < milestones.p3) {\r\n\r\n                        uint days_in = 1 + (now - milestones.p2) / 1 days;\r\n                        return BASE_PRICE - days_in * 25 / 7; // daily decrease 3.5\r\n                }\r\n\r\n                if (now >= milestones.p3 && now < milestones.p4) {\r\n\r\n                        return MID_PRICE;\r\n                }\r\n\r\n                if (now >= milestones.p4 && now < milestones.p5) {\r\n\r\n                        days_in = 1 + (now - milestones.p4) / 1 days;\r\n                        return MID_PRICE - days_in * 25 / 7; // daily decrease 3.5\r\n                }\r\n\r\n                if (now >= milestones.p5 && now < milestones.p6) {\r\n\r\n                        return FIN_PRICE;\r\n                }\r\n\r\n                if (now >= milestones.p6) {\r\n\r\n                        return 0;\r\n                }\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns total stored HKG amount.\r\n         * \r\n         * Contract assumes that last 3 digits of this value are behind the decimal place. i.e. 10001 is 10.001\r\n         * Thus, result of this function should be divided by 1000 to get HKG value\r\n         * \r\n         * @return result stored HKG amount\r\n         */\r\n        function getTotalSupply() constant returns(uint result) {\r\n                return totalSupply;\r\n        }\r\n\r\n        /**\r\n         * It is used for test purposes.\r\n         * \r\n         * Returns the result of 'now' statement of Solidity language\r\n         * \r\n         * @return unix timestamp for current moment in time\r\n         */\r\n        function getNow() constant returns(uint result) {\r\n                return now;\r\n        }\r\n\r\n        /**\r\n         * Returns total value passed through the contract\r\n         * \r\n         * @return result total value in wei\r\n         */\r\n        function getTotalValue() constant returns(uint result) {\r\n                return totalValue;\r\n        }\r\n}", 
  "balance": "0 Ether", 
  "name": "HackerGold", 
  "transactions": "519", 
  "address": "0xa62bdee2f277c2e2c0f46cba96879b263796ee1c"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "89<b>.</b>144240717362351894 Ether", 
  "name": "Wallet", 
  "transactions": "503", 
  "address": "0x9662958c46e481c020ddaf6ba06249bc1263b59f"
 }, 
 {
  "source": "contract Government {\r\n\r\n    // Global Variables\r\n    uint32 public lastCreditorPayedOut;\r\n    uint public lastTimeOfNewCredit;\r\n    uint public profitFromCrash;\r\n    address[] public creditorAddresses;\r\n    uint[] public creditorAmounts;\r\n    address public corruptElite;\r\n    mapping (address => uint) buddies;\r\n    uint constant TWELVE_HOURS = 43200;\r\n    uint8 public round;\r\n\r\n    function Government() {\r\n        // The corrupt elite establishes a new government\r\n        // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\r\n        profitFromCrash = msg.value;\r\n        corruptElite = msg.sender;\r\n        lastTimeOfNewCredit = block.timestamp;\r\n    }\r\n\r\n    function lendGovernmentMoney(address buddy) returns (bool) {\r\n        uint amount = msg.value;\r\n        // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\r\n        // 12h are on average = 60*60*12/12.5 = 3456\r\n        if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\r\n            // Return money to sender\r\n            msg.sender.send(amount);\r\n            // Sends all contract money to the last creditor\r\n            creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\r\n            corruptElite.send(this.balance);\r\n            // Reset contract state\r\n            lastCreditorPayedOut = 0;\r\n            lastTimeOfNewCredit = block.timestamp;\r\n            profitFromCrash = 0;\r\n            creditorAddresses = new address[](0);\r\n            creditorAmounts = new uint[](0);\r\n            round += 1;\r\n            return false;\r\n        }\r\n        else {\r\n            // the system needs to collect at least 1% of the profit from a crash to stay alive\r\n            if (amount >= 10 ** 18) {\r\n                // the System has received fresh money, it will survive at leat 12h more\r\n                lastTimeOfNewCredit = block.timestamp;\r\n                // register the new creditor and his amount with 10% interest rate\r\n                creditorAddresses.push(msg.sender);\r\n                creditorAmounts.push(amount * 110 / 100);\r\n                // now the money is distributed\r\n                // first the corrupt elite grabs 5% - thieves!\r\n                corruptElite.send(amount * 5/100);\r\n                // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\r\n                if (profitFromCrash < 10000 * 10**18) {\r\n                    profitFromCrash += amount * 5/100;\r\n                }\r\n                // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\r\n                // Make a deal with him.\r\n                if(buddies[buddy] >= amount) {\r\n                    buddy.send(amount * 5/100);\r\n                }\r\n                buddies[msg.sender] += amount * 110 / 100;\r\n                // 90% of the money will be used to pay out old creditors\r\n                if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\r\n                    creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\r\n                    buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\r\n                    lastCreditorPayedOut += 1;\r\n                }\r\n                return true;\r\n            }\r\n            else {\r\n                msg.sender.send(amount);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // fallback function\r\n    function() {\r\n        lendGovernmentMoney(0);\r\n    }\r\n\r\n    function totalDebt() returns (uint debt) {\r\n        for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\r\n            debt += creditorAmounts[i];\r\n        }\r\n    }\r\n\r\n    function totalPayedOut() returns (uint payout) {\r\n        for(uint i=0; i<lastCreditorPayedOut; i++){\r\n            payout += creditorAmounts[i];\r\n        }\r\n    }\r\n\r\n    // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\r\n    function investInTheSystem() {\r\n        profitFromCrash += msg.value;\r\n    }\r\n\r\n    // From time to time the corrupt elite inherits it's power to the next generation\r\n    function inheritToNextGeneration(address nextGeneration) {\r\n        if (msg.sender == corruptElite) {\r\n            corruptElite = nextGeneration;\r\n        }\r\n    }\r\n\r\n    function getCreditorAddresses() returns (address[]) {\r\n        return creditorAddresses;\r\n    }\r\n\r\n    function getCreditorAmounts() returns (uint[]) {\r\n        return creditorAmounts;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "Government", 
  "transactions": "501", 
  "address": "0xf45717552f12ef7cb65e95476f217ea008167ae3"
 }, 
 {
  "source": "// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        address oraclizeAddr = OAR.getAddress();\r\n        if (oraclizeAddr == 0){\r\n            oraclize_setNetwork(networkID_auto);\r\n            oraclizeAddr = OAR.getAddress();\r\n        }\r\n        oraclize = OraclizeI(oraclizeAddr);\r\n        _\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string self) internal returns (slice) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (self & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (self & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (self & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (self & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-termintaed utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal returns (slice ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice self) internal returns (slice) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /**\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice self) internal returns (string) {\r\n        var ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice self) internal returns (uint) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        var ptr = self._ptr - 31;\r\n        var end = ptr + self._len;\r\n        for (uint len = 0; ptr < end; len++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice self) internal returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice self, slice other) internal returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        var selfptr = self._ptr;\r\n        var otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                var diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice self, slice other) internal returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice self, slice rune) internal returns (slice) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint len;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            len = 1;\r\n        } else if(b < 0xE0) {\r\n            len = 2;\r\n        } else if(b < 0xF0) {\r\n            len = 3;\r\n        } else {\r\n            len = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (len > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += len;\r\n        self._len -= len;\r\n        rune._len = len;\r\n        return rune;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice self) internal returns (slice ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice self) internal returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint len;\r\n        uint div = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        var b = word / div;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            len = 1;\r\n        } else if(b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            len = 2;\r\n        } else if(b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            len = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            len = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (len > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < len; i++) {\r\n            div = div / 256;\r\n            b = (word / div) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice self) internal returns (bytes32 ret) {\r\n        assembly {\r\n            ret := sha3(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice self, slice needle) internal returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let len := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(sha3(selfptr, len), sha3(needleptr, len))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /**\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice self, slice needle) internal returns (slice) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let len := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(sha3(selfptr, len), sha3(needleptr, len))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice self, slice needle) internal returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        var selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let len := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(sha3(selfptr, len), sha3(needleptr, len))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /**\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice self, slice needle) internal returns (slice) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        var selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let len := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(sha3(selfptr, len), sha3(needleptr, len))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\r\n        uint ptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                // Optimized assembly for 68 gas per byte on short strings\r\n                assembly {\r\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\r\n                    let needledata := and(mload(needleptr), mask)\r\n                    let end := add(selfptr, sub(selflen, needlelen))\r\n                    ptr := selfptr\r\n                    loop:\r\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\r\n                    ptr := add(ptr, 1)\r\n                    jumpi(loop, lt(sub(ptr, 1), end))\r\n                    ptr := add(selfptr, selflen)\r\n                    exit:\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := sha3(needleptr, needlelen) }\r\n                ptr = selfptr;\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := sha3(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                // Optimized assembly for 69 gas per byte on short strings\r\n                assembly {\r\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\r\n                    let needledata := and(mload(needleptr), mask)\r\n                    ptr := add(selfptr, sub(selflen, needlelen))\r\n                    loop:\r\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\r\n                    ptr := sub(ptr, 1)\r\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\r\n                    ptr := selfptr\r\n                    jump(exit)\r\n                    ret:\r\n                    ptr := add(ptr, needlelen)\r\n                    exit:\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := sha3(needleptr, needlelen) }\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := sha3(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice self, slice needle) internal returns (slice) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice self, slice needle) internal returns (slice) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /**\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice self, slice needle, slice token) internal returns (slice) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice self, slice needle) internal returns (slice token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /**\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice self, slice needle, slice token) internal returns (slice) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice self, slice needle) internal returns (slice token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /**\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice self, slice needle) internal returns (uint count) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            count++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice self, slice needle) internal returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice self, slice other) internal returns (string) {\r\n        var ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice self, slice[] parts) internal returns (string) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint len = self._len * (parts.length - 1);\r\n        for(uint i = 0; i < parts.length; i++)\r\n            len += parts[i]._len;\r\n\r\n        var ret = new string(len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for(i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\n\r\ncontract mortal {\r\n    address owner;\r\n\r\n    function mortal() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function kill() internal{\r\n        suicide(owner);\r\n    }\r\n}\r\n\r\ncontract Pray4Prey is mortal, usingOraclize {\r\n\tusing strings for *;\r\n\t\r\n    /**the balances in wei being held by each player */\r\n    mapping(address => uint128) winBalances;\r\n    /**list of all players*/\r\n    address[] public players;\r\n    /** the number of players (may be != players.length, since players can leave the game)*/\r\n    uint16 public numPlayers;\r\n    \r\n    /** animals[0] -> list of the owners of the animals of type 0, animals[1] animals type 1 etc (using a mapping instead of a multidimensional array for lower gas consumptions) */\r\n    mapping(uint8 => address[]) animals;\r\n    /** the cost of each animal type */\r\n    uint128[] public costs;\r\n    /** the value of each animal type (cost - fee), so it's not necessary to compute it each time*/\r\n    uint128[] public values;\r\n    /** internal  array of the probability factors, so it's not necessary to compute it each time*/\r\n    uint8[] probabilityFactors;\r\n    /** the fee to be paid each time an animal is bought in percent*/\r\n    uint8[] public fees;\r\n\r\n    /** the indices of the animals per type per player */\r\n   // mapping(address => mapping(uint8 => uint16[])) animalIndices; \r\n  // mapping(address => mapping(uint8 => uint16)) numAnimalsXPlayerXType;\r\n    \r\n    /** total number of animals in the game \r\n    (!=sum of the lengths of the prey animals arrays, since those arrays contain holes) */\r\n    uint16 public numAnimals;\r\n    /** The maximum of animals allowed in the game */\r\n    uint16 public maxAnimals;\r\n    /** number of animals per player */\r\n    mapping(address => uint8) numAnimalsXPlayer;\r\n    /** number of animals per type */\r\n    mapping(uint8 => uint16) numAnimalsXType;\r\n\r\n    \r\n    /** the query string getting the random numbers from oraclize**/\r\n    string randomQuery;\r\n    /** the timestamp of the next attack **/\r\n    uint public nextAttackTimestamp;\r\n    /** gas provided for oraclize callback (attack)**/\r\n    uint32 public oraclizeGas;\r\n    /** the id of the next oraclize callback*/\r\n    bytes32 nextAttackId;\r\n    \r\n    \r\n    /** is fired when new animals are purchased (who bought how many animals of which type?) */\r\n    event newPurchase(address player, uint8 animalType, uint8 amount);\r\n    /** is fired when a player leaves the game */\r\n    event newExit(address player, uint256 totalBalance);\r\n    /** is fired when an attack occures*/\r\n    event newAttack();\r\n    \r\n    \r\n    /** expected parameters: the costs per animal type and the game fee in percent \r\n    *   assumes that the cheapest animal is stored in [0]\r\n    */\r\n    function Pray4Prey(uint128[] animalCosts, uint8[] gameFees) {\r\n        costs = animalCosts;\r\n        fees = gameFees;\r\n        for(uint8 i = 0; i< costs.length; i++){\r\n            values.push(costs[i]-costs[i]/100*fees[i]);\r\n            probabilityFactors.push(uint8(costs[costs.length-i-1]/costs[0]));\r\n        }\r\n        maxAnimals = 3000;\r\n        randomQuery = \"https://www.random.org/integers/?num=10&min=0&max=10000&col=1&base=10&format=plain&rnd=new\";\r\n        oraclizeGas=550000;\r\n    }\r\n    \r\n     /** The fallback function runs whenever someone sends ether\r\n        Depending of the value of the transaction the sender is either granted a prey or \r\n        the transaction is discarded and no ether accepted\r\n        In the first case fees have to be paid*/\r\n     function (){\r\n         for(uint8 i = 0; i < costs.length; i++)\r\n            if(msg.value==costs[i])\r\n                addAnimals(i);\r\n                \r\n        if(msg.value==1000000000000000)\r\n            exit();\r\n        else\r\n            throw;\r\n            \r\n     }\r\n     \r\n     /** buy animals of a given type \r\n     *  as many animals as possible are bought with msg.value, rest is added to the winBalance of the sender\r\n     */\r\n     function addAnimals(uint8 animalType){\r\n        uint8 amount = uint8(msg.value/costs[animalType]);\r\n        if(animalType >= costs.length || msg.value<costs[animalType] || numAnimalsXPlayer[msg.sender]+amount>50 || numAnimals+amount>=maxAnimals) throw;\r\n        //if type exists, enough ether was transferred, the player doesn't posess to many animals already (else exit is too costly) and there are less than 10000 animals in the game\r\n        if(numAnimalsXPlayer[msg.sender]==0)//new player\r\n            addPlayer();\r\n        for(uint8 j = 0; j<amount; j++){\r\n            addAnimal(animalType);\r\n        }\r\n        numAnimals+=amount;\r\n        numAnimalsXPlayer[msg.sender]+=amount;\r\n        //numAnimalsXPlayerXType[msg.sender][animalType]+=amount;\r\n        winBalances[msg.sender]+=uint128(msg.value*(100-fees[animalType])/100);\r\n        newPurchase(msg.sender, animalType, j);\r\n        \r\n     }\r\n     \r\n     /**\r\n     *  adds a single animal of the given type\r\n     */\r\n     function addAnimal(uint8 animalType) internal{\r\n        if(numAnimalsXType[animalType]<animals[animalType].length)\r\n            animals[animalType][numAnimalsXType[animalType]]=msg.sender;\r\n        else\r\n            animals[animalType].push(msg.sender);\r\n        numAnimalsXType[animalType]++;\r\n     }\r\n     \r\n  \r\n     \r\n     /**\r\n      * adds an address to the list of players\r\n      * before calling you need to check if the address is already in the game\r\n      * */\r\n     function addPlayer() internal{\r\n        if(numPlayers<players.length)\r\n            players[numPlayers]=msg.sender;\r\n        else\r\n            players.push(msg.sender);\r\n        numPlayers++;\r\n     }\r\n     \r\n     /**\r\n      * removes a given address from the player array\r\n      * */\r\n     function deletePlayer(address playerAddress) internal{\r\n         for(uint16 i  = 0; i < numPlayers; i++)\r\n             if(players[i]==playerAddress){\r\n                numPlayers--;\r\n                players[i]=players[numPlayers];\r\n                delete players[numPlayers];\r\n                return;\r\n             }\r\n     }\r\n     \r\n     \r\n     /** leave the game\r\n      * pays out the sender's winBalance and removes him and his animals from the game\r\n      * */\r\n    function exit(){\r\n    \tcleanUp(msg.sender);//delete the animals\r\n        newExit(msg.sender, winBalances[msg.sender]); //fire the event to notify the client\r\n        if(!payout(msg.sender)) throw;\r\n        delete winBalances[msg.sender];\r\n        deletePlayer(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Deletes the animals of a given player\r\n     * */\r\n    function cleanUp(address playerAddress) internal{\r\n    \tfor(uint8 animalType = 0;  animalType< costs.length;  animalType++){//costs.length == num animal types\r\n    \t    if(numAnimalsXType[animalType]>0){\r\n                for(uint16 i = 0; i < numAnimalsXType[animalType]; i++){\r\n                    if(animals[animalType][i] == playerAddress){\r\n                       replaceAnimal(animalType,i, true);\r\n                    }\r\n                }\r\n    \t    }\r\n        }\r\n        numAnimals-=numAnimalsXPlayer[playerAddress];\r\n        delete numAnimalsXPlayer[playerAddress];\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Replaces the animal at the given index with the last animal in the array\r\n     * */\r\n    function replaceAnimal(uint8 animalType, uint16 index, bool exit) internal{\r\n        if(exit){//delete all animals at the end of the array that belong to the same player\r\n            while(animals[animalType][numAnimalsXType[animalType]-1]==animals[animalType][index]){\r\n                numAnimalsXType[animalType]--;\r\n                delete animals[animalType][numAnimalsXType[animalType]];\r\n                if(numAnimalsXType[animalType]==index)\r\n                    return;\r\n            }\r\n        }\r\n        numAnimalsXType[animalType]--;\r\n\t\tanimals[animalType][index]=animals[animalType][numAnimalsXType[animalType]];\r\n\t\tdelete animals[animalType][numAnimalsXType[animalType]];//actually there's no need for the delete, since the index will not be accessed since it's higher than numAnimalsXType[animalType]\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     * pays out the given player and removes his fishes.\r\n     * amount = winbalance + sum(fishvalues)\r\n     * returns true if payout was successful\r\n     * */\r\n    function payout(address playerAddress) internal returns(bool){\r\n        return playerAddress.send(winBalances[playerAddress]);\r\n    }\r\n\r\n    \r\n    /**\r\n     * manually triggers the attack. cannot be called afterwards, except\r\n     * by the owner if and only if the attack wasn't launched as supposed, signifying\r\n     * an error ocurred during the last invocation of oraclize, or there wasn't enough ether to pay the gas\r\n     * */\r\n    function triggerAttackManually(uint32 inseconds){\r\n        if(!(msg.sender==owner && nextAttackTimestamp < now+300)) throw;\r\n        triggerAttack(inseconds);\r\n    }\r\n    \r\n    /**\r\n     * sends a query to oraclize in order to get random numbers in 'inseconds' seconds\r\n     */\r\n    function triggerAttack(uint32 inseconds) internal{\r\n    \tnextAttackTimestamp = now+inseconds;\r\n    \tnextAttackId = oraclize_query(nextAttackTimestamp, \"URL\", randomQuery, oraclizeGas+6000*numPlayers);\r\n    }\r\n    \r\n    /**\r\n     * The actual predator attack.\r\n     * The predator kills up to 10 animals, but in case there are less than 100 animals in the game up to 10% get eaten.\r\n     * */\r\n    function __callback(bytes32 myid, string result) {\r\n        if (msg.sender != oraclize_cbAddress()||myid!=nextAttackId) throw; // just to be sure the calling address is the Oraclize authorized one and the callback is the expected one\r\n        \r\n        uint16[] memory ranges = new uint16[](costs.length+1);\r\n        ranges[0] = 0;\r\n        for(uint8 animalType = 0; animalType < costs.length; animalType ++){\r\n            ranges[animalType+1] = ranges[animalType]+uint16(probabilityFactors[animalType]*numAnimalsXType[animalType]); \r\n        }     \r\n        uint128 pot;\r\n        uint16 random;        \r\n        uint16 howmany = numAnimals<100?(numAnimals<10?1:numAnimals/10):10;//do not kill more than 10%, but at least one\r\n        uint16[] memory randomNumbers = getNumbersFromString(result,\"\\n\", howmany);\r\n        for(uint8 i = 0; i < howmany; i++){\r\n            random = mapToNewRange(randomNumbers[i], ranges[costs.length]);\r\n            for(animalType = 0; animalType < costs.length; animalType ++)\r\n                if (random < ranges[animalType+1]){\r\n                    pot+= killAnimal(animalType, (random-ranges[animalType])/probabilityFactors[animalType]);\r\n                    break;\r\n                }\r\n        }\r\n        numAnimals-=howmany;\r\n        newAttack();\r\n        if(pot>uint128(oraclizeGas*tx.gasprice))\r\n            distribute(uint128(pot-oraclizeGas*tx.gasprice));//distribute the pot minus the oraclize gas costs\r\n        triggerAttack(timeTillNextAttack());\r\n    }\r\n    \r\n    /**\r\n     * the frequency of the shark attacks depends on the number of animals in the game. \r\n     * many animals -> many shark attacks\r\n     * at least one attack in 24 hours\r\n     * */\r\n    function timeTillNextAttack() constant internal returns(uint32){\r\n        return (86400/(1+numAnimals/100));\r\n    }\r\n    \r\n\r\n    /**\r\n     * kills the animal of the given type at the given index. \r\n     * */\r\n    function killAnimal(uint8 animalType, uint16 index) internal returns(uint128){\r\n        address preyOwner = animals[animalType][index];\r\n\r\n        replaceAnimal(animalType,index,false);\r\n        numAnimalsXPlayer[preyOwner]--;\r\n        \r\n        //numAnimalsXPlayerXType[preyOwner][animalType]--;\r\n        //if the player still owns prey, the value of the animalType1 alone goes into the pot\r\n        if(numAnimalsXPlayer[preyOwner]>0){\r\n        \twinBalances[preyOwner]-=values[animalType];\r\n            return values[animalType];\r\n        }\r\n        //owner does not have anymore prey, his winBlanace goes into the pot\r\n        else{\r\n            uint128 bounty = winBalances[preyOwner];\r\n            delete winBalances[preyOwner];\r\n            deletePlayer(preyOwner);\r\n            return bounty;\r\n        }\r\n\r\n    }\r\n    \r\n    \r\n    /** distributes the given amount among the players depending on the number of fishes they possess*/\r\n    function distribute(uint128 amount) internal{\r\n        uint128 share = amount/numAnimals;\r\n        for(uint16 i = 0; i < numPlayers; i++){\r\n            winBalances[players[i]]+=share*numAnimalsXPlayer[players[i]];\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * allows the owner to collect the accumulated fees\r\n     * sends the given amount to the owner's address if the amount does not exceed the\r\n     * fees (cannot touch the players' balances) minus 100 finney (ensure that oraclize fees can be paid)\r\n     * */\r\n    function collectFees(uint128 amount){\r\n        if(!(msg.sender==owner)) throw;\r\n        uint collectedFees = getFees();\r\n        if(amount + 100 finney < collectedFees){\r\n            if(!owner.send(amount)) throw;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * pays out the players and kills the game.\r\n     * */\r\n    function stop(){\r\n        if(!(msg.sender==owner)) throw;\r\n        for(uint16 i = 0; i< numPlayers; i++){\r\n            payout(players[i]);\r\n        }\r\n        kill();\r\n    }\r\n    \r\n    /**\r\n     * adds a new animal type to the game\r\n     * max. number of animal types: 100\r\n     * the cost may not be lower than costs[0]\r\n     * */\r\n    function addAnimalType(uint128 cost, uint8 fee){\r\n        if(!(msg.sender==owner)||cost<costs[0]||costs.length>=100) throw;\r\n        costs.push(cost);\r\n        fees.push(fee);\r\n        values.push(cost/100*fee);\r\n        probabilityFactors.push(uint8(cost/costs[0]));\r\n    }\r\n    \r\n \r\n   \r\n   /****************** GETTERS *************************/\r\n    \r\n    \r\n    function getWinBalancesOf(address playerAddress) constant returns(uint128){\r\n        return winBalances[playerAddress];\r\n    }\r\n    \r\n    function getAnimals(uint8 animalType) constant returns(address[]){\r\n        return animals[animalType];\r\n    }\r\n    \r\n    function getFees() constant returns(uint){\r\n        uint reserved = 0;\r\n        for(uint16 j = 0; j< numPlayers; j++)\r\n            reserved+=winBalances[players[j]];\r\n        return address(this).balance - reserved;\r\n    }\r\n\r\n    function getNumAnimalsXType(uint8 animalType) constant returns(uint16){\r\n        return numAnimalsXType[animalType];\r\n    }\r\n    \r\n    function getNumAnimalsXPlayer(address playerAddress) constant returns(uint16){\r\n        return numAnimalsXPlayer[playerAddress];\r\n    }\r\n    \r\n   /* function getNumAnimalsXPlayerXType(address playerAddress, uint8 animalType) constant returns(uint16){\r\n        return numAnimalsXPlayerXType[playerAddress][animalType];\r\n    }\r\n    */\r\n    /****************** SETTERS *************************/\r\n    \r\n    function setOraclizeGas(uint32 newGas){\r\n        if(!(msg.sender==owner)) throw;\r\n    \toraclizeGas = newGas;\r\n    }\r\n    \r\n    function setMaxAnimals(uint16 number){\r\n        if(!(msg.sender==owner)) throw;\r\n    \tmaxAnimals = number;\r\n    }\r\n    \r\n    /************* HELPERS ****************/\r\n\r\n    /**\r\n     * maps a given number to the new range (old range 10000)\r\n     * */\r\n    function mapToNewRange(uint number, uint range) constant internal returns (uint16 randomNumber) {\r\n        return uint16(number*range / 10000);\r\n    }\r\n    \r\n    /**\r\n     * converts a string of numbers being separated by a given delimiter into an array of numbers (#howmany) \r\n     */\r\n     function getNumbersFromString(string s, string delimiter, uint16 howmany) constant internal returns(uint16[] numbers){\r\n         strings.slice memory myresult = s.toSlice();\r\n         strings.slice memory delim = delimiter.toSlice();\r\n         numbers = new uint16[](howmany);\r\n         for(uint8 i = 0; i < howmany; i++){\r\n             numbers[i]= uint16(parseInt(myresult.split(delim).toString())); \r\n         }\r\n         return numbers;\r\n     }\r\n    \r\n}", 
  "balance": "0 Ether", 
  "name": "Pray4Prey", 
  "transactions": "490", 
  "address": "0x3fccb426c33b1ae067115390354b968592348d05"
 }, 
 {
  "source": "pragma solidity ^0.4.4;\r\n\r\ncontract PixelSelling {\r\n\r\n    struct Location{\r\n        address owner;\r\n        string image;\r\n        string message;\r\n        bool sale;\r\n        address saleTo;\r\n        uint price;\r\n    }\r\n\r\n    struct Share{\r\n        address owner;\r\n        uint lastCashout;\r\n        bool sale;\r\n        address saleTo;\r\n        uint price;\r\n    }\r\n\r\n    uint public latestprice;\r\n    uint public noShares;\r\n    uint public noSales;\r\n    mapping (address=>uint) public balances;\r\n\r\n    uint emptyLocationProvision;\r\n    uint privSaleProvision;\r\n    uint priceRise;\r\n    address creator;\r\n\r\n    mapping (uint=>Location) public locations;\r\n    mapping (uint=>Share) public shares;\r\n\r\n    uint[] provisions;\r\n\r\n    event Change(uint id, string eventType);\r\n\r\n    modifier isValidLocId(uint id){\r\n        if(!(id>=0 && id<10000))\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    function PixelSelling() {\r\n        creator=msg.sender;\r\n        latestprice=10000000000000000;\r\n        priceRise  =20000000000000000;\r\n        noShares=0;\r\n        noSales=0;\r\n        emptyLocationProvision=90;\r\n        privSaleProvision=9;\r\n    }\r\n\r\n    function(){throw;}\r\n\r\n    function buyEmptyLocation(uint id) isValidLocId(id) payable{\r\n        Location l=locations[id];\r\n        if(l.owner==0x0 && msg.value==latestprice){\r\n            l.owner=msg.sender;\r\n            l.image='';\r\n            l.message='';\r\n\r\n            l.sale=false;\r\n            l.saleTo=0x0;\r\n            l.price=latestprice;\r\n\r\n            shares[id] = Share(msg.sender,noSales,false,0x0,latestprice);\r\n\r\n            if(noShares>0){\r\n                balances[creator]+=(latestprice/100)*(100-emptyLocationProvision);\r\n                creditShareProvision(latestprice, emptyLocationProvision);\r\n            }else{\r\n                balances[creator]+=latestprice;\r\n                provisions.push(0);\r\n                noSales+=1;\r\n            }\r\n\r\n            noShares+=1;\r\n\r\n            latestprice+=priceRise;\r\n\r\n            Change(id,'owner');\r\n        }else{\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function buyImagePriv(uint id) isValidLocId(id) payable{\r\n        Location l=locations[id];\r\n        if(\r\n            l.owner!=0x0 &&\r\n            l.sale==true &&\r\n            (l.saleTo==msg.sender||l.saleTo==0x0) &&\r\n            msg.value==l.price\r\n        ){\r\n            l.image='';\r\n            l.message='';\r\n            l.sale=false;\r\n            l.saleTo=0x0;\r\n\r\n            balances[creator]+=(msg.value/100);\r\n            balances[l.owner]+=(msg.value/100)*(99-privSaleProvision);\r\n\r\n            l.owner=msg.sender;\r\n\r\n            creditShareProvision(msg.value, privSaleProvision);\r\n\r\n            Change(id,'img owner');\r\n        }else{\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function buySharePriv(uint id) isValidLocId(id) payable{\r\n        Share s=shares[id];\r\n\t\tif(\r\n\t\t\ts.owner!=0x0 &&\r\n\t\t\ts.sale==true &&\r\n\t\t\t(s.saleTo==msg.sender||s.saleTo==0x0) &&\r\n\t\t\tmsg.value==s.price\r\n\t\t){\r\n            s.sale=false;\r\n            s.saleTo=0x0;\r\n\r\n            balances[creator]+=(msg.value/100);\r\n            balances[shares[id].owner]+=(msg.value/100)*(99-privSaleProvision);\r\n\r\n            shares[id].owner=msg.sender;\r\n\r\n            creditShareProvision(msg.value, privSaleProvision);\r\n\r\n            Change(id,'share owner');\r\n        }else{\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function setImage(uint id, string img) isValidLocId(id) {\r\n\t\tLocation l=locations[id];\r\n        if(l.owner==msg.sender && bytes(img).length<5001){\r\n            l.image=img;\r\n            Change(id,'image');\r\n        }else{\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function setMessage(uint id, string mssg) isValidLocId(id) {\r\n\t\tLocation l=locations[id];\r\n        if(l.owner==msg.sender && bytes(mssg).length<501){\r\n            l.message=mssg;\r\n            Change(id,'message');\r\n        }else{\r\n\t\t\tthrow;\r\n\t\t}\r\n    }\r\n\r\n    function setSaleImg(uint id, bool setSale, address to, uint p) isValidLocId(id) {\r\n        Location l=locations[id];\r\n\t\tif(l.owner==msg.sender){\r\n            l.sale=setSale;\r\n            l.price=p;\r\n            l.saleTo=to;\r\n            Change(id,'img sale');\r\n        }else{\r\n\t\t\tthrow;\r\n\t\t}\r\n    }\r\n\r\n    function setSaleShare(uint id, bool setSale, address to, uint p) isValidLocId(id) {\r\n        Share s=shares[id];\r\n\t\tif(s.owner==msg.sender){\r\n            s.sale=setSale;\r\n            s.price=p;\r\n            s.saleTo=to;\r\n            Change(id,'share sale');\r\n        }else{\r\n\t\t\tthrow;\r\n\t\t}\r\n    }\r\n\r\n    function creditShareProvision(uint price, uint provision) private {\r\n        provisions.push(provisions[noSales-1]+(((price/100)*provision)/noShares));\r\n        noSales+=1;\r\n    }\r\n\r\n    function getProvisionBalance(uint id) isValidLocId(id) constant returns (uint balance) {\r\n        Share s=shares[id];\r\n        if(s.owner!=0x0){\r\n            return provisions[noSales-1]-provisions[s.lastCashout];\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function collectProvisions(uint id) isValidLocId(id) {\r\n        Share s=shares[id];\r\n        if(s.owner==msg.sender){\r\n            balances[s.owner]+=provisions[noSales-1]-provisions[s.lastCashout];\r\n            s.lastCashout=noSales-1;\r\n        }else{\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function withdrawBalance() {\r\n        if(balances[msg.sender]>0){\r\n            uint amtToWithdraw=balances[msg.sender];\r\n            balances[msg.sender]=0;\r\n            if(!msg.sender.send(amtToWithdraw)) throw;\r\n        }else{\r\n            throw;\r\n        }\r\n    }\r\n}", 
  "balance": "99<b>.</b>318691514311317685 Ether", 
  "name": "PixelSelling", 
  "transactions": "488", 
  "address": "0x709c7134053510fce03b464982eab6e3d89728a5"
 }, 
 {
  "source": "contract HonestDice {\r\n\t\r\n\tevent Bet(address indexed user, uint blocknum, uint256 amount, uint chance);\r\n\tevent Won(address indexed user, uint256 amount, uint chance);\r\n\t\r\n\tstruct Roll {\r\n\t\tuint256 value;\r\n\t\tuint chance;\r\n\t\tuint blocknum;\r\n\t\tbytes32 secretHash;\r\n\t\tbytes32 serverSeed;\r\n\t}\r\n\t\r\n\tuint betsLocked;\r\n\taddress owner;\r\n\taddress feed;\t\t\t\t   \r\n\tuint256 minimumBet = 1 * 1000000000000000000; // 1 Ether\r\n\tuint256 constant maxPayout = 5; // 5% of bankroll\r\n\tuint constant seedCost = 100000000000000000; // This is the cost of supplyin the server seed, deduct it;\r\n\tmapping (address => Roll) rolls;\r\n\tuint constant timeout = 20; // 5 Minutes\r\n\t\r\n\tfunction HonestDice() {\r\n\t\towner = msg.sender;\r\n\t\tfeed = msg.sender;\r\n\t}\r\n\t\r\n\tfunction roll(uint chance, bytes32 secretHash) {\r\n\t\tif (chance < 1 || chance > 255 || msg.value < minimumBet || calcWinnings(msg.value, chance) > getMaxPayout() || betsLocked != 0) { \r\n\t\t\tmsg.sender.send(msg.value); // Refund\r\n\t\t\treturn;\r\n\t\t}\r\n\t\trolls[msg.sender] = Roll(msg.value, chance, block.number, secretHash, 0);\r\n\t\tBet(msg.sender, block.number, msg.value, chance);\r\n\t}\r\n\t\r\n\tfunction serverSeed(address user, bytes32 seed) {\r\n\t\t// The server calls this with a random seed\r\n\t\tif (msg.sender != feed) return;\r\n\t\tif (rolls[user].serverSeed != 0) return;\r\n\t\trolls[user].serverSeed = seed;\r\n\t}\r\n\t\r\n\tfunction hashTo256(bytes32 hash) constant returns (uint _r) {\r\n\t\t// Returns a number between 0 - 255 from a hash\r\n\t\treturn uint(hash) & 0xff;\r\n\t}\r\n\t\r\n\tfunction hash(bytes32 input) constant returns (uint _r) {\r\n\t\t// Simple sha3 hash. Not to be called via the blockchain\r\n\t\treturn uint(sha3(input));\r\n\t}\r\n\t\r\n\tfunction isReady() constant returns (bool _r) {\r\n\t\treturn isReadyFor(msg.sender);\r\n\t}\r\n\t\r\n\tfunction isReadyFor(address _user) constant returns (bool _r) {\r\n\t\tRoll r = rolls[_user];\r\n\t\tif (r.serverSeed == 0) return false;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction getResult(bytes32 secret) constant returns (uint _r) {\r\n\t\t// Get the result number of the roll\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\treturn hashTo256(sha3(secret, r.serverSeed));\r\n\t}\r\n\t\r\n\tfunction didWin(bytes32 secret) constant returns (bool _r) {\r\n\t\t// Returns if the player won or not\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\tif (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tfunction calcWinnings(uint256 value, uint chance) constant returns (uint256 _r) {\r\n\t\t// 1% house edge\r\n\t\treturn (value * 99 / 100) * 256 / chance;\r\n\t}\r\n\t\r\n\tfunction getMaxPayout() constant returns (uint256 _r) {\r\n\t\treturn this.balance * maxPayout / 100;\r\n\t}\r\n\t\r\n\tfunction claim(bytes32 secret) {\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed == 0) return;\r\n\t\tif (sha3(secret) != r.secretHash) return;\r\n\t\tif (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\r\n\t\t\tmsg.sender.send(calcWinnings(r.value, r.chance) - seedCost);\r\n\t\t\tWon(msg.sender, r.value, r.chance);\r\n\t\t}\r\n\t\t\r\n\t\tdelete rolls[msg.sender];\r\n\t}\r\n\t\r\n\tfunction canClaimTimeout() constant returns (bool _r) {\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tif (r.serverSeed != 0) return false;\r\n\t\tif (r.value <= 0) return false;\r\n\t\tif (block.number < r.blocknum + timeout) return false;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction claimTimeout() {\r\n\t\t// Get your monies back if the server isn't responding with a seed\r\n\t\tif (!canClaimTimeout()) return;\r\n\t\tRoll r = rolls[msg.sender];\r\n\t\tmsg.sender.send(r.value);\r\n\t\tdelete rolls[msg.sender];\r\n\t}\r\n\t\r\n\tfunction getMinimumBet() constant returns (uint _r) {\r\n\t\treturn minimumBet;\r\n\t}\r\n\t\r\n\tfunction getBankroll() constant returns (uint256 _r) {\r\n\t\treturn this.balance;\r\n\t}\r\n\t\r\n\tfunction getBetsLocked() constant returns (uint _r) {\r\n\t\treturn betsLocked;\r\n\t}\r\n\t\r\n\tfunction setFeed(address newFeed) {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tfeed = newFeed;\r\n\t}\r\n\t\r\n\tfunction lockBetsForWithdraw() {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tuint betsLocked = block.number;\r\n\t}\r\n\t\r\n\tfunction unlockBets() {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tuint betsLocked = 0;\r\n\t}\r\n\t\r\n\tfunction withdraw(uint amount) {\r\n\t\tif (msg.sender != owner) return;\r\n\t\tif (betsLocked == 0 || block.number < betsLocked + 5760) return;\r\n\t\towner.send(amount);\r\n\t}\r\n}", 
  "balance": "81<b>.</b>944570743596402037 Ether", 
  "name": "HonestDice", 
  "transactions": "488", 
  "address": "0xd79b4c6791784184e2755b2fc1659eaab0f80456"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "552<b>.</b>03994550132878325 Ether", 
  "name": "Wallet", 
  "transactions": "483", 
  "address": "0xd06e310f2449c46327c01ef2845cb3259825c968"
 }, 
 {
  "source": "/*\r\n   Copyright 2016 Nexus Development, LLC\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n*/\r\n\r\npragma solidity ^0.4.2;\r\n\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ncontract ERC20Constant {\r\n    function totalSupply() constant returns (uint supply);\r\n    function balanceOf( address who ) constant returns (uint value);\r\n    function allowance(address owner, address spender) constant returns (uint _allowance);\r\n}\r\ncontract ERC20Stateful {\r\n    function transfer( address to, uint value) returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n}\r\ncontract ERC20Events {\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}\r\n\r\ncontract ERC20Base is ERC20\r\n{\r\n    mapping( address => uint ) _balances;\r\n    mapping( address => mapping( address => uint ) ) _approvals;\r\n    uint _supply;\r\n    function ERC20Base( uint initial_balance ) {\r\n        _balances[msg.sender] = initial_balance;\r\n        _supply = initial_balance;\r\n    }\r\n    function totalSupply() constant returns (uint supply) {\r\n        return _supply;\r\n    }\r\n    function balanceOf( address who ) constant returns (uint value) {\r\n        return _balances[who];\r\n    }\r\n    function transfer( address to, uint value) returns (bool ok) {\r\n        if( _balances[msg.sender] < value ) {\r\n            throw;\r\n        }\r\n        if( !safeToAdd(_balances[to], value) ) {\r\n            throw;\r\n        }\r\n        _balances[msg.sender] -= value;\r\n        _balances[to] += value;\r\n        Transfer( msg.sender, to, value );\r\n        return true;\r\n    }\r\n    function transferFrom( address from, address to, uint value) returns (bool ok) {\r\n        // if you don't have enough balance, throw\r\n        if( _balances[from] < value ) {\r\n            throw;\r\n        }\r\n        // if you don't have approval, throw\r\n        if( _approvals[from][msg.sender] < value ) {\r\n            throw;\r\n        }\r\n        if( !safeToAdd(_balances[to], value) ) {\r\n            throw;\r\n        }\r\n        // transfer and return true\r\n        _approvals[from][msg.sender] -= value;\r\n        _balances[from] -= value;\r\n        _balances[to] += value;\r\n        Transfer( from, to, value );\r\n        return true;\r\n    }\r\n    function approve(address spender, uint value) returns (bool ok) {\r\n        _approvals[msg.sender][spender] = value;\r\n        Approval( msg.sender, spender, value );\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) constant returns (uint _allowance) {\r\n        return _approvals[owner][spender];\r\n    }\r\n    function safeToAdd(uint a, uint b) internal returns (bool) {\r\n        return (a + b >= a);\r\n    }\r\n}\r\n\r\ncontract ReducedToken {\r\n    function balanceOf(address _owner) returns (uint256);\r\n    function transfer(address _to, uint256 _value) returns (bool);\r\n    function migrate(uint256 _value);\r\n}\r\n\r\ncontract DepositBrokerInterface {\r\n    function clear();\r\n}\r\n\r\ncontract TokenWrapperInterface is ERC20 {\r\n    function withdraw(uint amount);\r\n\r\n    // NO deposit, must be done via broker! Sorry!\r\n    function createBroker() returns (DepositBrokerInterface);\r\n\r\n    // broker contracts only - transfer to a personal broker then use `clear`\r\n    function notifyDeposit(uint amount);\r\n\r\n    function getBroker(address owner) returns (DepositBrokerInterface);\r\n}\r\n\r\ncontract DepositBroker is DepositBrokerInterface {\r\n    ReducedToken _g;\r\n    TokenWrapperInterface _w;\r\n    function DepositBroker( ReducedToken token ) {\r\n        _w = TokenWrapperInterface(msg.sender);\r\n        _g = token;\r\n    }\r\n    function clear() {\r\n        var amount = _g.balanceOf(this);\r\n        _g.transfer(_w, amount);\r\n        _w.notifyDeposit(amount);\r\n    }\r\n}\r\n\r\ncontract TokenWrapperEvents {\r\n    event LogBroker(address indexed broker);\r\n}\r\n\r\n// Deposits only accepted via broker!\r\ncontract TokenWrapper is ERC20Base(0), TokenWrapperInterface, TokenWrapperEvents {\r\n    ReducedToken _unwrapped;\r\n    mapping(address=>address) _broker2owner;\r\n    mapping(address=>address) _owner2broker;\r\n    function TokenWrapper( ReducedToken unwrapped) {\r\n        _unwrapped = unwrapped;\r\n    }\r\n    function createBroker() returns (DepositBrokerInterface) {\r\n        DepositBroker broker;\r\n        if( _owner2broker[msg.sender] == address(0) ) {\r\n            broker = new DepositBroker(_unwrapped);\r\n            _broker2owner[broker] = msg.sender;\r\n            _owner2broker[msg.sender] = broker;\r\n            LogBroker(broker);\r\n        }\r\n        else {\r\n            broker = DepositBroker(_owner2broker[msg.sender]);\r\n        }\r\n        \r\n        return broker;\r\n    }\r\n    function notifyDeposit(uint amount) {\r\n        var owner = _broker2owner[msg.sender];\r\n        if( owner == address(0) ) {\r\n            throw;\r\n        }\r\n        _balances[owner] += amount;\r\n        _supply += amount;\r\n    }\r\n    function withdraw(uint amount) {\r\n        if( _balances[msg.sender] < amount ) {\r\n            throw;\r\n        }\r\n        _balances[msg.sender] -= amount;\r\n        _supply -= amount;\r\n        _unwrapped.transfer(msg.sender, amount);\r\n    }\r\n    function getBroker(address owner) returns (DepositBrokerInterface) {\r\n        return DepositBroker(_owner2broker[msg.sender]);\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "TokenWrapper", 
  "transactions": "483", 
  "address": "0x01afc37f4f85babc47c0e2d0eababc7fb49793c8"
 }, 
 {
  "source": "// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        address oraclizeAddr = OAR.getAddress();\r\n        if (oraclizeAddr == 0){\r\n            oraclize_setNetwork(networkID_auto);\r\n            oraclizeAddr = OAR.getAddress();\r\n        }\r\n        oraclize = OraclizeI(oraclizeAddr);\r\n        _\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\r\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\r\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        return mint;\r\n    }\r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\r\n    uint public edge = 200; //edge percentage (10000 = 100%)\r\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint public minBet = 1 finney;\r\n    uint public maxInvestors = 5; //maximum number of investors\r\n    uint public ownerEdge = 50; //edge percentage (10000 = 100%)\r\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    \r\n    uint constant safeGas = 25000;\r\n    uint constant oraclizeGasLimit = 150000;\r\n\r\n    struct Investor {\r\n        address user;\r\n        uint capital;\r\n    }\r\n    mapping(uint => Investor) investors; //starts at 1\r\n    uint public numInvestors = 0;\r\n    mapping(address => uint) investorIDs;\r\n    uint public invested = 0;\r\n    \r\n    address owner;\r\n    bool public isStopped;\r\n\r\n    struct Bet {\r\n        address user;\r\n        uint bet; // amount\r\n        uint roll; // result\r\n\tuint fee; \r\n    }\r\n    mapping (bytes32 => Bet) bets;\r\n    bytes32[] betsKeys;\r\n    uint public amountWagered = 0;\r\n    int public profit = 0;\r\n    int public takenProfit = 0;\r\n    int public ownerProfit = 0;\r\n\r\n    function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) {\r\n        \r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        \r\n        pwin = pwinInitial;\r\n        edge = edgeInitial;\r\n        maxWin = maxWinInitial;\r\n        minBet = minBetInitial;\r\n        maxInvestors = maxInvestorsInitial;\r\n        ownerEdge = ownerEdgeInitial;\r\n        divestFee = divestFeeInitial;\r\n        \r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    function() {\r\n        bet();\r\n    }\r\n\r\n    function bet() {\r\n        if (isStopped) throw;\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\r\n        if (msg.value < oraclizeFee) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\", 'BDXJhrVpBJ53o2CxlJRlQtZJKZqLYt5IQe+73YDS4HtNjS5HodbIB3tvfow7UquyAk085VkLnL9EpKgwqWQz7ZLdGvsQlRd2sKxIolNg9DbnfPspGqLhLbbYSVnN8CwvsjpAXcSSo3c+4cNwC90yF4oNibkvD3ytapoZ7goTSyoUYTfwSjnw3ti+HJVH7N3+c0iwOCqZjDdsGQUcX3m3S/IHWbOOQQ5osO4Lbj3Gg0x1UdNtfUzYCFY79nzYgWIQEFCuRBI0n6NBvBQW727+OsDRY0J/9/gjt8ucibHWic0=', oraclizeGasLimit); // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}'\r\n            bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee);\r\n            betsKeys.push(myid);\r\n        } else {\r\n            throw; // invalid bet size\r\n        }\r\n    }\r\n\r\n    function numBets() constant returns(uint) {\r\n        return betsKeys.length;\r\n    }\r\n    \r\n    function minBetAmount() constant returns(uint) {\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\r\n        return oraclizeFee+minBet;\r\n    }\r\n    \r\n    function safeSend(address addr, uint value) internal {\r\n        if (!(addr.call.gas(safeGas).value(value)())){\r\n            ownerProfit += int(value);\r\n        }\r\n    }\r\n  \r\n    function __callback(bytes32 myid, string result, bytes proof) {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        \r\n        Bet thisBet = bets[myid];\r\n        if (thisBet.bet>0) {\r\n            if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) {\r\n                uint roll = parseInt(result);\r\n                if (roll<1 || roll>10000){\r\n                    safeSend(thisBet.user, thisBet.bet);\r\n                    return;    \r\n                }\r\n\r\n                bets[myid].roll = roll;\r\n                \r\n                int profitDiff;\r\n                if (roll-1 < pwin) { //win\r\n                    uint winAmount = (thisBet.bet * (10000 - edge)) / pwin;\r\n                    safeSend(thisBet.user, winAmount);\r\n                    profitDiff = int(thisBet.bet - winAmount);\r\n                } else { //lose\r\n                    safeSend(thisBet.user, 1);\r\n                    profitDiff = int(thisBet.bet) - 1;\r\n                }\r\n                \r\n                ownerProfit += (profitDiff*int(ownerEdge))/10000;\r\n                profit += profitDiff-(profitDiff*int(ownerEdge))/10000;\r\n                \r\n                amountWagered += thisBet.bet;\r\n            } else {\r\n                //bet is too big (bankroll may have changed since the bet was made)\r\n                safeSend(thisBet.user, thisBet.bet);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBet(uint id) constant returns(address, uint, uint, uint) {\r\n        if(id<betsKeys.length)\r\n        {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee);\r\n        }\r\n    }\r\n\r\n    function invest() {\r\n        if (isStopped) throw;\r\n        \r\n        if (investorIDs[msg.sender]>0) {\r\n            rebalance();\r\n            investors[investorIDs[msg.sender]].capital += msg.value;\r\n            invested += msg.value;\r\n        } else {\r\n            rebalance();\r\n            uint investorID = 0;\r\n            if (numInvestors<maxInvestors) {\r\n                investorID = ++numInvestors;\r\n            } else {\r\n                for (uint i=1; i<=numInvestors; i++) {\r\n                    if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) {\r\n                        investorID = i;\r\n                    }\r\n                }\r\n            }\r\n            if (investorID>0) {\r\n                if (investors[investorID].capital>0) {\r\n                    divest(investors[investorID].user, investors[investorID].capital);\r\n                    investorIDs[investors[investorID].user] = 0;\r\n                }\r\n                if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) {\r\n                    investors[investorID].user = msg.sender;\r\n                    investors[investorID].capital = msg.value;\r\n                    invested += msg.value;\r\n                    investorIDs[msg.sender] = investorID;\r\n                } else {\r\n                    throw;\r\n                }\r\n            } else {\r\n                throw;\r\n            }\r\n        }\r\n    }\r\n\r\n    function rebalance() private {\r\n        if (takenProfit != profit) {\r\n            uint newInvested = 0;\r\n            uint initialBankroll = getBankroll();\r\n            for (uint i=1; i<=numInvestors; i++) {\r\n                investors[i].capital = getBalance(investors[i].user);\r\n                newInvested += investors[i].capital;\r\n            }\r\n            invested = newInvested;\r\n            if (newInvested != initialBankroll && numInvestors>0) {\r\n                ownerProfit += int(initialBankroll - newInvested); //give the rounding error to the first investor\r\n                invested += (initialBankroll - newInvested);\r\n            }\r\n            takenProfit = profit;\r\n        }\r\n    }\r\n\r\n    function divest(address user, uint amount) private {\r\n        if (investorIDs[user]>0) {\r\n            rebalance();\r\n            if (amount>getBalance(user)) {\r\n                amount = getBalance(user);\r\n            }\r\n            investors[investorIDs[user]].capital -= amount;\r\n            invested -= amount;\r\n            \r\n            uint newAmount = (amount*divestFee)/10000; // take a fee from the deinvest amount\r\n            ownerProfit += int(newAmount);\r\n            safeSend(user, (amount-newAmount));\r\n        }\r\n    }\r\n\r\n    function divest(uint amount) {\r\n        if (msg.value>0) throw;\r\n        divest(msg.sender, amount);\r\n    }\r\n\r\n    function divest() {\r\n        if (msg.value>0) throw;\r\n        divest(msg.sender, getBalance(msg.sender));\r\n    }\r\n\r\n    function getBalance(address user) constant returns(uint) {\r\n        if (investorIDs[user]>0 && invested>0) {\r\n            return investors[investorIDs[user]].capital * getBankroll() / invested;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getBankroll() constant returns(uint) {\r\n        uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit);\r\n        if (this.balance < bankroll){\r\n            log0(\"bankroll_mismatch\");\r\n            bankroll = this.balance;\r\n        }\r\n        return bankroll;\r\n    }\r\n\r\n    function getMinInvestment() constant returns(uint) {\r\n        if (numInvestors<maxInvestors) {\r\n            return 0;\r\n        } else {\r\n            uint investorID;\r\n            for (uint i=1; i<=numInvestors; i++) {\r\n                if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) {\r\n                    investorID = i;\r\n                }\r\n            }\r\n            return getBalance(investors[investorID].user);\r\n        }\r\n    }\r\n\r\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) {\r\n        return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length);\r\n    }\r\n\r\n    function stopContract() {\r\n        if (owner != msg.sender) throw;\r\n        isStopped = true;\r\n    }\r\n  \r\n    function resumeContract() {\r\n        if (owner != msg.sender) throw;\r\n        isStopped = false;\r\n    }\r\n    \r\n    function forceDivestAll() {\r\n        forceDivestAll(false);\r\n    }\r\n    \r\n    function forceDivestAll(bool ownerTakeChangeAndProfit) {\r\n        if (owner != msg.sender) throw;\r\n        for (uint investorID=1; investorID<=numInvestors; investorID++) {\r\n            divest(investors[investorID].user, getBalance(investors[investorID].user));\r\n        }\r\n        if (ownerTakeChangeAndProfit) owner.send(this.balance);\r\n    }\r\n    \r\n    function ownerTakeProfit() {\r\n        ownerTakeProfit(false);\r\n    }\r\n    \r\n    function ownerTakeProfit(bool takeChange) {\r\n        if (owner != msg.sender) throw;\r\n        if (takeChange){\r\n            uint investorsCapital = 0;\r\n            for (uint i=1; i<=numInvestors; i++) {\r\n                investorsCapital += investors[i].capital;\r\n            }\r\n            if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\r\n                owner.send(this.balance);\r\n                ownerProfit = 0;\r\n            }\r\n        } else {\r\n            owner.send(uint(ownerProfit));\r\n            ownerProfit = 0;\r\n        }\r\n    }\r\n   \r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "483", 
  "address": "0xcf7cba701ded5c4d8e588e64f70b6ba1c17ea277"
 }, 
 {
  "source": "pragma solidity ^0.4.0;\r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n    \r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }    \r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   } \r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;                                  \r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }   \r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }   \r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n    \r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n    \r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    \r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract Dice is usingOraclize {\r\n\r\n    uint constant pwin = 9000; //probability of winning (10000 = 100%)\r\n    uint constant edge = 190; //edge percentage (10000 = 100%)\r\n    uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\r\n    uint constant minBet = 200 finney;\r\n    uint constant maxInvestors = 10; //maximum number of investors\r\n    uint constant houseEdge = 25; //edge percentage (10000 = 100%)\r\n    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)\r\n    uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%)\r\n\r\n    uint safeGas = 2300;\r\n    uint constant ORACLIZE_GAS_LIMIT = 175000;\r\n    uint constant INVALID_BET_MARKER = 99999;\r\n    uint constant EMERGENCY_TIMEOUT = 3 days;\r\n\r\n    struct Investor {\r\n        address investorAddress;\r\n        uint amountInvested;\r\n        bool votedForEmergencyWithdrawal;\r\n    }\r\n\r\n    struct Bet {\r\n        address playerAddress;\r\n        uint amountBet;\r\n        uint numberRolled;\r\n    }\r\n\r\n    struct WithdrawalProposal {\r\n        address toAddress;\r\n        uint atTime;\r\n    }\r\n\r\n    //Starting at 1\r\n    mapping(address => uint) public investorIDs;\r\n    mapping(uint => Investor) public investors;\r\n    uint public numInvestors = 0;\r\n\r\n    uint public invested = 0;\r\n\r\n    address public owner;\r\n    address public houseAddress;\r\n    bool public isStopped;\r\n\r\n    WithdrawalProposal public proposedWithdrawal;\r\n\r\n    mapping (bytes32 => Bet) public bets;\r\n    bytes32[] public betsKeys;\r\n\r\n    uint public investorsProfit = 0;\r\n    uint public investorsLosses = 0;\r\n    bool profitDistributed;\r\n\r\n    event LOG_NewBet(address playerAddress, uint amount);\r\n    event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\r\n    event LOG_BetLost(address playerAddress, uint numberRolled);\r\n    event LOG_EmergencyWithdrawalProposed();\r\n    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\r\n    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\r\n    event LOG_FailedSend(address receiver, uint amount);\r\n    event LOG_ZeroSend();\r\n    event LOG_InvestorEntrance(address investor, uint amount);\r\n    event LOG_InvestorCapitalUpdate(address investor, int amount);\r\n    event LOG_InvestorExit(address investor, uint amount);\r\n    event LOG_ContractStopped();\r\n    event LOG_ContractResumed();\r\n    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\r\n    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\r\n    event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\r\n    event LOG_EmergencyAutoStop();\r\n    event LOG_EmergencyWithdrawalVote(address investor, bool vote);\r\n    event LOG_ValueIsTooBig();\r\n    event LOG_SuccessfulSend(address addr, uint amount);\r\n\r\n    function Dice() {\r\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\r\n        owner = msg.sender;\r\n        houseAddress = msg.sender;\r\n    }\r\n\r\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyIfNotStopped {\r\n        if (isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfStopped {\r\n        if (!isStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInvestors {\r\n        if (investorIDs[msg.sender] == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotInvestors {\r\n        if (investorIDs[msg.sender] != 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOraclize {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanMinInvestment {\r\n        if (msg.value <= getMinInvestment()) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoreThanZero {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(bytes32 myid) {\r\n        if(bets[myid].playerAddress == address(0x0)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\r\n        if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) {\r\n             _;\r\n        }\r\n        else {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\r\n        uint numberRolled = parseInt(result);\r\n        if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\r\n            bets[myid].numberRolled = INVALID_BET_MARKER;\r\n            safeSend(bets[myid].playerAddress, bets[myid].amountBet);\r\n            return;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWinningBets(uint numberRolled) {\r\n        if (numberRolled - 1 < pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyLosingBets(uint numberRolled) {\r\n        if (numberRolled - 1 >= pwin) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyAfterProposed {\r\n        if (proposedWithdrawal.toAddress == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfProfitNotDistributed {\r\n        if (!profitDistributed) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyIfValidGas(uint newGasLimit) {\r\n        if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\r\n        if (newGasLimit < 25000) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotProcessed(bytes32 myid) {\r\n        if (bets[myid].numberRolled > 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfEmergencyTimeOutHasPassed {\r\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\r\n        _;\r\n    }\r\n\r\n    modifier investorsInvariant {\r\n        _;\r\n        if (numInvestors > maxInvestors) throw;\r\n    }\r\n\r\n    //CONSTANT HELPER FUNCTIONS\r\n\r\n    function getBankroll()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if ((invested < investorsProfit) ||\r\n            (invested + investorsProfit < invested) ||\r\n            (invested + investorsProfit < investorsLosses)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return invested + investorsProfit - investorsLosses;\r\n        }\r\n    }\r\n\r\n    function getMinInvestment()\r\n        constant\r\n        returns(uint) {\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint investorID = searchSmallestInvestor();\r\n            return getBalance(investors[investorID].investorAddress);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getStatus()\r\n        constant\r\n        returns(uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\r\n        uint bankroll = getBankroll();\r\n        uint minInvestment = getMinInvestment();\r\n        return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length);\r\n    }\r\n\r\n    function getBet(uint id)\r\n        constant\r\n        returns(address, uint, uint) {\r\n\r\n        if (id < betsKeys.length) {\r\n            bytes32 betKey = betsKeys[id];\r\n            return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\r\n        }\r\n    }\r\n\r\n    function numBets()\r\n        constant\r\n        returns(uint) {\r\n\r\n        return betsKeys.length;\r\n    }\r\n\r\n    function getMinBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        return oraclizeFee + minBet;\r\n    }\r\n\r\n    function getMaxBetAmount()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\r\n        return betValue + oraclizeFee;\r\n    }\r\n\r\n    function getLossesShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\r\n    }\r\n\r\n    function getProfitShare(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\r\n    }\r\n\r\n    function getBalance(address currentInvestor)\r\n        constant\r\n        returns (uint) {\r\n\r\n        uint invested = investors[investorIDs[currentInvestor]].amountInvested;\r\n        uint profit = getProfitShare(currentInvestor);\r\n        uint losses = getLossesShare(currentInvestor);\r\n\r\n        if ((invested + profit < profit) ||\r\n            (invested + profit < invested) ||\r\n            (invested + profit < losses))\r\n            return 0;\r\n        else\r\n            return invested + profit - losses;\r\n    }\r\n\r\n    function searchSmallestInvestor()\r\n        constant\r\n        returns(uint) {\r\n\r\n        uint investorID = 1;\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\r\n                investorID = i;\r\n            }\r\n        }\r\n\r\n        return investorID;\r\n    }\r\n\r\n    function changeOraclizeProofType(byte _proofType)\r\n        onlyOwner {\r\n\r\n        if (_proofType == 0x00) throw;\r\n        oraclize_setProof( _proofType |  proofStorage_IPFS );\r\n    }\r\n\r\n    function changeOraclizeConfig(bytes32 _config)\r\n        onlyOwner {\r\n\r\n        oraclize_setConfig(_config);\r\n    }\r\n\r\n    // PRIVATE HELPERS FUNCTION\r\n\r\n    function safeSend(address addr, uint value)\r\n        private {\r\n\r\n        if (value == 0) {\r\n            LOG_ZeroSend();\r\n            return;\r\n        }\r\n\r\n        if (this.balance < value) {\r\n            LOG_ValueIsTooBig();\r\n            return;\r\n        }\r\n\r\n        if (!(addr.call.gas(safeGas).value(value)())) {\r\n            LOG_FailedSend(addr, value);\r\n            if (addr != houseAddress) {\r\n                //Forward to house address all change\r\n                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\r\n            }\r\n        }\r\n\r\n        LOG_SuccessfulSend(addr,value);\r\n    }\r\n\r\n    function addInvestorAtID(uint id)\r\n        private {\r\n\r\n        investorIDs[msg.sender] = id;\r\n        investors[id].investorAddress = msg.sender;\r\n        investors[id].amountInvested = msg.value;\r\n        invested += msg.value;\r\n\r\n        LOG_InvestorEntrance(msg.sender, msg.value);\r\n    }\r\n\r\n    function profitDistribution()\r\n        private\r\n        onlyIfProfitNotDistributed {\r\n\r\n        uint copyInvested;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            address currentInvestor = investors[i].investorAddress;\r\n            uint profitOfInvestor = getProfitShare(currentInvestor);\r\n            uint lossesOfInvestor = getLossesShare(currentInvestor);\r\n            //Check for overflow and underflow\r\n            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\r\n                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {\r\n                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\r\n                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\r\n            }\r\n            else {\r\n                isStopped = true;\r\n                LOG_EmergencyAutoStop();\r\n            }\r\n\r\n            if (copyInvested + investors[i].amountInvested >= copyInvested)\r\n                copyInvested += investors[i].amountInvested;\r\n        }\r\n\r\n        delete investorsProfit;\r\n        delete investorsLosses;\r\n        invested = copyInvested;\r\n\r\n        profitDistributed = true;\r\n    }\r\n\r\n    // SECTION II: BET & BET PROCESSING\r\n\r\n    function()\r\n        payable {\r\n\r\n        bet();\r\n    }\r\n\r\n    function bet()\r\n        payable\r\n        onlyIfNotStopped {\r\n\r\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\r\n        if (oraclizeFee >= msg.value) throw;\r\n        uint betValue = msg.value - oraclizeFee;\r\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\r\n            LOG_NewBet(msg.sender, betValue);\r\n            bytes32 myid =\r\n                oraclize_query(\r\n                    \"nested\",\r\n                    \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BCwQjCz4jHioB9O2gc+U+wyWmL2GcIOI/nLM9hpSH/W1q49WbwY4e7uKOPft1No60u57EQPDnz4518CfJDxls3zL9Ks5xjW3wFi8vnRESRkRTOP9xF0e+h/VUv7fFk8dgYSVnp4HeRin5lqclE2wEcHbInSMieg=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\",\r\n                    ORACLIZE_GAS_LIMIT + safeGas\r\n                );\r\n            bets[myid] = Bet(msg.sender, betValue, 0);\r\n            betsKeys.push(myid);\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result, bytes proof)\r\n        onlyOraclize\r\n        onlyIfBetExist(myid)\r\n        onlyIfNotProcessed(myid)\r\n        onlyIfValidRoll(myid, result)\r\n        onlyIfBetSizeIsStillCorrect(myid)  {\r\n\r\n        uint numberRolled = parseInt(result);\r\n        bets[myid].numberRolled = numberRolled;\r\n        isWinningBet(bets[myid], numberRolled);\r\n        isLosingBet(bets[myid], numberRolled);\r\n        delete profitDistributed;\r\n    }\r\n\r\n    function isWinningBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyWinningBets(numberRolled) {\r\n\r\n        uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\r\n        LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\r\n        safeSend(thisBet.playerAddress, winAmount);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsLosses + winAmount < investorsLosses) ||\r\n            (investorsLosses + winAmount < thisBet.amountBet)) {\r\n                throw;\r\n            }\r\n\r\n        investorsLosses += winAmount - thisBet.amountBet;\r\n    }\r\n\r\n    function isLosingBet(Bet thisBet, uint numberRolled)\r\n        private\r\n        onlyLosingBets(numberRolled) {\r\n\r\n        LOG_BetLost(thisBet.playerAddress, numberRolled);\r\n        safeSend(thisBet.playerAddress, 1);\r\n\r\n        //Check for overflow and underflow\r\n        if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\r\n            (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\r\n            (thisBet.amountBet == 1)) {\r\n                throw;\r\n            }\r\n\r\n        uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback\r\n        investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\r\n        uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback\r\n        safeSend(houseAddress, houseProfit);\r\n    }\r\n\r\n    //SECTION III: INVEST & DIVEST\r\n\r\n    function increaseInvestment()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyInvestors  {\r\n\r\n        profitDistribution();\r\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\r\n        invested += msg.value;\r\n    }\r\n\r\n    function newInvestor()\r\n        payable\r\n        onlyIfNotStopped\r\n        onlyMoreThanZero\r\n        onlyNotInvestors\r\n        onlyMoreThanMinInvestment\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n\r\n        if (numInvestors == maxInvestors) {\r\n            uint smallestInvestorID = searchSmallestInvestor();\r\n            divest(investors[smallestInvestorID].investorAddress);\r\n        }\r\n\r\n        numInvestors++;\r\n        addInvestorAtID(numInvestors);\r\n    }\r\n\r\n    function divest()\r\n        onlyInvestors {\r\n\r\n        divest(msg.sender);\r\n    }\r\n\r\n\r\n    function divest(address currentInvestor)\r\n        private\r\n        investorsInvariant {\r\n\r\n        profitDistribution();\r\n        uint currentID = investorIDs[currentInvestor];\r\n        uint amountToReturn = getBalance(currentInvestor);\r\n\r\n        if ((invested >= investors[currentID].amountInvested)) {\r\n            invested -= investors[currentID].amountInvested;\r\n            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\r\n            amountToReturn -= divestFeeAmount;\r\n\r\n            delete investors[currentID];\r\n            delete investorIDs[currentInvestor];\r\n\r\n            //Reorder investors\r\n            if (currentID != numInvestors) {\r\n                // Get last investor\r\n                Investor lastInvestor = investors[numInvestors];\r\n                //Set last investor ID to investorID of divesting account\r\n                investorIDs[lastInvestor.investorAddress] = currentID;\r\n                //Copy investor at the new position in the mapping\r\n                investors[currentID] = lastInvestor;\r\n                //Delete old position in the mappping\r\n                delete investors[numInvestors];\r\n            }\r\n\r\n            numInvestors--;\r\n            safeSend(currentInvestor, amountToReturn);\r\n            safeSend(houseAddress, divestFeeAmount);\r\n            LOG_InvestorExit(currentInvestor, amountToReturn);\r\n        } else {\r\n            isStopped = true;\r\n            LOG_EmergencyAutoStop();\r\n        }\r\n    }\r\n\r\n    function forceDivestOfAllInvestors()\r\n        onlyOwner {\r\n\r\n        uint copyNumInvestors = numInvestors;\r\n        for (uint i = 1; i <= copyNumInvestors; i++) {\r\n            divest(investors[1].investorAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n    The owner can use this function to force the exit of an investor from the\r\n    contract during an emergency withdrawal in the following situations:\r\n        - Unresponsive investor\r\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\r\n        other investors\r\n    */\r\n    function forceDivestOfOneInvestor(address currentInvestor)\r\n        onlyOwner\r\n        onlyIfStopped {\r\n\r\n        divest(currentInvestor);\r\n        //Resets emergency withdrawal proposal. Investors must vote again\r\n        delete proposedWithdrawal;\r\n    }\r\n\r\n    //SECTION IV: CONTRACT MANAGEMENT\r\n\r\n    function stopContract()\r\n        onlyOwner {\r\n\r\n        isStopped = true;\r\n        LOG_ContractStopped();\r\n    }\r\n\r\n    function resumeContract()\r\n        onlyOwner {\r\n\r\n        isStopped = false;\r\n        LOG_ContractResumed();\r\n    }\r\n\r\n    function changeHouseAddress(address newHouse)\r\n        onlyOwner {\r\n\r\n        if (newHouse == address(0x0)) throw; //changed based on audit feedback\r\n        houseAddress = newHouse;\r\n        LOG_HouseAddressChanged(houseAddress, newHouse);\r\n    }\r\n\r\n    function changeOwnerAddress(address newOwner)\r\n        onlyOwner {\r\n\r\n        if (newOwner == address(0x0)) throw;\r\n        owner = newOwner;\r\n        LOG_OwnerAddressChanged(owner, newOwner);\r\n    }\r\n\r\n    function changeGasLimitOfSafeSend(uint newGasLimit)\r\n        onlyOwner\r\n        onlyIfValidGas(newGasLimit) {\r\n\r\n        safeGas = newGasLimit;\r\n        LOG_GasLimitChanged(safeGas, newGasLimit);\r\n    }\r\n\r\n    //SECTION V: EMERGENCY WITHDRAWAL\r\n\r\n    function voteEmergencyWithdrawal(bool vote)\r\n        onlyInvestors\r\n        onlyAfterProposed\r\n        onlyIfStopped {\r\n\r\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\r\n        LOG_EmergencyWithdrawalVote(msg.sender, vote);\r\n    }\r\n\r\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\r\n        onlyIfStopped\r\n        onlyOwner {\r\n\r\n        //Resets previous votes\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            delete investors[i].votedForEmergencyWithdrawal;\r\n        }\r\n\r\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\r\n        LOG_EmergencyWithdrawalProposed();\r\n    }\r\n\r\n    function executeEmergencyWithdrawal()\r\n        onlyOwner\r\n        onlyAfterProposed\r\n        onlyIfStopped\r\n        onlyIfEmergencyTimeOutHasPassed {\r\n\r\n        uint numOfVotesInFavour;\r\n        uint amountToWithdraw = this.balance;\r\n\r\n        for (uint i = 1; i <= numInvestors; i++) {\r\n            if (investors[i].votedForEmergencyWithdrawal == true) {\r\n                numOfVotesInFavour++;\r\n                delete investors[i].votedForEmergencyWithdrawal;\r\n            }\r\n        }\r\n\r\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\r\n            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\r\n                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\r\n            }\r\n            else {\r\n                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\r\n            }\r\n        }\r\n        else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "Dice", 
  "transactions": "483", 
  "address": "0x84bfd848717d60e01805b34d38a0d8b1f2bc4e85"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n\t// TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n\t// EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n\t// MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n\t// METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n   \t// FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n\t// MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n\t// METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value < m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n\t// FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint m_spentToday;\r\n    uint m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n\t// EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n\t// TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n\t// FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "741<b>.</b>852621178748871984 Ether", 
  "name": "Wallet", 
  "transactions": "475", 
  "address": "0xda4a4626d3e16e094de3225a751aab7128e96526"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "1<b>.</b>002749087366345 Ether", 
  "name": "Wallet", 
  "transactions": "461", 
  "address": "0x4cf1fb602758744fc8b782c948ae52fd85ed62e3"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "23<b>.</b>57951163 Ether", 
  "name": "Wallet", 
  "transactions": "459", 
  "address": "0x298f6444c7889a2284689badba002b63b383b4e7"
 }
]