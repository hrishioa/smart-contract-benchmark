[
 {
  "source": "contract AmIOnTheFork {\r\n    function forked() constant returns(bool);\r\n}\r\n\r\ncontract ReplaySafeSplit {\r\n    // Fork oracle to use\r\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\r\n\r\n    // Splits the funds into 2 addresses\r\n    function split(address targetFork, address targetNoFork) returns(bool) {\r\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\r\n            return true;\r\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\r\n            return true;\r\n        }\r\n        throw; // don't accept value transfer, otherwise it would be trapped.\r\n    }\r\n\r\n    // Reject value transfers.\r\n    function() {\r\n        throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ReplaySafeSplit", 
  "address": "0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444", 
  "transactions": "184841"
 }, 
 {
  "source": "/*\n\n- Bytecode Verification performed was compared on second iteration -\n\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic, standardized Token contract with no \"premine\". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic account, used by the DAO contract to separately manage both the rewards \nand the extraBalance accounts. \n*/\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n * Token Creation contract, used by the DAO to create its tokens and initialize\n * its ether. Feel free to modify the divisor method to implement different\n * Token Creation parameters\n*/\n\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks > now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days > now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0\n            || _debatingPeriod < minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}", 
  "balance": "7<b>.</b>565996705823359927 Ether", 
  "name": "DAO", 
  "address": "0xbb9bc244d798123fde783fcc1c72d3bb8c189413", 
  "transactions": "168208"
 }, 
 {
  "source": "contract AmIOnTheFork {\r\n    function forked() constant returns(bool);\r\n}\r\n\r\ncontract ReplaySafeSplit {\r\n    // Fork oracle to use\r\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\r\n\r\n    event e(address a);\r\n\t\r\n    // Splits the funds into 2 addresses\r\n    function split(address targetFork, address targetNoFork) returns(bool) {\r\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\r\n\t\t\te(targetFork);\r\n            return true;\r\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\r\n\t\t\te(targetNoFork);\t\t\r\n            return true;\r\n        }\r\n        throw; // don't accept value transfer, otherwise it would be trapped.\r\n    }\r\n\r\n    // Reject value transfers.\r\n    function() {\r\n        throw;\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "ReplaySafeSplit", 
  "address": "0xe94b04a0fed112f3664e45adb2b8915693dd5ff3", 
  "transactions": "123413"
 }, 
 {
  "source": "pragma solidity ^0.4.4;\r\n/*\r\n* This is a contract for debloating the state\r\n* @author mhswende\r\n**/\r\ncontract Sweeper\r\n{\r\n    //Solidity implentation\r\n    function sol_clean(uint256 s, uint i){\r\n        uint x = s;\r\n        address b = 0;\r\n        for(uint c=0 ; c < i ; c++){\r\n            x = x+s;\r\n            b = address(x/0x1000000000000000000000000);\r\n            b.send(0);\r\n\r\n        }\r\n    }\r\n    //Asm implementation\r\n    function asm_clean(uint s, uint i)\r\n    {\r\n\r\n        assembly{\r\n            let seed := calldataload(4)//4 if we're using a named function\r\n            let iterations := calldataload(36)\r\n            let target :=seed\r\n        \r\n        loop:\r\n            target := add(target,seed)\r\n            pop(call(0,div(target,0x1000000000000000000000000),0,0,0,0,0))\r\n            iterations := sub(iterations,1) \r\n            jumpi(loop, iterations)\r\n        }\r\n    }\r\n}", 
  "balance": "0 Ether", 
  "name": "Sweeper", 
  "address": "0xa43ebd8939d8328f5858119a3fb65f65c864c6dd", 
  "transactions": "35370"
 }, 
 {
  "source": "// Ethereum Name Registrar as it should be!\r\n//\r\n// Written by Alexandre Naverniouk\r\n// twitter @AlexNa\r\n\r\n\r\ncontract EtherId {\r\n\r\nuint constant MAX_PROLONG = 2000000; // Maximum number of blocks to prolong the ownership. About one year.\r\n\r\nuint public n_domains = 0;      // total number of registered domains\r\nuint public root_domain = 0;    // name of the first domain in the linked list\r\naddress contract_owner = 0; //\r\n\r\nstruct Id {                     // Id record. Double linked list. Allows to delete ID\r\n    uint value;\r\n    uint next_id;\r\n    uint prev_id;\r\n}\r\n\r\nstruct Domain {                 // Domain record. Linked list. \r\n    address owner;              // Owner of the domain\r\n    uint expires;               // Expiration block namber\r\n    uint price;                 // Sale price ( 0 - not for sale )\r\n    address transfer;           // Address of the new owner\r\n    uint next_domain;           // Makes linked list for scanning\r\n    uint root_id;               // Name of the first ID in the list\r\n    mapping (uint => Id) ids;   // Map of the ID's\r\n}\r\n\r\nmapping (uint => Domain) domains; // Map of the domains\r\n\r\nfunction EtherId()\r\n{\r\n    contract_owner = msg.sender;\r\n}\r\n\r\nevent DomainChanged( address indexed sender, uint domain, uint id ); // Fired every time the registry is changed\r\n\r\nfunction getId( uint domain, uint id ) constant returns (uint v, uint next_id, uint prev_id )\r\n{\r\n    Id i = domains[domain].ids[id]; \r\n\r\n    v = i.value;\r\n    next_id = i.next_id;\r\n    prev_id = i.prev_id;\r\n}\r\n\r\nfunction getDomain( uint domain ) constant returns \r\n    (address owner, uint expires, uint price, address transfer, uint next_domain, uint root_id )\r\n{\r\n    Domain d = domains[ domain ];\r\n    \r\n    owner = d.owner;\r\n    expires = d.expires;\r\n    price = d.price;\r\n    transfer = d.transfer;\r\n    next_domain = d.next_domain;\r\n    root_id = d.root_id;    \r\n}\r\n\r\n\r\nfunction changeDomain( uint domain, uint expires, uint price, address transfer ) \r\n{\r\n    uint money_used = 0;            // How much was spent here\r\n\r\n    if( expires > MAX_PROLONG )     // Not prolong for too long\r\n    {\r\n        expires = MAX_PROLONG;\r\n    }\r\n    \r\n    if( domain == 0 ) throw;        // Prevents creating 0 domain\r\n\r\n    Domain d = domains[ domain ];\r\n\r\n    if( d.owner == 0 )              // 0 means the domain is not yet registered\r\n    { \r\n        d.owner = msg.sender;       // Simple calim\r\n        d.price = price;\r\n        d.transfer = transfer;\r\n        d.expires = block.number + expires;\r\n        \r\n        d.next_domain = root_domain;// Put the new domain into the linked list\r\n        root_domain = domain;\r\n        \r\n        //****************************************************************************\r\n        //*** SPECIAL CODE FOR TRANSFERING FIRST 32301 DOMAINS INTO THE NEW CONTRACT\r\n        if( msg.sender == contract_owner && n_domains < 32301 && transfer != 0 ) { \r\n            d.owner = transfer; // immediately transfer the ownership to the old owner\r\n            d.transfer = 0;\r\n        }\r\n        //****************************************************************************\r\n        \r\n        \r\n        n_domains = n_domains + 1;\r\n        DomainChanged( msg.sender, domain, 0 );\r\n    }\r\n    else                            // The domain already has an owner\r\n    {\r\n        if( d.owner == msg.sender || block.number > d.expires ) { // If it is yours or expired, you have all rights to change\r\n            d.owner = msg.sender;   // Possible change of the ownershp if expired\r\n            d.price = price;\r\n            d.transfer = transfer;\r\n            d.expires = block.number + expires;\r\n            DomainChanged( msg.sender, domain, 0 );\r\n        }\r\n        else                        // Not yours and not expired\r\n        {\r\n            if( d.transfer != 0 ) { // The new owner is specified and ...\r\n                if( d.transfer == msg.sender && msg.value >= d.price ) // ... it is you and enought money \r\n                {\r\n                    if( d.price > 0 ) \r\n                    { \r\n                        if( address( d.owner ).send( d.price ) ) // The money goes to the owner\r\n                        {\r\n                            money_used = d.price;   // remember how much spent\r\n                        }\r\n                        else throw; // problem with send()\r\n                    }\r\n\r\n                    d.owner = msg.sender;   // Change the ownership\r\n                    d.price = price;        // New price\r\n                    d.transfer = transfer;  // New transfer\r\n                    d.expires = block.number + expires; //New expiration\r\n                    DomainChanged( msg.sender, domain, 0 );\r\n                }\r\n            } \r\n            else  // not set for transfer, but...\r\n            {\r\n                if( d.price > 0 &&  msg.value >= d.price ) // ... on sale, and enough money\r\n                {\r\n                    if( address( d.owner ).send( d.price ) ) // The money goes to the owner\r\n                    {\r\n                        money_used = d.price; // remember how much spent\r\n                    }\r\n                    else throw; // problem with send()\r\n\r\n                    d.owner = msg.sender;   // Change the ownership\r\n                    d.price = price;        // New price\r\n                    d.transfer = transfer;  // New transfer\r\n                    d.expires = block.number + expires; // New expiration\r\n                    DomainChanged( msg.sender, domain, 0 );\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    if( msg.value > money_used ) // If transaction has more money than was needed\r\n    {\r\n        if( !msg.sender.send( msg.value - money_used ) ) throw; // We do not need your leftover\r\n    }\r\n}\r\n\r\nfunction changeId( uint domain, uint name, uint value ) {\r\n\r\n    if( domain == 0 ) throw;        // Prevents creating 0 domain\r\n    if( name == 0 ) throw;          // Prevents creating 0 id\r\n    \r\n    Domain d = domains[ domain ];\r\n\r\n    if( d.owner == msg.sender )     // Only owner can change the ID\r\n    {\r\n        Id id = d.ids[ name ];\r\n\r\n        if( id.value == 0 ) {       // 0 means the ID was not found\r\n            if( value != 0 ) {      // Only add non zero values\r\n                id.value = value;   \r\n                id.next_id = d.root_id; // Put into the head of the list\r\n                // id.prev_id = 0;  // 0 is the default, no need to assign\r\n                \r\n                if( d.root_id != 0 ) \r\n                {\r\n                    d.ids[ d.root_id ].prev_id = name; // link the next ID back\r\n                }\r\n\r\n                d.root_id = name;   \r\n                DomainChanged( msg.sender, domain, name );\r\n            }\r\n        }\r\n        else                        // The ID was found\r\n        {\r\n            if( value != 0 )        // Simple change of the value\r\n            {\r\n                id.value = value;\r\n                DomainChanged( msg.sender, domain, name );\r\n            }\r\n            else                    // Deleting the ID\r\n            {\r\n                if( id.prev_id != 0 ) // Modify the double linked list\r\n                {\r\n                    d.ids[ id.prev_id ].next_id = id.next_id;   \r\n                }\r\n                else\r\n                {\r\n                    d.root_id = id.next_id;\r\n                }\r\n\r\n                if( id.next_id != 0 )\r\n                {\r\n                    d.ids[ id.next_id ].prev_id = id.prev_id;   \r\n                }\r\n                \r\n                id.prev_id = 0;   // Clear the storage\r\n                id.next_id = 0;   \r\n                id.value = 0;   \r\n                DomainChanged( msg.sender, domain, name );\r\n            }\r\n        }\r\n    }\r\n    \r\n    if( msg.value > 0 ) // If transaction has any money...\r\n    {\r\n        if( !msg.sender.send( msg.value ) ) throw; // ... it is a mistake, so send it back\r\n    }\r\n}\r\n\r\n}", 
  "balance": "0 Ether", 
  "name": "EtherId", 
  "address": "0xd588b586d61c826a0e87919b3d1a239206d58bf2", 
  "transactions": "33203"
 }, 
 {
  "source": "//                       , ; ,   .-'\"\"\"'-.   , ; ,\r\n//                       \\\\|/  .'          '.  \\|//\r\n//                        \\-;-/   ()   ()   \\-;-/\r\n//                        // ;               ; \\\\\r\n//                       //__; :.         .; ;__\\\\\r\n//                      `-----\\'.'-.....-'.'/-----'\r\n//                             '.'.-.-,_.'.'\r\n//                               '(  (..-'\r\n//                                 '-'\r\n//  ROULETH \r\n//\r\n//  Play the Roulette on ethereum blockchain !\r\n//  (or become a member of Rouleth's Decentralized Organisation  and contribute to the bankroll.) \r\n//\r\n//\r\n//\r\n//   check latest contract address version on the current website interface\r\n//   V 2\r\n//\r\n//\r\n//\r\n\r\ncontract Rouleth\r\n{\r\n    //Game and Global Variables, Structure of gambles\r\n    address developer;\r\n    uint8 blockDelay; //nb of blocks to wait before spin\r\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\r\n    uint256 maxGamble; //max gamble value manually set by config\r\n    uint256 minGamble; //min gamble value manually set by config\r\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\r\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\r\n    uint casinoStatisticalLimit; //ratio payroll and max win\r\n    //Current gamble value possibly lower than limit auto\r\n    uint256 currentMaxGamble; \r\n    //Gambles\r\n    enum BetTypes{number, color, parity, dozen, column, lowhigh} \r\n    struct Gamble\r\n    {\r\n\taddress player;\r\n        bool spinned; //Was the rouleth spinned ?\r\n\tbool win;\r\n\t//Possible bet types\r\n        BetTypes betType;\r\n\tuint8 input; //stores number, color, dozen or oddeven\r\n\tuint256 wager;\r\n\tuint256 blockNumber; //block of bet\r\n\tuint256 blockSpinned; //block of spin\r\n        uint8 wheelResult;\r\n    }\r\n    Gamble[] private gambles;\r\n    uint totalGambles; \r\n    //Tracking progress of players\r\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\r\n    //records current status of player\r\n    enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; \r\n\r\n\r\n    //**********************************************\r\n    //        Management & Config FUNCTIONS        //\r\n    //**********************************************\r\n\r\n    function  Rouleth() private //creation settings\r\n    { \r\n        developer = msg.sender;\r\n        blockDelay=1; //indicates which block after bet will be used for RNG\r\n\tblockExpiration=200; //delay after which gamble expires\r\n        minGamble=50 finney; //configurable min bet\r\n        maxGamble=500 finney; //configurable max bet\r\n        maxBetsPerBlock=5; // limit of bets per block, to prevent multiple bets per miners\r\n        casinoStatisticalLimit=100; //we are targeting at least 400\r\n    }\r\n    \r\n    modifier onlyDeveloper() \r\n    {\r\n\tif (msg.sender!=developer) throw;\r\n\t_\r\n    }\r\n    \r\n    function changeDeveloper_only_Dev(address new_dev)\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\tdeveloper=new_dev;\r\n    }\r\n\r\n    //Prevents accidental sending of Eth when you shouldn't\r\n    modifier noEthSent()\r\n    {\r\n        if (msg.value>0) \r\n\t{\r\n\t    throw;\r\n\t}\r\n        _\r\n    }\r\n\r\n\r\n    //Activate, Deactivate Betting\r\n    enum States{active, inactive} States private contract_state;\r\n    \r\n    function disableBetting_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        contract_state=States.inactive;\r\n    }\r\n\r\n\r\n    function enableBetting_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        contract_state=States.active;\r\n\r\n    }\r\n    \r\n    modifier onlyActive()\r\n    {\r\n        if (contract_state==States.inactive) throw;\r\n        _\r\n    }\r\n\r\n\r\n\r\n    //Change some settings within safety bounds\r\n    function changeSettings_only_Dev(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMinGamble, uint256 newMaxGamble, uint16 newMaxInvestor, uint256 newMinInvestment,uint256 newMaxInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\r\n\r\n        // changes the statistical multiplier that guarantees the long run casino survival\r\n        if (newCasinoStatLimit<100) throw;\r\n        casinoStatisticalLimit=newCasinoStatLimit;\r\n        //Max number of bets per block to prevent miner cheating\r\n        maxBetsPerBlock=newMaxBetsBlock;\r\n        //MAX BET : limited by payroll/(casinoStatisticalLimit*35)\r\n        if (newMaxGamble<newMinGamble) throw;  \r\n\telse { maxGamble=newMaxGamble; }\r\n        //Min Bet\r\n        if (newMinGamble<0) throw; \r\n\telse { minGamble=newMinGamble; }\r\n        //MAX NB of DAO members (can only increase (within bounds) or stay equal)\r\n        //this number of members can only increase after 25k spins on Rouleth\r\n        //refuse change of max number of members if less than 25k spins played\r\n        if (newMaxInvestor!=setting_maxInvestors && gambles.length<25000) throw;\r\n        if ( newMaxInvestor<setting_maxInvestors \r\n             || newMaxInvestor>investors.length) throw;\r\n        else { setting_maxInvestors=newMaxInvestor;}\r\n        //computes the results of the vote of the VIP members, fees to apply to new members\r\n        computeResultVoteExtraInvestFeesRate();\r\n        if (newMaxInvestment<newMinInvestment) throw;\r\n        //MIN INVEST : \r\n        setting_minInvestment=newMinInvestment;\r\n        //MAX INVEST : \r\n        setting_maxInvestment=newMaxInvestment;\r\n        //Invest LOCK PERIOD\r\n\t//1 year max\r\n\t//can also serve as a failsafe to shutdown withdraws for a period\r\n        if (setting_lockPeriod>360 days) throw; \r\n        setting_lockPeriod=newLockPeriod;\r\n        //Delay before spin :\r\n\tblockDelay=newBlockDelay;\r\n\tif (newBlockExpiration<blockDelay+20) throw;\r\n\tblockExpiration=newBlockExpiration;\r\n        updateMaxBet();\r\n    }\r\n\r\n\r\n    //**********************************************\r\n    //                 Nicknames FUNCTIONS                    //\r\n    //**********************************************\r\n\r\n    //User set nickname\r\n    mapping (address => string) nicknames;\r\n    function setNickname(string name) \r\n    noEthSent\r\n    {\r\n        if (bytes(name).length >= 2 && bytes(name).length <= 30)\r\n            nicknames[msg.sender] = name;\r\n    }\r\n    function getNickname(address _address) constant returns(string _name) {\r\n        _name = nicknames[_address];\r\n    }\r\n\r\n    \r\n    //**********************************************\r\n    //                 BETTING FUNCTIONS                    //\r\n    //**********************************************\r\n\r\n    //***//basic betting without Mist or contract call\r\n    //activates when the player only sends eth to the contract\r\n    //without specifying any type of bet.\r\n    function () \r\n    {\r\n\t//defaut bet : bet on red\r\n\tbetOnColor(true,false);\r\n    } \r\n\r\n    //Admin function that\r\n    //recalculates max bet\r\n    //updated after each bet and change of bankroll\r\n    function updateMaxBet() private\r\n    {\r\n\t//check that setting is still within safety bounds\r\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \r\n\t{ \r\n\t    currentMaxGamble=maxGamble;\r\n        }\r\n\telse\r\n\t{ \r\n\t    currentMaxGamble = payroll/(casinoStatisticalLimit*35);\r\n\t}\r\n    }\r\n\r\n\r\n    //***//Guarantees that gamble is under max bet and above min.\r\n    // returns bet value\r\n    function checkBetValue() private returns(uint256 playerBetValue)\r\n    {\r\n        if (msg.value < minGamble) throw;\r\n\tif (msg.value > currentMaxGamble) //if above max, send difference back\r\n\t{\r\n            playerBetValue=currentMaxGamble;\r\n\t}\r\n        else\r\n        { playerBetValue=msg.value; }\r\n        return;\r\n    }\r\n\r\n\r\n    //check number of bets in block (to prevent miner cheating)\r\n    modifier checkNbBetsCurrentBlock()\r\n    {\r\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\r\n        else nbBetsCurrentBlock=0;\r\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\r\n        _\r\n    }\r\n\r\n\r\n    //Function record bet called by all others betting functions\r\n    function placeBet(BetTypes betType_, uint8 input_) private\r\n    {\r\n\t// Before we record, we may have to spin the past bet if the croupier bot \r\n\t// is down for some reason or if the player played again too quickly.\r\n\t// This would fail though if the player tries too play to quickly (in consecutive block).\r\n\t// gambles should be spaced by at least a block\r\n\t// the croupier bot should spin within 2 blocks (~30 secs) after your bet.\r\n\t// if the bet expires it is added to casino profit, otherwise it would be a way to cheat\r\n\tif (playerStatus[msg.sender]!=Status.waitingForBet)\r\n\t{\r\n            SpinTheWheel(msg.sender);\r\n\t}\r\n        //Once this is done, we can record the new bet\r\n\tplayerStatus[msg.sender]=Status.waitingForSpin;\r\n\tgambleIndex[msg.sender]=gambles.length;\r\n        totalGambles++;\r\n        //adapts wager to casino limits\r\n        uint256 betValue = checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, betType_, input_, betValue, block.number, 0, 37)); //37 indicates not spinned yet\r\n\t//refund excess bet (at last step vs re-entry)\r\n        if (betValue<msg.value) \r\n        {\r\n \t    if (msg.sender.send(msg.value-betValue)==false) throw;\r\n        }\r\n    }\r\n\r\n\r\n    //***//bet on Number\t\r\n    function betOnNumber(uint8 numberChosen)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        //check that number chosen is valid and records bet\r\n        if (numberChosen>36) throw;\r\n        placeBet(BetTypes.number, numberChosen);\r\n    }\r\n\r\n    //***// function betOnColor\r\n    //bet type : color\r\n    //input : 0 for red\r\n    //input : 1 for black\r\n    function betOnColor(bool Red, bool Black)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Red) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (Black) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(BetTypes.color, input);\r\n    }\r\n\r\n    //***// function betOnLow_High\r\n    //bet type : lowhigh\r\n    //input : 0 for low\r\n    //input : 1 for low\r\n    function betOnLowHigh(bool Low, bool High)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Low) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (High) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(BetTypes.lowhigh, input);\r\n    }\r\n\r\n    //***// function betOnOddEven\r\n    //bet type : parity\r\n    //input : 0 for even\r\n    //input : 1 for odd\r\n    function betOnOddEven(bool Odd, bool Even)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Even) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (Odd) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(BetTypes.parity, input);\r\n    }\r\n\r\n\r\n    //***// function betOnDozen\r\n    //     //bet type : dozen\r\n    //     //input : 0 for first dozen\r\n    //     //input : 1 for second dozen\r\n    //     //input : 2 for third dozen\r\n    function betOnDozen(bool First, bool Second, bool Third)\r\n    {\r\n        betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\r\n    }\r\n\r\n\r\n    // //***// function betOnColumn\r\n    //     //bet type : column\r\n    //     //input : 0 for first column\r\n    //     //input : 1 for second column\r\n    //     //input : 2 for third column\r\n    function betOnColumn(bool First, bool Second, bool Third)\r\n    {\r\n        betOnColumnOrDozen(First, Second, Third, BetTypes.column);\r\n    }\r\n\r\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    { \r\n        uint8 count;\r\n        uint8 input;\r\n        if (First) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (Second) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (Third) \r\n        {\r\n            count+=1; \r\n            input=2;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(bet, input);\r\n    }\r\n\r\n\r\n    //**********************************************\r\n    // Spin The Wheel & Check Result FUNCTIONS//\r\n    //**********************************************\r\n\r\n    event Win(address player, uint8 result, uint value_won, bytes32 bHash, bytes32 sha3Player, uint gambleId);\r\n    event Loss(address player, uint8 result, uint value_loss, bytes32 bHash, bytes32 sha3Player, uint gambleId);\r\n\r\n    //***//function to spin callable\r\n    // no eth allowed\r\n    function spinTheWheel(address spin_for_player)\r\n    noEthSent\r\n    {\r\n        SpinTheWheel(spin_for_player);\r\n    }\r\n\r\n\r\n    function SpinTheWheel(address playerSpinned) private\r\n    {\r\n        if (playerSpinned==0)\r\n\t{\r\n\t    playerSpinned=msg.sender;         //if no index spins for the sender\r\n\t}\r\n\r\n\t//check that player has to spin\r\n        if (playerStatus[playerSpinned]!=Status.waitingForSpin) throw;\r\n        //redundent double check : check that gamble has not been spinned already\r\n        if (gambles[gambleIndex[playerSpinned]].spinned==true) throw;\r\n        //check that the player waited for the delay before spin\r\n        //and also that the bet is not expired\r\n\tuint playerblock = gambles[gambleIndex[playerSpinned]].blockNumber;\r\n        //too early to spin\r\n\tif (block.number<=playerblock+blockDelay) throw;\r\n        //too late, bet expired, player lost\r\n        else if (block.number>playerblock+blockExpiration)  solveBet(playerSpinned, 255, false, 1, 0, 0) ;\r\n\t//spin !\r\n        else\r\n\t{\r\n\t    uint8 wheelResult;\r\n            //Spin the wheel, \r\n            bytes32 blockHash= block.blockhash(playerblock+blockDelay);\r\n            //security check that the Hash is not empty\r\n            if (blockHash==0) throw;\r\n\t    // generate the hash for RNG from the blockHash and the player's address\r\n            bytes32 shaPlayer = sha3(playerSpinned, blockHash);\r\n\t    // get the final wheel result\r\n\t    wheelResult = uint8(uint256(shaPlayer)%37);\r\n            //check result against bet and pay if win\r\n\t    checkBetResult(wheelResult, playerSpinned, blockHash, shaPlayer);\r\n\t}\r\n    }\r\n    \r\n\r\n    //CHECK BETS FUNCTIONS private\r\n    function checkBetResult(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        BetTypes betType=gambles[gambleIndex[player]].betType;\r\n        //bet on Number\r\n        if (betType==BetTypes.number) checkBetNumber(result, player, blockHash, shaPlayer);\r\n        else if (betType==BetTypes.parity) checkBetParity(result, player, blockHash, shaPlayer);\r\n        else if (betType==BetTypes.color) checkBetColor(result, player, blockHash, shaPlayer);\r\n\telse if (betType==BetTypes.lowhigh) checkBetLowhigh(result, player, blockHash, shaPlayer);\r\n\telse if (betType==BetTypes.dozen) checkBetDozen(result, player, blockHash, shaPlayer);\r\n        else if (betType==BetTypes.column) checkBetColumn(result, player, blockHash, shaPlayer);\r\n        updateMaxBet();  //at the end, update the Max possible bet\r\n    }\r\n\r\n    // function solve Bet once result is determined : sends to winner, adds loss to profit\r\n    function solveBet(address player, uint8 result, bool win, uint8 multiplier, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        //Update status and record spinned\r\n        playerStatus[player]=Status.waitingForBet;\r\n        gambles[gambleIndex[player]].wheelResult=result;\r\n        gambles[gambleIndex[player]].spinned=true;\r\n        gambles[gambleIndex[player]].blockSpinned=block.number;\r\n\tuint bet_v = gambles[gambleIndex[player]].wager;\r\n\t\r\n        if (win)\r\n        {\r\n\t    gambles[gambleIndex[player]].win=true;\r\n\t    uint win_v = (multiplier-1)*bet_v;\r\n            lossSinceChange+=win_v;\r\n            Win(player, result, win_v, blockHash, shaPlayer, gambleIndex[player]);\r\n            //send win!\r\n\t    //safe send vs potential callstack overflowed spins\r\n            if (player.send(win_v+bet_v)==false) throw;\r\n        }\r\n        else\r\n        {\r\n\t    Loss(player, result, bet_v-1, blockHash, shaPlayer, gambleIndex[player]);\r\n            profitSinceChange+=bet_v-1;\r\n            //send 1 wei to confirm spin if loss\r\n            if (player.send(1)==false) throw;\r\n        }\r\n\r\n    }\r\n\r\n    // checkbeton number(input)\r\n    // bet type : number\r\n    // input : chosen number\r\n    function checkBetNumber(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n\tif (result==gambles[gambleIndex[player]].input)\r\n\t{\r\n            win=true;  \r\n        }\r\n        solveBet(player, result,win,36, blockHash, shaPlayer);\r\n    }\r\n\r\n\r\n    // checkbet on oddeven\r\n    // bet type : parity\r\n    // input : 0 for even, 1 for odd\r\n    function checkBetParity(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n\tif (result%2==gambles[gambleIndex[player]].input && result!=0)\r\n\t{\r\n            win=true;                \r\n        }\r\n        solveBet(player,result,win,2, blockHash, shaPlayer);\r\n    }\r\n    \r\n    // checkbet on lowhigh\r\n    // bet type : lowhigh\r\n    // input : 0 low, 1 high\r\n    function checkBetLowhigh(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n\tif (result!=0 && ( (result<19 && gambles[gambleIndex[player]].input==0)\r\n\t\t\t   || (result>18 && gambles[gambleIndex[player]].input==1)\r\n\t\t\t ) )\r\n\t{\r\n            win=true;\r\n        }\r\n        solveBet(player,result,win,2, blockHash, shaPlayer);\r\n    }\r\n\r\n    // checkbet on color\r\n    // bet type : color\r\n    // input : 0 red, 1 black\r\n    uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\r\n    function checkBetColor(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool red;\r\n        //check if red\r\n        for (uint8 k; k<18; k++)\r\n        { \r\n            if (red_list[k]==result) \r\n            { \r\n                red=true; \r\n                break;\r\n            }\r\n        }\r\n        bool win;\r\n        //win\r\n        if ( result!=0\r\n             && ( (gambles[gambleIndex[player]].input==0 && red)  \r\n                  || ( gambles[gambleIndex[player]].input==1 && !red)  ) )\r\n        {\r\n            win=true;\r\n        }\r\n        solveBet(player,result,win,2, blockHash, shaPlayer);\r\n    }\r\n\r\n    // checkbet on dozen\r\n    // bet type : dozen\r\n    // input : 0 first, 1 second, 2 third\r\n    function checkBetDozen(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    { \r\n        bool win;\r\n        //win on first dozen\r\n     \tif ( result!=0 &&\r\n             ( (result<13 && gambles[gambleIndex[player]].input==0)\r\n     \t       ||\r\n               (result>12 && result<25 && gambles[gambleIndex[player]].input==1)\r\n               ||\r\n               (result>24 && gambles[gambleIndex[player]].input==2) ) )\r\n     \t{\r\n            win=true;                \r\n        }\r\n        solveBet(player,result,win,3, blockHash, shaPlayer);\r\n    }\r\n\r\n    // checkbet on column\r\n    // bet type : column\r\n    // input : 0 first, 1 second, 2 third\r\n    function checkBetColumn(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n        if ( result!=0\r\n             && ( (gambles[gambleIndex[player]].input==0 && result%3==1)  \r\n                  || ( gambles[gambleIndex[player]].input==1 && result%3==2)\r\n                  || ( gambles[gambleIndex[player]].input==2 && result%3==0)  ) )\r\n        {\r\n            win=true;\r\n        }\r\n        solveBet(player,result,win,3, blockHash, shaPlayer);\r\n    }\r\n\r\n\r\n    //D.A.O. FUNCTIONS\r\n\r\n\r\n    //total casino payroll\r\n    uint256 payroll;\r\n    //Profit Loss since last investor change\r\n    uint256 profitSinceChange;\r\n    uint256 lossSinceChange;\r\n    //DAO members struct array (hard capped to 777 members (77 VIP + 700 extra members) )\r\n    struct Investor\r\n    {\r\n\taddress investor;\r\n\tuint256 time;\r\n    }\t\r\n    \r\n    Investor[777] private investors; //array of 777 elements (max Rouleth's members nb.)\r\n    uint16 setting_maxInvestors = 77; //Initially restricted to 77 VIP Members\r\n    //Balances of the DAO members\r\n    mapping (address=>uint256) balance; \r\n    //lockPeriod\r\n    //minimum membership time\r\n    uint256 setting_lockPeriod=30 days ;\r\n    uint256 setting_minInvestment=100 ether; //min amount to send when using \"invest()\"\r\n    uint256 setting_maxInvestment=200 ether; //max amount to send when using \"invest()\"\r\n    \r\n    event newInvest(address player, uint invest_v, uint net_invest_v);\r\n\r\n\r\n    //Become a DAO member.\r\n    function invest()\r\n    {\r\n        // update balances before altering the shares            \r\n        updateBalances();\r\n        uint256 netInvest;\r\n        uint excess;\r\n        // reset the open position counter to values out of bounds\r\n        // =999 if full\r\n        uint16 openPosition=999;\r\n        bool alreadyInvestor;\r\n        // loop over array to find if already member, \r\n        // and record a potential openPosition\r\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\r\n        { \r\n            // captures an index of an open position\r\n            if (investors[k].investor==0) openPosition=k; \r\n            // captures if already a member \r\n            else if (investors[k].investor==msg.sender)\r\n            {\r\n                alreadyInvestor=true;\r\n                break;\r\n            }\r\n        }\r\n        //new Member\r\n        if (!alreadyInvestor)\r\n        {\r\n            // check that more than min is sent (variable setting)\r\n            if (msg.value<setting_minInvestment) throw;\r\n            // check that less than max is sent (variable setting)\r\n            // otherwise refund\r\n            if (msg.value>setting_maxInvestment)\r\n            {\r\n                excess=msg.value-setting_maxInvestment;\r\n  \t\tnetInvest=setting_maxInvestment;\r\n            }\r\n\t    else\r\n\t    {\r\n\t\tnetInvest=msg.value;\r\n\t    }\r\n            //members can't become a VIP member after the initial period\r\n            if (setting_maxInvestors >77 && openPosition<77) throw;\r\n            //case : array not full, record new member\r\n            else if (openPosition!=999) investors[openPosition]=Investor(msg.sender, now);\r\n            //case : array full\r\n            else\r\n            {\r\n                throw;\r\n            }\r\n        }\r\n        //already a member\r\n        else\r\n        {\r\n            netInvest=msg.value;\r\n            //is already above the max balance allowed or is sending\r\n\t    // too much refuse additional invest\r\n            if (balance[msg.sender]+msg.value>setting_maxInvestment)\r\n            {\r\n                throw;\r\n            }\r\n\t    // this additionnal amount should be of at least 1/5 of \"setting_minInvestment\" (vs spam)\r\n\t    if (msg.value<setting_minInvestment/5) throw;\r\n        }\r\n\r\n        // add to balance of member and to bankroll\r\n        // 10% of initial 77 VIP members investment is allocated to\r\n        // game developement provider chosen by Rouleth DAO\r\n\t// 90% to bankroll\r\n        //share that will be allocated to game dev\r\n        uint256 developmentAllocation;\r\n        developmentAllocation=10*netInvest/100; \r\n        netInvest-=developmentAllocation;\r\n        //send game development allocation to Rouleth DAO or tech provider\r\n        if (developer.send(developmentAllocation)==false) throw;\r\n\r\n\t// Apply extra entry fee once casino has been opened to extra members\r\n\t// that fee will be shared between the VIP members and represents the increment of\r\n\t// market value of their shares in Rouleth to outsiders\r\n\t// warning if a VIP adds to its initial invest after the casino has been opened to \r\n\t// extra members he will pay have to pay this fee.\r\n        if (setting_maxInvestors>77)\r\n        {\r\n            // % of extra member's investment that rewards VIP funders\r\n            // Starts at 100%\r\n            // is set by a vote and computed when settings are changed\r\n            // to allow more investors\r\n            uint256 entryExtraCost=voted_extraInvestFeesRate*netInvest/100;\r\n            // add to VIP profit (to be shared by later call by dev.)\r\n            profitVIP += entryExtraCost;\r\n            netInvest-=entryExtraCost;\r\n        }\r\n        newInvest(msg.sender, msg.value, netInvest);//event log\r\n        balance[msg.sender]+=netInvest; //add to balance\r\n        payroll+=netInvest; //add to bankroll\r\n        updateMaxBet();\r\n        //refund potential excess\r\n        if (excess>0) \r\n        {\r\n            if (msg.sender.send(excess)==false) throw;\r\n        }\r\n    }\r\n\r\n\r\n    //Allows to transfer your DAO account to another address\r\n    //target should not be currently a DAO member of rouleth\r\n    //enter twice the address to make sure you make no mistake.\r\n    //this can't be reversed if you don't own the target account\r\n    function transferInvestorAccount(address newInvestorAccountOwner, address newInvestorAccountOwner_confirm)\r\n    noEthSent\r\n    {\r\n        if (newInvestorAccountOwner!=newInvestorAccountOwner_confirm) throw;\r\n        if (newInvestorAccountOwner==0) throw;\r\n        //retrieve investor ID\r\n        uint16 investorID=999;\r\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\r\n        {\r\n\t    //new address cant be of a current investor\r\n            if (investors[k].investor==newInvestorAccountOwner) throw;\r\n\r\n\t    //retrieve investor id\r\n            if (investors[k].investor==msg.sender)\r\n            {\r\n                investorID=k;\r\n            }\r\n        }\r\n        if (investorID==999) throw; //stop if not a member\r\n\telse\r\n\t    //accept and execute change of address\r\n\t    //votes on entryFeesRate are not transfered\r\n\t    //new address should vote again\r\n\t{\r\n\t    balance[newInvestorAccountOwner]=balance[msg.sender];\r\n\t    balance[msg.sender]=0;\r\n            investors[investorID].investor=newInvestorAccountOwner;\r\n\t}\r\n    }\r\n    \r\n    //***// Withdraw function (only after lockPeriod)\r\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\r\n    // if your withdraw brings your balance under the min required,\r\n    // your balance is fully withdrawn\r\n    event withdraw(address player, uint withdraw_v);\r\n    \r\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\r\n    noEthSent\r\n    {\r\n\t//vs spam withdraw min 1/10 of min\r\n\tif (amountToWithdrawInWei!=0 && amountToWithdrawInWei<setting_minInvestment/10) throw;\r\n        //before withdraw, update balances with the Profit and Loss sinceChange\r\n        updateBalances();\r\n\t//check that amount requested is authorized  \r\n\tif (amountToWithdrawInWei>balance[msg.sender]) throw;\r\n        //retrieve member ID\r\n        uint16 investorID=999;\r\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\r\n        {\r\n            if (investors[k].investor==msg.sender)\r\n            {\r\n                investorID=k;\r\n                break;\r\n            }\r\n        }\r\n        if (investorID==999) throw; //stop if not a member\r\n        //check if investment lock period is over\r\n        if (investors[investorID].time+setting_lockPeriod>now) throw;\r\n        //if balance left after withdraw is still above min accept partial withdraw\r\n        if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\r\n        {\r\n            balance[msg.sender]-=amountToWithdrawInWei;\r\n            payroll-=amountToWithdrawInWei;\r\n            //send amount to investor (with security if transaction fails)\r\n            if (msg.sender.send(amountToWithdrawInWei)==false) throw;\r\n\t    withdraw(msg.sender, amountToWithdrawInWei);\r\n        }\r\n        else\r\n            //if amountToWithdraw=0 : user wants full withdraw\r\n            //if balance after withdraw is < min invest, withdraw all and delete member\r\n        {\r\n            //send amount to member (with security if transaction fails)\r\n            uint256 fullAmount=balance[msg.sender];\r\n            payroll-=fullAmount;\r\n            balance[msg.sender]=0;\r\n\r\n\t    //delete member\r\n            delete investors[investorID];\r\n            if (msg.sender.send(fullAmount)==false) throw;\r\n   \t    withdraw(msg.sender, fullAmount);\r\n        }\r\n        updateMaxBet();\r\n    }\r\n\r\n    //***// updates balances with Profit Losses when there is a withdraw/deposit\r\n    // can be called by dev for accounting when there are no more changes\r\n    function manualUpdateBalances_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\tupdateBalances();\r\n    }\r\n    function updateBalances() private\r\n    {\r\n        //split Profits\r\n        uint256 profitToSplit;\r\n        uint256 lossToSplit;\r\n        if (profitSinceChange==0 && lossSinceChange==0)\r\n        { return; }\r\n        \r\n        else\r\n        {\r\n            // Case : Global profit (more win than losses)\r\n            // 20% fees for game development on global profit (if profit>loss)\r\n            if (profitSinceChange>lossSinceChange)\r\n            {\r\n                profitToSplit=profitSinceChange-lossSinceChange;\r\n                uint256 developerFees=profitToSplit*20/100;\r\n                profitToSplit-=developerFees;\r\n                if (developer.send(developerFees)==false) throw;\r\n            }\r\n            else\r\n            {\r\n                lossToSplit=lossSinceChange-profitSinceChange;\r\n            }\r\n            \r\n            //share the loss and profits between all DAO members \r\n            //(proportionnaly. to each one's balance)\r\n\r\n            uint totalShared;\r\n            for (uint16 k=0; k<setting_maxInvestors; k++)\r\n            {\r\n                address inv=investors[k].investor;\r\n                if (inv==0) continue;\r\n                else\r\n                {\r\n                    if (profitToSplit!=0) \r\n                    {\r\n                        uint profitShare=(profitToSplit*balance[inv])/payroll;\r\n                        balance[inv]+=profitShare;\r\n                        totalShared+=profitShare;\r\n                    }\r\n                    else if (lossToSplit!=0) \r\n                    {\r\n                        uint lossShare=(lossToSplit*balance[inv])/payroll;\r\n                        balance[inv]-=lossShare;\r\n                        totalShared+=lossShare;\r\n                        \r\n                    }\r\n                }\r\n            }\r\n            // update bankroll\r\n\t    // and handle potential very small left overs from integer div.\r\n            if (profitToSplit !=0) \r\n            {\r\n\t\tpayroll+=profitToSplit;\r\n\t\tbalance[developer]+=profitToSplit-totalShared;\r\n            }\r\n            else if (lossToSplit !=0) \r\n            {\r\n\t\tpayroll-=lossToSplit;\r\n\t\tbalance[developer]-=lossToSplit-totalShared;\r\n            }\r\n            profitSinceChange=0; //reset Profit;\r\n            lossSinceChange=0; //reset Loss ;\r\n        }\r\n    }\r\n    \r\n\r\n    //VIP Voting on Extra Invest Fees Rate\r\n    //mapping records 100 - vote\r\n    mapping (address=>uint) hundredminus_extraInvestFeesRate;\r\n    // max fee is 99%\r\n    // a fee of 100% indicates that the VIP has never voted.\r\n    function voteOnNewEntryFees_only_VIP(uint8 extraInvestFeesRate_0_to_99)\r\n    noEthSent\r\n    {\r\n        if (extraInvestFeesRate_0_to_99<1 || extraInvestFeesRate_0_to_99>99) throw;\r\n        hundredminus_extraInvestFeesRate[msg.sender]=100-extraInvestFeesRate_0_to_99;\r\n    }\r\n\r\n    uint256 payrollVIP;\r\n    uint256 voted_extraInvestFeesRate;\r\n    function computeResultVoteExtraInvestFeesRate() private\r\n    {\r\n        payrollVIP=0;\r\n        voted_extraInvestFeesRate=0;\r\n        //compute total payroll of the VIPs\r\n        //compute vote results among VIPs\r\n        for (uint8 k=0; k<77; k++)\r\n        {\r\n            if (investors[k].investor==0) continue;\r\n            else\r\n            {\r\n                //don't count vote if the VIP never voted\r\n                if (hundredminus_extraInvestFeesRate[investors[k].investor]==0) continue;\r\n                else\r\n                {\r\n                    payrollVIP+=balance[investors[k].investor];\r\n                    voted_extraInvestFeesRate+=hundredminus_extraInvestFeesRate[investors[k].investor]*balance[investors[k].investor];\r\n                }\r\n            }\r\n        }\r\n\t//compute final result\r\n\t    if (payrollVIP!=0)\r\n\t    {\r\n            voted_extraInvestFeesRate=100-voted_extraInvestFeesRate/payrollVIP;\r\n     \t    }\r\n    }\r\n\r\n\r\n    //Split the profits of the VIP members on extra members' contribution\r\n    uint profitVIP;\r\n    function splitProfitVIP_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        payrollVIP=0;\r\n        //compute total payroll of the VIPs\r\n        for (uint8 k=0; k<77; k++)\r\n        {\r\n            if (investors[k].investor==0) continue;\r\n            else\r\n            {\r\n                payrollVIP+=balance[investors[k].investor];\r\n            }\r\n        }\r\n        //split the profits of the VIP members on extra member's contribution\r\n\tuint totalSplit;\r\n        for (uint8 i=0; i<77; i++)\r\n        {\r\n            if (investors[i].investor==0) continue;\r\n            else\r\n            {\r\n\t\tuint toSplit=balance[investors[i].investor]*profitVIP/payrollVIP;\r\n                balance[investors[i].investor]+=toSplit;\r\n\t\ttotalSplit+=toSplit;\r\n            }\r\n        }\r\n\t//take care of Integer Div remainders, and add to bankroll\r\n\tbalance[developer]+=profitVIP-totalSplit;\r\n\tpayroll+=profitVIP;\r\n\t//reset var profitVIP\r\n        profitVIP=0;\r\n    }\r\n\r\n    \r\n    //INFORMATION FUNCTIONS\r\n    function checkProfitLossSinceInvestorChange() constant returns(uint profit_since_update_balances, uint loss_since_update_balances, uint profit_VIP_since_update_balances)\r\n    {\r\n        profit_since_update_balances=profitSinceChange;\r\n        loss_since_update_balances=lossSinceChange;\r\n        profit_VIP_since_update_balances=profitVIP;\t\r\n        return;\r\n    }\r\n\r\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\r\n    {\r\n        balanceInWei=balance[investor];\r\n        return;\r\n    }\r\n\r\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\r\n    {\r\n        investor=investors[index].investor;\r\n        endLockPeriod=investors[index].time+setting_lockPeriod;\r\n        return;\r\n    }\r\n    \r\n    function investmentEntryInfos() constant returns(uint current_max_nb_of_investors, uint investLockPeriod, uint voted_Fees_Rate_on_extra_investments)\r\n    {\r\n    \tinvestLockPeriod=setting_lockPeriod;\r\n    \tvoted_Fees_Rate_on_extra_investments=voted_extraInvestFeesRate;\r\n    \tcurrent_max_nb_of_investors=setting_maxInvestors;\r\n    \treturn;\r\n    }\r\n    \r\n    function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\r\n    {\r\n    \tmaxBet=currentMaxGamble;\r\n    \tblockDelayBeforeSpin=blockDelay;\r\n    \treturn ;\r\n    }\r\n\r\n    function getTotalGambles() constant returns(uint _totalGambles)\r\n    {\r\n        _totalGambles=totalGambles;\r\n    \treturn ;\r\n    }\r\n    \r\n    function getPayroll() constant returns(uint payroll_at_last_update_balances)\r\n    {\r\n        payroll_at_last_update_balances=payroll;\r\n    \treturn ;\r\n    }\r\n\r\n    \r\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin, uint gambleID)\r\n    {\r\n        player_status=playerStatus[player];\r\n        bettype=gambles[gambleIndex[player]].betType;\r\n        input=gambles[gambleIndex[player]].input;\r\n        value=gambles[gambleIndex[player]].wager;\r\n        result=gambles[gambleIndex[player]].wheelResult;\r\n        wheelspinned=gambles[gambleIndex[player]].spinned;\r\n        win=gambles[gambleIndex[player]].win;\r\n        blockNb=gambles[gambleIndex[player]].blockNumber;\r\n        blockSpin=gambles[gambleIndex[player]].blockSpinned;\r\n    \tgambleID=gambleIndex[player];\r\n    \treturn;\r\n    }\r\n    \r\n    function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin)\r\n    {\r\n        player=gambles[index].player;\r\n        bettype=gambles[index].betType;\r\n        input=gambles[index].input;\r\n        value=gambles[index].wager;\r\n        result=gambles[index].wheelResult;\r\n        wheelspinned=gambles[index].spinned;\r\n        win=gambles[index].win;\r\n    \tblockNb=gambles[index].blockNumber;\r\n        blockSpin=gambles[index].blockSpinned;\r\n    \treturn;\r\n    }\r\n\r\n} //end of contract", 
  "balance": "9,401<b>.</b>25949999514259373 Ether", 
  "name": "Rouleth", 
  "address": "0x18a672e11d637fffadccc99b152f4895da069601", 
  "transactions": "25867"
 }, 
 {
  "source": "contract Ambi {\r\n    function getNodeAddress(bytes32 _name) constant returns (address);\r\n    function addNode(bytes32 _name, address _addr) external returns (bool);\r\n    function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool);\r\n}\r\n\r\ncontract PotRewards {\r\n    function transfer(address _from, address _to, uint _amount);\r\n}\r\n\r\ncontract PosRewards {\r\n    function transfer(address _from, address _to);\r\n}\r\n\r\ncontract ElcoinInterface {\r\n    function rewardTo(address _to, uint _amount) returns (bool);\r\n}\r\n\r\ncontract EtherTreasuryInterface {\r\n    function withdraw(address _to, uint _value) returns(bool);\r\n}\r\n\r\ncontract MetaCoinInterface {\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approved(address indexed _owner, address indexed _spender, uint256 _value);\r\n\tevent Unapproved(address indexed _owner, address indexed _spender);\r\n\r\n\tfunction totalSupply() constant returns (uint256 supply){}\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance){}\r\n\tfunction transfer(address _to, uint256 _value) returns (bool success){}\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success){}\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success){}\r\n\tfunction unapprove(address _spender) returns (bool success){}\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining){}\r\n}\r\n\r\ncontract ElcoinDb {\r\n    function getBalance(address addr) constant returns(uint balance);\r\n    function deposit(address addr, uint amount, bytes32 hash, uint time) returns (bool res);\r\n    function withdraw(address addr, uint amount, bytes32 hash, uint time) returns (bool res);\r\n}\r\n\r\ncontract AmbiEnabled {\r\n    Ambi ambiC;\r\n    bytes32 public name;\r\n\r\n    modifier checkAccess(bytes32 _role) {\r\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\r\n            _\r\n        }\r\n    }\r\n    \r\n    function getAddress(bytes32 _name) constant returns (address) {\r\n        return ambiC.getNodeAddress(_name);\r\n    }\r\n\r\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\r\n        if(address(ambiC) != 0x0){\r\n            return false;\r\n        }\r\n        Ambi ambiContract = Ambi(_ambi);\r\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\r\n            bool isNode = ambiContract.addNode(_name, address(this));\r\n            if (!isNode){\r\n                return false;\r\n            }   \r\n        }\r\n        name = _name;\r\n        ambiC = ambiContract;\r\n        return true;\r\n    }\r\n\r\n    function remove() checkAccess(\"owner\") {\r\n        suicide(msg.sender);\r\n    }\r\n}\r\n\r\ncontract Elcoin is AmbiEnabled, MetaCoinInterface {\r\n\r\n    event Error(uint8 indexed code, address indexed origin, address indexed sender);\r\n\r\n    mapping (address => uint) public recoveredIndex;\r\n    address[] public recovered;\r\n\r\n    uint public totalSupply;\r\n    uint public absMinFee; // set up in 1/1000000 of Elcoin\r\n    uint public feePercent; // set up in 1/100 of percent, 10 is 0.1%\r\n    uint public absMaxFee; // set up in 1/1000000 of Elcoin\r\n    address public feeAddr;\r\n\r\n    function Elcoin() {\r\n        recovered.length++;\r\n        feeAddr = tx.origin;\r\n        _setFeeStructure(0, 0, 1);\r\n    }\r\n\r\n    function _db() internal constant returns (ElcoinDb) {\r\n        return ElcoinDb(getAddress(\"elcoinDb\"));\r\n    }\r\n\r\n    function _setFeeStructure(uint _absMinFee, uint _feePercent, uint _absMaxFee) internal returns (bool) {\r\n        if(_absMinFee < 0 || _feePercent < 0 || _feePercent > 10000 || _absMaxFee < 0 || _absMaxFee < _absMinFee) {\r\n            Error(1, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n        absMinFee = _absMinFee;\r\n        feePercent = _feePercent;\r\n        absMaxFee = _absMaxFee;\r\n        return true;\r\n    }\r\n\r\n    function _rawTransfer(ElcoinDb _db, address _from, address _to, uint _value) internal {\r\n        _db.withdraw(_from, _value, 0, 0);\r\n        uint fee = calculateFee(_value);\r\n        uint net = _value - fee;\r\n        _db.deposit(_to, net, 0, 0);\r\n\r\n        Transfer(_from, _to, _value);\r\n        if (fee > 0) {\r\n            _db.deposit(feeAddr, fee, 0, 0);\r\n        }\r\n    }\r\n\r\n    function _transfer(ElcoinDb _db, address _from, address _to, uint _value) internal returns (bool) {\r\n        if (_value < absMinFee) {\r\n            return false;\r\n        }\r\n        if (_from == _to) {\r\n            return false;\r\n        }\r\n        uint balance = _db.getBalance(_from);\r\n\r\n        if (balance < _value) {\r\n            return false;\r\n        }\r\n        _rawTransfer(_db, _from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transferWithReward(ElcoinDb _db, address _from, address _to, uint _value) internal returns (bool) {\r\n        if (!_transfer(_db, _from, _to, _value)) {\r\n            Error(2, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        address pos = getAddress(\"elcoinPoS\");\r\n        address pot = getAddress(\"elcoinPoT\");\r\n        if (pos != 0x0) {\r\n            PosRewards(pos).transfer(_from, _to);\r\n        }\r\n        if (pot != 0x0) {\r\n            PotRewards(pot).transfer(_from, _to, _value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _recoverAccount(ElcoinDb _db, address _old, address _new) internal returns (bool) {\r\n        uint pos =  recovered.length++;\r\n        recovered[pos] = _old;\r\n        recoveredIndex[_old] = pos;\r\n        uint balance = _db.getBalance(_old);\r\n        var rv = _db.withdraw(_old, balance, 0, 0);\r\n        if (!rv) {\r\n            Error(5, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n        _db.deposit(_new, balance, 0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    modifier notRecoveredAccount(address _account) {\r\n        if(recoveredIndex[_account] == 0x0) {\r\n            _\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _account) constant returns (uint) {\r\n        return _db().getBalance(_account);\r\n    }\r\n\r\n    function calculateFee(uint _amount) constant returns (uint) {\r\n        uint fee = (_amount * feePercent) / 10000;\r\n\r\n        if (fee < absMinFee) {\r\n            return absMinFee;\r\n        }\r\n\r\n        if (fee > absMaxFee) {\r\n            return absMaxFee;\r\n        }\r\n\r\n        return fee;\r\n    }\r\n\r\n    function issueCoin(address _to, uint _value, uint _totalSupply) checkAccess(\"currencyOwner\") returns (bool) {\r\n        if (totalSupply > 0) {\r\n            Error(6, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        bool dep = _db().deposit(_to, _value, 0, 0);\r\n        totalSupply = _totalSupply;\r\n        return dep;\r\n    }\r\n\r\n    function batchTransfer(address[] _to, uint[] _value) checkAccess(\"currencyOwner\") returns (bool) {\r\n        if (_to.length != _value.length) {\r\n            Error(7, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        uint totalToSend = 0;\r\n        for (uint8 i = 0; i < _value.length; i++) {\r\n            totalToSend += _value[i];\r\n        }\r\n\r\n        ElcoinDb db = _db();\r\n        if (db.getBalance(msg.sender) < totalToSend) {\r\n            Error(8, tx.origin, msg.sender);\r\n            return false;\r\n        }\r\n\r\n        db.withdraw(msg.sender, totalToSend, 0, 0);\r\n        for (uint8 j = 0; j < _to.length; j++) {\r\n            db.deposit(_to[j], _value[j], 0, 0);\r\n            Transfer(msg.sender, _to[j], _value[j]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        uint startGas = msg.gas + transferCallGas;\r\n        if (!_transferWithReward(_db(), msg.sender, _to, _value)) {\r\n            return false;\r\n        }\r\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\r\n        return _refund(refund);\r\n    }\r\n\r\n    function transferPool(address _from, address _to, uint _value) checkAccess(\"pool\") returns (bool) {\r\n        return _transferWithReward(_db(), _from, _to, _value);\r\n    }\r\n\r\n    function rewardTo(address _to, uint _amount) checkAccess(\"reward\") returns (bool) {\r\n        bool result = _db().deposit(_to, _amount, 0, 0);\r\n        if (result) {\r\n            totalSupply += _amount;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function recoverAccount(address _old, address _new) checkAccess(\"recovery\") notRecoveredAccount(_old) returns (bool) {\r\n        return _recoverAccount(_db(), _old, _new);\r\n    }\r\n\r\n    function setFeeAddr(address _feeAddr) checkAccess(\"currencyOwner\") {\r\n        feeAddr = _feeAddr;\r\n    }\r\n\r\n    function setFee(uint _absMinFee, uint _feePercent, uint _absMaxFee) checkAccess(\"cron\") returns (bool) {\r\n        return _setFeeStructure(_absMinFee, _feePercent, _absMaxFee);\r\n    }\r\n\r\n    uint public txGasPriceLimit = 21000000000;\r\n    uint public transferCallGas = 21000;\r\n    uint public refundGas = 15000;\r\n    EtherTreasuryInterface treasury;\r\n\r\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(\"currencyOwner\") returns (bool) {\r\n        if (_txGasPriceLimit == 0) {\r\n            return false;\r\n        }\r\n        treasury = EtherTreasuryInterface(_treasury);\r\n        txGasPriceLimit = _txGasPriceLimit;\r\n        if (msg.value > 0 && !address(treasury).send(msg.value)) {\r\n            throw;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function updateRefundGas() checkAccess(\"currencyOwner\") returns (uint) {\r\n        uint startGas = msg.gas;\r\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice; // just to simulate calculations, dunno if optimizer will remove this.\r\n        if (!_refund(1)) {\r\n            return 0;\r\n        }\r\n        refundGas = startGas - msg.gas;\r\n        return refundGas;\r\n    }\r\n\r\n    function setOperationsCallGas(uint _transfer) checkAccess(\"currencyOwner\") returns (bool) {\r\n        transferCallGas = _transfer;\r\n        return true;\r\n    }\r\n\r\n    function _refund(uint _value) internal returns (bool) {\r\n        if (tx.gasprice > txGasPriceLimit) {\r\n            return false;\r\n        }\r\n        return treasury.withdraw(tx.origin, _value);\r\n    }\r\n}", 
  "balance": "0<b>.</b>000000000000019292 Ether", 
  "name": "Elcoin", 
  "address": "0x57d90b64a1a57749b0f932f1a3395792e12e7055", 
  "transactions": "21928"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "0 Ether", 
  "name": "Wallet", 
  "transactions": "1", 
  "address": "0xad951be7ff90580d539c6b3eec899aec57e400a7"
 }, 
 {
  "source": "//sol Wallet\r\n// Multi-sig, daily-limited account proxy/wallet.\r\n// @authors:\r\n// Gav Wood <g@ethdev.com>\r\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\r\n// single, or, crucially, each of a number of, designated owners.\r\n// usage:\r\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\r\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\r\n// interior is executed.\r\ncontract multiowned {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has five types of events: it can accept a confirmation, in which case\r\n    // we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    // some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n    \r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n    \r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        // make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                // not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n    \r\n    // list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    // index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n// uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n    // MODIFIERS\r\n\r\n    // simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\r\n        m_spentToday = 0;\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    // returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        // reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        // check to see if there's enough left - if so, subtract and return true.\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // determines today's index.\r\n    function today() private constant returns (uint) { return now / 1 days; }\r\n\r\n    // FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n// interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n    // EVENTS\r\n\r\n    // logged events:\r\n    // Funds has arrived into the wallet (record how much).\r\n    event Deposit(address from, uint value);\r\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    // Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n    \r\n    // FUNCTIONS\r\n    \r\n    // TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\n// usage:\r\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n// Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit {\r\n\r\n    uint public version = 2;\r\n\r\n    // TYPES\r\n\r\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor - just pass on the owner array to the multiowned and\r\n    // the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n    \r\n    // kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\r\n        suicide(_to);\r\n    }\r\n    \r\n    // gets called when no other function matches\r\n    function() {\r\n        // just being sent some cash?\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n    \r\n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\r\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    // and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        // first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            // yes - just execute the call.\r\n            _to.call.value(_value)(_data);\r\n            return 0;\r\n        }\r\n        // determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n    \r\n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    // to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}", 
  "balance": "0 Ether", 
  "name": "Wallet", 
  "transactions": "1", 
  "address": "0xc919e9ba27bb93cdb2e64f02762df0d1b6a0d836"
 }
]